
> typeextractor@1.0.0 start /Users/michieldral/Projects/Bukkit-Unchained/TypeExtractor
> ../graal-bin/bin/node --inspect --jvm --polyglot --vm.cp=$(gradle classpath -q) ./src/TypeExtractor.js

declare interface $co$aikar$timings$FullServerTickHandler {
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  isViolated(): boolean;
  isEnabled(): boolean;
  isSpecial(): boolean;
  close(): void;
  hashCode(): number;
  equals(arg0: any): boolean;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  stopTimingIfSync(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
}

declare class co$aikar$timings$FullServerTickHandler
  implements $co$aikar$timings$FullServerTickHandler {
  constructor();
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  isViolated(): boolean;
  isEnabled(): boolean;
  isSpecial(): boolean;
  close(): void;
  hashCode(): number;
  equals(arg0: any): boolean;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  stopTimingIfSync(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  abort(): void;
}


declare interface $co$aikar$timings$Timing {
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  abort(): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  close(): void;
}

declare class co$aikar$timings$Timing implements $co$aikar$timings$Timing {
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  abort(): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  close(): void;
}


declare interface $co$aikar$timings$TimingHandler
  extends $co$aikar$timings$Timing {
  checkEnabled(): void;
  processTick(arg0: boolean): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  abort(): void;
  addDiff(arg0: number, arg1: co$aikar$timings$TimingHandler): void;
  reset(arg0: boolean): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  equals(arg0: any): boolean;
  hashCode(): number;
  close(): void;
  isSpecial(): boolean;
  isTimed(): boolean;
  isEnabled(): boolean;
  cloneChildren(): JavaArray<co$aikar$timings$TimingData>;
}

declare class co$aikar$timings$TimingHandler
  implements $co$aikar$timings$TimingHandler {
  constructor(arg0: co$aikar$timings$TimingIdentifier);
  checkEnabled(): void;
  processTick(arg0: boolean): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  abort(): void;
  addDiff(arg0: number, arg1: co$aikar$timings$TimingHandler): void;
  reset(arg0: boolean): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  equals(arg0: any): boolean;
  hashCode(): number;
  close(): void;
  isSpecial(): boolean;
  isTimed(): boolean;
  isEnabled(): boolean;
  cloneChildren(): JavaArray<co$aikar$timings$TimingData>;
}


declare interface $co$aikar$timings$TimingIdentifier {
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}

declare class co$aikar$timings$TimingIdentifier
  implements $co$aikar$timings$TimingIdentifier {
  constructor(arg0: string, arg1: string, arg2: co$aikar$timings$Timing);
  static getGroup(arg0: string): co$aikar$timings$TimingIdentifier$TimingGroup;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}


declare interface $co$aikar$timings$TimingIdentifier$TimingGroup {
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class co$aikar$timings$TimingIdentifier$TimingGroup
  implements $co$aikar$timings$TimingIdentifier$TimingGroup {
  equals(arg0: any): boolean;
  hashCode(): number;
  constructor(arg0: string, arg1: co$aikar$timings$TimingIdentifier$1);
}


declare interface $co$aikar$timings$TimingIdentifier$1 {}

declare class co$aikar$timings$TimingIdentifier$1
  implements $co$aikar$timings$TimingIdentifier$1 {}


declare interface $co$aikar$timings$TimingData {
  add(arg0: number): void;
  processTick(arg0: boolean): void;
  reset(): void;
  clone(): co$aikar$timings$TimingData;
  export(): any /* java.util.List */;
  hasData(): boolean;
  getTotalTime(): number;
  getCurTickCount(): number;
  setCurTickCount(arg0: number): void;
  getCurTickTotal(): number;
  setCurTickTotal(arg0: number): void;
  clone(): any;
}

declare class co$aikar$timings$TimingData
  implements $co$aikar$timings$TimingData {
  constructor(arg0: number);
  add(arg0: number): void;
  processTick(arg0: boolean): void;
  reset(): void;
  clone(): co$aikar$timings$TimingData;
  export(): any /* java.util.List */;
  hasData(): boolean;
  getTotalTime(): number;
  getCurTickCount(): number;
  setCurTickCount(arg0: number): void;
  getCurTickTotal(): number;
  setCurTickTotal(arg0: number): void;
  clone(): any;
}


declare interface $co$aikar$timings$NullTimingHandler
  extends $co$aikar$timings$Timing {
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  abort(): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  close(): void;
}

declare class co$aikar$timings$NullTimingHandler
  implements $co$aikar$timings$NullTimingHandler {
  static NULL: co$aikar$timings$Timing;
  constructor();
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  abort(): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  close(): void;
}


declare interface $co$aikar$timings$TimedEventExecutor
  extends $org$bukkit$plugin$EventExecutor {
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
}

declare class co$aikar$timings$TimedEventExecutor
  implements $co$aikar$timings$TimedEventExecutor {
  constructor(
    arg0: org$bukkit$plugin$EventExecutor,
    arg1: org$bukkit$plugin$Plugin,
    arg2: any /* java.lang.reflect.Method */,
    arg3: any /* java.lang.Class */
  );
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
  static eventExecutorMap: any; /* java.util.concurrent.ConcurrentMap */
  static create(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.lang.Class */
  ): org$bukkit$plugin$EventExecutor;
}


declare interface $org$bukkit$plugin$EventExecutor {
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
}

declare class org$bukkit$plugin$EventExecutor
  implements $org$bukkit$plugin$EventExecutor {
  static eventExecutorMap: any; /* java.util.concurrent.ConcurrentMap */
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
  static create(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.lang.Class */
  ): org$bukkit$plugin$EventExecutor;
}


declare interface $org$bukkit$event$Listener {}

declare class org$bukkit$event$Listener implements $org$bukkit$event$Listener {}


declare interface $org$bukkit$event$Event {
  callEvent(): boolean;
  getEventName(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  isAsynchronous(): boolean;
}

declare class org$bukkit$event$Event implements $org$bukkit$event$Event {
  constructor();
  constructor(arg0: boolean);
  callEvent(): boolean;
  getEventName(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  isAsynchronous(): boolean;
}


declare interface $org$bukkit$event$HandlerList {
  register(arg0: org$bukkit$plugin$RegisteredListener): void;
  registerAll(arg0: java$util$Collection): void;
  unregister(arg0: org$bukkit$plugin$RegisteredListener): void;
  unregister(arg0: org$bukkit$plugin$Plugin): void;
  unregister(arg0: org$bukkit$event$Listener): void;
  bake(): void;
  getRegisteredListeners(): JavaArray<org$bukkit$plugin$RegisteredListener>;
}

declare class org$bukkit$event$HandlerList
  implements $org$bukkit$event$HandlerList {
  static bakeAll(): void;
  static unregisterAll(): void;
  static unregisterAll(arg0: org$bukkit$plugin$Plugin): void;
  static unregisterAll(arg0: org$bukkit$event$Listener): void;
  constructor();
  register(arg0: org$bukkit$plugin$RegisteredListener): void;
  registerAll(arg0: java$util$Collection): void;
  unregister(arg0: org$bukkit$plugin$RegisteredListener): void;
  unregister(arg0: org$bukkit$plugin$Plugin): void;
  unregister(arg0: org$bukkit$event$Listener): void;
  bake(): void;
  getRegisteredListeners(): JavaArray<org$bukkit$plugin$RegisteredListener>;
  static getRegisteredListeners(
    arg0: org$bukkit$plugin$Plugin
  ): any /* java.util.ArrayList */;
  static getHandlerLists(): any /* java.util.ArrayList */;
}


declare interface $org$bukkit$plugin$Plugin
  extends $org$bukkit$command$TabExecutor {
  getDataFolder(): any /* java.io.File */;
  getDescription(): org$bukkit$plugin$PluginDescriptionFile;
  getConfig(): org$bukkit$configuration$file$FileConfiguration;
  getResource(arg0: string): any /* java.io.InputStream */;
  saveConfig(): void;
  saveDefaultConfig(): void;
  saveResource(arg0: string, arg1: boolean): void;
  reloadConfig(): void;
  getPluginLoader(): org$bukkit$plugin$PluginLoader;
  getServer(): org$bukkit$Server;
  isEnabled(): boolean;
  onDisable(): void;
  onLoad(): void;
  onEnable(): void;
  isNaggable(): boolean;
  setNaggable(arg0: boolean): void;
  getDefaultWorldGenerator(
    arg0: string,
    arg1: string
  ): org$bukkit$generator$ChunkGenerator;
  getLogger(): any /* java.util.logging.Logger */;
  getSLF4JLogger(): unknown;
  getName(): string;
}

declare class org$bukkit$plugin$Plugin implements $org$bukkit$plugin$Plugin {
  getDataFolder(): any /* java.io.File */;
  getDescription(): org$bukkit$plugin$PluginDescriptionFile;
  getConfig(): org$bukkit$configuration$file$FileConfiguration;
  getResource(arg0: string): any /* java.io.InputStream */;
  saveConfig(): void;
  saveDefaultConfig(): void;
  saveResource(arg0: string, arg1: boolean): void;
  reloadConfig(): void;
  getPluginLoader(): org$bukkit$plugin$PluginLoader;
  getServer(): org$bukkit$Server;
  isEnabled(): boolean;
  onDisable(): void;
  onLoad(): void;
  onEnable(): void;
  isNaggable(): boolean;
  setNaggable(arg0: boolean): void;
  getDefaultWorldGenerator(
    arg0: string,
    arg1: string
  ): org$bukkit$generator$ChunkGenerator;
  getLogger(): any /* java.util.logging.Logger */;
  getSLF4JLogger(): unknown;
  getName(): string;
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
}


declare interface $org$bukkit$command$CommandExecutor {
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
}

declare class org$bukkit$command$CommandExecutor
  implements $org$bukkit$command$CommandExecutor {
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
}


declare interface $org$bukkit$command$CommandSender
  extends $org$bukkit$permissions$Permissible {
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
}

declare class org$bukkit$command$CommandSender
  implements $org$bukkit$command$CommandSender {
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$permissions$Permissible
  extends $org$bukkit$permissions$ServerOperator {
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
}

declare class org$bukkit$permissions$Permissible
  implements $org$bukkit$permissions$Permissible {
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$permissions$ServerOperator {
  isOp(): boolean;
  setOp(arg0: boolean): void;
}

declare class org$bukkit$permissions$ServerOperator
  implements $org$bukkit$permissions$ServerOperator {
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$permissions$Permission {
  getName(): string;
  getChildren(): any /* java.util.Map */;
  getDefault(): org$bukkit$permissions$PermissionDefault;
  setDefault(arg0: org$bukkit$permissions$PermissionDefault): void;
  getDescription(): string;
  setDescription(arg0: string): void;
  getPermissibles(): any /* java.util.Set */;
  recalculatePermissibles(): void;
  addParent(arg0: string, arg1: boolean): org$bukkit$permissions$Permission;
  addParent(arg0: org$bukkit$permissions$Permission, arg1: boolean): void;
}

declare class org$bukkit$permissions$Permission
  implements $org$bukkit$permissions$Permission {
  static DEFAULT_PERMISSION: org$bukkit$permissions$PermissionDefault;
  constructor(arg0: string);
  constructor(arg0: string, arg1: string);
  constructor(arg0: string, arg1: org$bukkit$permissions$PermissionDefault);
  constructor(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault
  );
  constructor(arg0: string, arg1: any /* java.util.Map */);
  constructor(arg0: string, arg1: string, arg2: any /* java.util.Map */);
  constructor(
    arg0: string,
    arg1: org$bukkit$permissions$PermissionDefault,
    arg2: any /* java.util.Map */
  );
  constructor(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault,
    arg3: any /* java.util.Map */
  );
  getName(): string;
  getChildren(): any /* java.util.Map */;
  getDefault(): org$bukkit$permissions$PermissionDefault;
  setDefault(arg0: org$bukkit$permissions$PermissionDefault): void;
  getDescription(): string;
  setDescription(arg0: string): void;
  getPermissibles(): any /* java.util.Set */;
  recalculatePermissibles(): void;
  addParent(arg0: string, arg1: boolean): org$bukkit$permissions$Permission;
  addParent(arg0: org$bukkit$permissions$Permission, arg1: boolean): void;
  static loadPermissions(
    arg0: any /* java.util.Map */,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault
  ): any /* java.util.List */;
  static loadPermission(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$permissions$Permission;
  static loadPermission(
    arg0: string,
    arg1: any /* java.util.Map */,
    arg2: org$bukkit$permissions$PermissionDefault,
    arg3: any /* java.util.List */
  ): org$bukkit$permissions$Permission;
}


declare interface $org$bukkit$permissions$PermissionDefault {
  getValue(arg0: boolean): boolean;
  toString(): string;
}

declare class org$bukkit$permissions$PermissionDefault
  implements $org$bukkit$permissions$PermissionDefault {
  static TRUE: org$bukkit$permissions$PermissionDefault;
  static FALSE: org$bukkit$permissions$PermissionDefault;
  static OP: org$bukkit$permissions$PermissionDefault;
  static NOT_OP: org$bukkit$permissions$PermissionDefault;
  static values(): JavaArray<org$bukkit$permissions$PermissionDefault>;
  static valueOf(arg0: string): org$bukkit$permissions$PermissionDefault;
  getValue(arg0: boolean): boolean;
  static getByName(arg0: string): org$bukkit$permissions$PermissionDefault;
  toString(): string;
}


declare interface $org$bukkit$permissions$PermissionAttachment {
  getPlugin(): org$bukkit$plugin$Plugin;
  setRemovalCallback(
    arg0: org$bukkit$permissions$PermissionRemovedExecutor
  ): void;
  getRemovalCallback(): org$bukkit$permissions$PermissionRemovedExecutor;
  getPermissible(): org$bukkit$permissions$Permissible;
  getPermissions(): any /* java.util.Map */;
  setPermission(arg0: string, arg1: boolean): void;
  setPermission(arg0: org$bukkit$permissions$Permission, arg1: boolean): void;
  unsetPermission(arg0: string): void;
  unsetPermission(arg0: org$bukkit$permissions$Permission): void;
  remove(): boolean;
}

declare class org$bukkit$permissions$PermissionAttachment
  implements $org$bukkit$permissions$PermissionAttachment {
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$permissions$Permissible
  );
  getPlugin(): org$bukkit$plugin$Plugin;
  setRemovalCallback(
    arg0: org$bukkit$permissions$PermissionRemovedExecutor
  ): void;
  getRemovalCallback(): org$bukkit$permissions$PermissionRemovedExecutor;
  getPermissible(): org$bukkit$permissions$Permissible;
  getPermissions(): any /* java.util.Map */;
  setPermission(arg0: string, arg1: boolean): void;
  setPermission(arg0: org$bukkit$permissions$Permission, arg1: boolean): void;
  unsetPermission(arg0: string): void;
  unsetPermission(arg0: org$bukkit$permissions$Permission): void;
  remove(): boolean;
}


declare interface $org$bukkit$permissions$PermissionRemovedExecutor {
  attachmentRemoved(arg0: org$bukkit$permissions$PermissionAttachment): void;
}

declare class org$bukkit$permissions$PermissionRemovedExecutor
  implements $org$bukkit$permissions$PermissionRemovedExecutor {
  attachmentRemoved(arg0: org$bukkit$permissions$PermissionAttachment): void;
}


declare interface $org$bukkit$Server
  extends $org$bukkit$plugin$messaging$PluginMessageRecipient {
  getName(): string;
  getVersion(): string;
  getBukkitVersion(): string;
  getMinecraftVersion(): string;
  getOnlinePlayers(): java$util$Collection;
  getMaxPlayers(): number;
  getPort(): number;
  getViewDistance(): number;
  getIp(): string;
  getWorldType(): string;
  getGenerateStructures(): boolean;
  getAllowEnd(): boolean;
  getAllowNether(): boolean;
  hasWhitelist(): boolean;
  setWhitelist(arg0: boolean): void;
  getWhitelistedPlayers(): any /* java.util.Set */;
  reloadWhitelist(): void;
  broadcastMessage(arg0: string): number;
  broadcast(arg0: unknown): void;
  broadcast(arg0: JavaArray<unknown>): void;
  getUpdateFolder(): string;
  getUpdateFolderFile(): any /* java.io.File */;
  getConnectionThrottle(): number;
  getTicksPerAnimalSpawns(): number;
  getTicksPerMonsterSpawns(): number;
  getTicksPerWaterSpawns(): number;
  getTicksPerAmbientSpawns(): number;
  getPlayer(arg0: string): org$bukkit$entity$Player;
  getPlayerExact(arg0: string): org$bukkit$entity$Player;
  matchPlayer(arg0: string): any /* java.util.List */;
  getPlayer(arg0: any /* java.util.UUID */): org$bukkit$entity$Player;
  getPlayerUniqueId(arg0: string): any /* java.util.UUID */;
  getPluginManager(): org$bukkit$plugin$PluginManager;
  getScheduler(): org$bukkit$scheduler$BukkitScheduler;
  getServicesManager(): org$bukkit$plugin$ServicesManager;
  getWorlds(): any /* java.util.List */;
  createWorld(arg0: org$bukkit$WorldCreator): org$bukkit$World;
  unloadWorld(arg0: string, arg1: boolean): boolean;
  unloadWorld(arg0: org$bukkit$World, arg1: boolean): boolean;
  getWorld(arg0: string): org$bukkit$World;
  getWorld(arg0: any /* java.util.UUID */): org$bukkit$World;
  getMap(arg0: number): org$bukkit$map$MapView;
  createMap(arg0: org$bukkit$World): org$bukkit$map$MapView;
  createExplorerMap(
    arg0: org$bukkit$World,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$StructureType
  ): org$bukkit$inventory$ItemStack;
  createExplorerMap(
    arg0: org$bukkit$World,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$StructureType,
    arg3: number,
    arg4: boolean
  ): org$bukkit$inventory$ItemStack;
  reload(): void;
  reloadData(): void;
  getLogger(): any /* java.util.logging.Logger */;
  getPluginCommand(arg0: string): org$bukkit$command$PluginCommand;
  savePlayers(): void;
  dispatchCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): boolean;
  addRecipe(arg0: org$bukkit$inventory$Recipe): boolean;
  getRecipesFor(arg0: org$bukkit$inventory$ItemStack): any /* java.util.List */;
  recipeIterator(): any /* java.util.Iterator */;
  clearRecipes(): void;
  resetRecipes(): void;
  removeRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  getCommandAliases(): any /* java.util.Map */;
  getSpawnRadius(): number;
  setSpawnRadius(arg0: number): void;
  getOnlineMode(): boolean;
  getAllowFlight(): boolean;
  isHardcore(): boolean;
  shutdown(): void;
  broadcast(arg0: string, arg1: string): number;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(arg0: any /* java.util.UUID */): org$bukkit$OfflinePlayer;
  getIPBans(): any /* java.util.Set */;
  banIP(arg0: string): void;
  unbanIP(arg0: string): void;
  getBannedPlayers(): any /* java.util.Set */;
  getBanList(arg0: org$bukkit$BanList$Type): org$bukkit$BanList;
  getOperators(): any /* java.util.Set */;
  getDefaultGameMode(): org$bukkit$GameMode;
  setDefaultGameMode(arg0: org$bukkit$GameMode): void;
  getConsoleSender(): org$bukkit$command$ConsoleCommandSender;
  getWorldContainer(): any /* java.io.File */;
  getOfflinePlayers(): JavaArray<org$bukkit$OfflinePlayer>;
  getMessenger(): org$bukkit$plugin$messaging$Messenger;
  getHelpMap(): org$bukkit$help$HelpMap;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: org$bukkit$event$inventory$InventoryType
  ): org$bukkit$inventory$Inventory;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: org$bukkit$event$inventory$InventoryType,
    arg2: string
  ): org$bukkit$inventory$Inventory;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: number
  ): org$bukkit$inventory$Inventory;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: number,
    arg2: string
  ): org$bukkit$inventory$Inventory;
  createMerchant(arg0: string): org$bukkit$inventory$Merchant;
  getMonsterSpawnLimit(): number;
  getAnimalSpawnLimit(): number;
  getWaterAnimalSpawnLimit(): number;
  getAmbientSpawnLimit(): number;
  isPrimaryThread(): boolean;
  getMotd(): string;
  getShutdownMessage(): string;
  getWarningState(): org$bukkit$Warning$WarningState;
  getItemFactory(): org$bukkit$inventory$ItemFactory;
  getScoreboardManager(): org$bukkit$scoreboard$ScoreboardManager;
  getServerIcon(): org$bukkit$util$CachedServerIcon;
  loadServerIcon(
    arg0: any /* java.io.File */
  ): org$bukkit$util$CachedServerIcon;
  loadServerIcon(
    arg0: any /* java.awt.image.BufferedImage */
  ): org$bukkit$util$CachedServerIcon;
  setIdleTimeout(arg0: number): void;
  getIdleTimeout(): number;
  createChunkData(
    arg0: org$bukkit$World
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  createBossBar(
    arg0: string,
    arg1: org$bukkit$boss$BarColor,
    arg2: org$bukkit$boss$BarStyle,
    arg3: JavaArray<org$bukkit$boss$BarFlag>
  ): org$bukkit$boss$BossBar;
  createBossBar(
    arg0: org$bukkit$NamespacedKey,
    arg1: string,
    arg2: org$bukkit$boss$BarColor,
    arg3: org$bukkit$boss$BarStyle,
    arg4: JavaArray<org$bukkit$boss$BarFlag>
  ): org$bukkit$boss$KeyedBossBar;
  getBossBars(): any /* java.util.Iterator */;
  getBossBar(arg0: org$bukkit$NamespacedKey): org$bukkit$boss$KeyedBossBar;
  removeBossBar(arg0: org$bukkit$NamespacedKey): boolean;
  getEntity(arg0: any /* java.util.UUID */): org$bukkit$entity$Entity;
  getTPS(): JavaArray<number>;
  getTickTimes(): JavaArray<number>;
  getAverageTickTime(): number;
  getCommandMap(): org$bukkit$command$CommandMap;
  getAdvancement(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$advancement$Advancement;
  advancementIterator(): any /* java.util.Iterator */;
  createBlockData(arg0: org$bukkit$Material): org$bukkit$block$data$BlockData;
  createBlockData(
    arg0: org$bukkit$Material,
    arg1: any /* java.util.function.Consumer */
  ): org$bukkit$block$data$BlockData;
  createBlockData(arg0: string): org$bukkit$block$data$BlockData;
  createBlockData(
    arg0: org$bukkit$Material,
    arg1: string
  ): org$bukkit$block$data$BlockData;
  getTag(
    arg0: string,
    arg1: org$bukkit$NamespacedKey,
    arg2: any /* java.lang.Class */
  ): org$bukkit$Tag;
  getTags(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): any /* java.lang.Iterable */;
  getLootTable(arg0: org$bukkit$NamespacedKey): org$bukkit$loot$LootTable;
  selectEntities(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  getUnsafe(): org$bukkit$UnsafeValues;
  spigot(): org$bukkit$Server$Spigot;
  reloadPermissions(): void;
  reloadCommandAliases(): boolean;
  suggestPlayerNamesWhenNullTabCompletions(): boolean;
  getPermissionMessage(): string;
  createProfile(
    arg0: any /* java.util.UUID */
  ): com$destroystokyo$paper$profile$PlayerProfile;
  createProfile(arg0: string): com$destroystokyo$paper$profile$PlayerProfile;
  createProfile(
    arg0: any /* java.util.UUID */,
    arg1: string
  ): com$destroystokyo$paper$profile$PlayerProfile;
  getCurrentTick(): number;
  isStopping(): boolean;
  getMobGoals(): com$destroystokyo$paper$entity$ai$MobGoals;
}

declare class org$bukkit$Server implements $org$bukkit$Server {
  static BROADCAST_CHANNEL_ADMINISTRATIVE: string;
  static BROADCAST_CHANNEL_USERS: string;
  getName(): string;
  getVersion(): string;
  getBukkitVersion(): string;
  getMinecraftVersion(): string;
  getOnlinePlayers(): java$util$Collection;
  getMaxPlayers(): number;
  getPort(): number;
  getViewDistance(): number;
  getIp(): string;
  getWorldType(): string;
  getGenerateStructures(): boolean;
  getAllowEnd(): boolean;
  getAllowNether(): boolean;
  hasWhitelist(): boolean;
  setWhitelist(arg0: boolean): void;
  getWhitelistedPlayers(): any /* java.util.Set */;
  reloadWhitelist(): void;
  broadcastMessage(arg0: string): number;
  broadcast(arg0: unknown): void;
  broadcast(arg0: JavaArray<unknown>): void;
  getUpdateFolder(): string;
  getUpdateFolderFile(): any /* java.io.File */;
  getConnectionThrottle(): number;
  getTicksPerAnimalSpawns(): number;
  getTicksPerMonsterSpawns(): number;
  getTicksPerWaterSpawns(): number;
  getTicksPerAmbientSpawns(): number;
  getPlayer(arg0: string): org$bukkit$entity$Player;
  getPlayerExact(arg0: string): org$bukkit$entity$Player;
  matchPlayer(arg0: string): any /* java.util.List */;
  getPlayer(arg0: any /* java.util.UUID */): org$bukkit$entity$Player;
  getPlayerUniqueId(arg0: string): any /* java.util.UUID */;
  getPluginManager(): org$bukkit$plugin$PluginManager;
  getScheduler(): org$bukkit$scheduler$BukkitScheduler;
  getServicesManager(): org$bukkit$plugin$ServicesManager;
  getWorlds(): any /* java.util.List */;
  createWorld(arg0: org$bukkit$WorldCreator): org$bukkit$World;
  unloadWorld(arg0: string, arg1: boolean): boolean;
  unloadWorld(arg0: org$bukkit$World, arg1: boolean): boolean;
  getWorld(arg0: string): org$bukkit$World;
  getWorld(arg0: any /* java.util.UUID */): org$bukkit$World;
  getMap(arg0: number): org$bukkit$map$MapView;
  createMap(arg0: org$bukkit$World): org$bukkit$map$MapView;
  createExplorerMap(
    arg0: org$bukkit$World,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$StructureType
  ): org$bukkit$inventory$ItemStack;
  createExplorerMap(
    arg0: org$bukkit$World,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$StructureType,
    arg3: number,
    arg4: boolean
  ): org$bukkit$inventory$ItemStack;
  reload(): void;
  reloadData(): void;
  getLogger(): any /* java.util.logging.Logger */;
  getPluginCommand(arg0: string): org$bukkit$command$PluginCommand;
  savePlayers(): void;
  dispatchCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): boolean;
  addRecipe(arg0: org$bukkit$inventory$Recipe): boolean;
  getRecipesFor(arg0: org$bukkit$inventory$ItemStack): any /* java.util.List */;
  recipeIterator(): any /* java.util.Iterator */;
  clearRecipes(): void;
  resetRecipes(): void;
  removeRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  getCommandAliases(): any /* java.util.Map */;
  getSpawnRadius(): number;
  setSpawnRadius(arg0: number): void;
  getOnlineMode(): boolean;
  getAllowFlight(): boolean;
  isHardcore(): boolean;
  shutdown(): void;
  broadcast(arg0: string, arg1: string): number;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(arg0: any /* java.util.UUID */): org$bukkit$OfflinePlayer;
  getIPBans(): any /* java.util.Set */;
  banIP(arg0: string): void;
  unbanIP(arg0: string): void;
  getBannedPlayers(): any /* java.util.Set */;
  getBanList(arg0: org$bukkit$BanList$Type): org$bukkit$BanList;
  getOperators(): any /* java.util.Set */;
  getDefaultGameMode(): org$bukkit$GameMode;
  setDefaultGameMode(arg0: org$bukkit$GameMode): void;
  getConsoleSender(): org$bukkit$command$ConsoleCommandSender;
  getWorldContainer(): any /* java.io.File */;
  getOfflinePlayers(): JavaArray<org$bukkit$OfflinePlayer>;
  getMessenger(): org$bukkit$plugin$messaging$Messenger;
  getHelpMap(): org$bukkit$help$HelpMap;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: org$bukkit$event$inventory$InventoryType
  ): org$bukkit$inventory$Inventory;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: org$bukkit$event$inventory$InventoryType,
    arg2: string
  ): org$bukkit$inventory$Inventory;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: number
  ): org$bukkit$inventory$Inventory;
  createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: number,
    arg2: string
  ): org$bukkit$inventory$Inventory;
  createMerchant(arg0: string): org$bukkit$inventory$Merchant;
  getMonsterSpawnLimit(): number;
  getAnimalSpawnLimit(): number;
  getWaterAnimalSpawnLimit(): number;
  getAmbientSpawnLimit(): number;
  isPrimaryThread(): boolean;
  getMotd(): string;
  getShutdownMessage(): string;
  getWarningState(): org$bukkit$Warning$WarningState;
  getItemFactory(): org$bukkit$inventory$ItemFactory;
  getScoreboardManager(): org$bukkit$scoreboard$ScoreboardManager;
  getServerIcon(): org$bukkit$util$CachedServerIcon;
  loadServerIcon(
    arg0: any /* java.io.File */
  ): org$bukkit$util$CachedServerIcon;
  loadServerIcon(
    arg0: any /* java.awt.image.BufferedImage */
  ): org$bukkit$util$CachedServerIcon;
  setIdleTimeout(arg0: number): void;
  getIdleTimeout(): number;
  createChunkData(
    arg0: org$bukkit$World
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  createBossBar(
    arg0: string,
    arg1: org$bukkit$boss$BarColor,
    arg2: org$bukkit$boss$BarStyle,
    arg3: JavaArray<org$bukkit$boss$BarFlag>
  ): org$bukkit$boss$BossBar;
  createBossBar(
    arg0: org$bukkit$NamespacedKey,
    arg1: string,
    arg2: org$bukkit$boss$BarColor,
    arg3: org$bukkit$boss$BarStyle,
    arg4: JavaArray<org$bukkit$boss$BarFlag>
  ): org$bukkit$boss$KeyedBossBar;
  getBossBars(): any /* java.util.Iterator */;
  getBossBar(arg0: org$bukkit$NamespacedKey): org$bukkit$boss$KeyedBossBar;
  removeBossBar(arg0: org$bukkit$NamespacedKey): boolean;
  getEntity(arg0: any /* java.util.UUID */): org$bukkit$entity$Entity;
  getTPS(): JavaArray<number>;
  getTickTimes(): JavaArray<number>;
  getAverageTickTime(): number;
  getCommandMap(): org$bukkit$command$CommandMap;
  getAdvancement(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$advancement$Advancement;
  advancementIterator(): any /* java.util.Iterator */;
  createBlockData(arg0: org$bukkit$Material): org$bukkit$block$data$BlockData;
  createBlockData(
    arg0: org$bukkit$Material,
    arg1: any /* java.util.function.Consumer */
  ): org$bukkit$block$data$BlockData;
  createBlockData(arg0: string): org$bukkit$block$data$BlockData;
  createBlockData(
    arg0: org$bukkit$Material,
    arg1: string
  ): org$bukkit$block$data$BlockData;
  getTag(
    arg0: string,
    arg1: org$bukkit$NamespacedKey,
    arg2: any /* java.lang.Class */
  ): org$bukkit$Tag;
  getTags(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): any /* java.lang.Iterable */;
  getLootTable(arg0: org$bukkit$NamespacedKey): org$bukkit$loot$LootTable;
  selectEntities(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  getUnsafe(): org$bukkit$UnsafeValues;
  spigot(): org$bukkit$Server$Spigot;
  reloadPermissions(): void;
  reloadCommandAliases(): boolean;
  suggestPlayerNamesWhenNullTabCompletions(): boolean;
  getPermissionMessage(): string;
  createProfile(
    arg0: any /* java.util.UUID */
  ): com$destroystokyo$paper$profile$PlayerProfile;
  createProfile(arg0: string): com$destroystokyo$paper$profile$PlayerProfile;
  createProfile(
    arg0: any /* java.util.UUID */,
    arg1: string
  ): com$destroystokyo$paper$profile$PlayerProfile;
  getCurrentTick(): number;
  isStopping(): boolean;
  getMobGoals(): com$destroystokyo$paper$entity$ai$MobGoals;
  sendPluginMessage(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
  getListeningPluginChannels(): any /* java.util.Set */;
}


declare interface $org$bukkit$plugin$messaging$PluginMessageRecipient {
  sendPluginMessage(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
  getListeningPluginChannels(): any /* java.util.Set */;
}

declare class org$bukkit$plugin$messaging$PluginMessageRecipient
  implements $org$bukkit$plugin$messaging$PluginMessageRecipient {
  sendPluginMessage(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
  getListeningPluginChannels(): any /* java.util.Set */;
}


declare interface $java$util$Collection {
  size(): number;
  isEmpty(): boolean;
  contains(arg0: any): boolean;
  iterator(): any /* java.util.Iterator */;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  addAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  equals(arg0: any): boolean;
  hashCode(): number;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}

declare class java$util$Collection implements $java$util$Collection {
  size(): number;
  isEmpty(): boolean;
  contains(arg0: any): boolean;
  iterator(): any /* java.util.Iterator */;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  addAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  equals(arg0: any): boolean;
  hashCode(): number;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}


declare interface $org$bukkit$entity$Player
  extends $org$bukkit$entity$HumanEntity,
    $org$bukkit$conversations$Conversable,
    $org$bukkit$OfflinePlayer,
    $org$bukkit$plugin$messaging$PluginMessageRecipient,
    $com$destroystokyo$paper$network$NetworkClient {
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  getPlayerListName(): string;
  setPlayerListName(arg0: string): void;
  getPlayerListHeader(): string;
  getPlayerListFooter(): string;
  setPlayerListHeader(arg0: string): void;
  setPlayerListFooter(arg0: string): void;
  setPlayerListHeaderFooter(arg0: string, arg1: string): void;
  setCompassTarget(arg0: org$bukkit$Location): void;
  getCompassTarget(): org$bukkit$Location;
  getAddress(): any /* java.net.InetSocketAddress */;
  sendRawMessage(arg0: string): void;
  kickPlayer(arg0: string): void;
  chat(arg0: string): void;
  performCommand(arg0: string): boolean;
  isSneaking(): boolean;
  setSneaking(arg0: boolean): void;
  isSprinting(): boolean;
  setSprinting(arg0: boolean): void;
  saveData(): void;
  loadData(): void;
  setSleepingIgnored(arg0: boolean): void;
  isSleepingIgnored(): boolean;
  playNote(arg0: org$bukkit$Location, arg1: Buffer, arg2: Buffer): void;
  playNote(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Instrument,
    arg2: org$bukkit$Note
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  stopSound(arg0: org$bukkit$Sound): void;
  stopSound(arg0: string): void;
  stopSound(arg0: org$bukkit$Sound, arg1: org$bukkit$SoundCategory): void;
  stopSound(arg0: string, arg1: org$bukkit$SoundCategory): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: number
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: any
  ): void;
  sendBlockChange(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Material,
    arg2: Buffer
  ): void;
  sendBlockChange(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$block$data$BlockData
  ): void;
  sendChunkChange(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: JavaArray<Buffer>
  ): boolean;
  sendSignChange(arg0: org$bukkit$Location, arg1: JavaArray<string>): void;
  sendSignChange(
    arg0: org$bukkit$Location,
    arg1: JavaArray<string>,
    arg2: org$bukkit$DyeColor
  ): void;
  sendMap(arg0: org$bukkit$map$MapView): void;
  banPlayerFull(arg0: string): org$bukkit$BanEntry;
  banPlayerFull(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayerFull(
    arg0: string,
    arg1: any /* java.util.Date */
  ): org$bukkit$BanEntry;
  banPlayerFull(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayerIP(arg0: string, arg1: boolean): org$bukkit$BanEntry;
  banPlayerIP(arg0: string, arg1: string, arg2: boolean): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: boolean
  ): org$bukkit$BanEntry;
  banPlayerIP(arg0: string): org$bukkit$BanEntry;
  banPlayerIP(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */
  ): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string,
    arg3: boolean
  ): org$bukkit$BanEntry;
  sendActionBar(arg0: string): void;
  sendActionBar(arg0: string, arg1: string): void;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  sendMessage(arg0: unknown, arg1: JavaArray<unknown>): void;
  setPlayerListHeaderFooter(
    arg0: JavaArray<unknown>,
    arg1: JavaArray<unknown>
  ): void;
  setPlayerListHeaderFooter(arg0: unknown, arg1: unknown): void;
  setTitleTimes(arg0: number, arg1: number, arg2: number): void;
  setSubtitle(arg0: JavaArray<unknown>): void;
  setSubtitle(arg0: unknown): void;
  showTitle(arg0: JavaArray<unknown>): void;
  showTitle(arg0: unknown): void;
  showTitle(
    arg0: JavaArray<unknown>,
    arg1: JavaArray<unknown>,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  showTitle(
    arg0: unknown,
    arg1: unknown,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  sendTitle(arg0: com$destroystokyo$paper$Title): void;
  updateTitle(arg0: com$destroystokyo$paper$Title): void;
  hideTitle(): void;
  updateInventory(): void;
  setPlayerTime(arg0: number, arg1: boolean): void;
  getPlayerTime(): number;
  getPlayerTimeOffset(): number;
  isPlayerTimeRelative(): boolean;
  resetPlayerTime(): void;
  setPlayerWeather(arg0: org$bukkit$WeatherType): void;
  getPlayerWeather(): org$bukkit$WeatherType;
  resetPlayerWeather(): void;
  giveExp(arg0: number): void;
  giveExp(arg0: number, arg1: boolean): void;
  applyMending(arg0: number): number;
  giveExpLevels(arg0: number): void;
  getExp(): number;
  setExp(arg0: number): void;
  getLevel(): number;
  setLevel(arg0: number): void;
  getTotalExperience(): number;
  setTotalExperience(arg0: number): void;
  sendExperienceChange(arg0: number): void;
  sendExperienceChange(arg0: number, arg1: number): void;
  getExhaustion(): number;
  setExhaustion(arg0: number): void;
  getSaturation(): number;
  setSaturation(arg0: number): void;
  getFoodLevel(): number;
  setFoodLevel(arg0: number): void;
  getAllowFlight(): boolean;
  setAllowFlight(arg0: boolean): void;
  hidePlayer(arg0: org$bukkit$entity$Player): void;
  hidePlayer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$entity$Player
  ): void;
  showPlayer(arg0: org$bukkit$entity$Player): void;
  showPlayer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$entity$Player
  ): void;
  canSee(arg0: org$bukkit$entity$Player): boolean;
  isFlying(): boolean;
  setFlying(arg0: boolean): void;
  setFlySpeed(arg0: number): void;
  setWalkSpeed(arg0: number): void;
  getFlySpeed(): number;
  getWalkSpeed(): number;
  setTexturePack(arg0: string): void;
  setResourcePack(arg0: string): void;
  setResourcePack(arg0: string, arg1: JavaArray<Buffer>): void;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
  setScoreboard(arg0: org$bukkit$scoreboard$Scoreboard): void;
  isHealthScaled(): boolean;
  setHealthScaled(arg0: boolean): void;
  setHealthScale(arg0: number): void;
  getHealthScale(): number;
  getSpectatorTarget(): org$bukkit$entity$Entity;
  setSpectatorTarget(arg0: org$bukkit$entity$Entity): void;
  sendTitle(arg0: string, arg1: string): void;
  sendTitle(
    arg0: string,
    arg1: string,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  resetTitle(): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: any
  ): void;
  getAdvancementProgress(
    arg0: org$bukkit$advancement$Advancement
  ): org$bukkit$advancement$AdvancementProgress;
  getClientViewDistance(): number;
  getLocale(): string;
  getAffectsSpawning(): boolean;
  setAffectsSpawning(arg0: boolean): void;
  getViewDistance(): number;
  setViewDistance(arg0: number): void;
  updateCommands(): void;
  openBook(arg0: org$bukkit$inventory$ItemStack): void;
  setResourcePack(arg0: string, arg1: string): void;
  getResourcePackStatus(): org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  getResourcePackHash(): string;
  hasResourcePack(): boolean;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  getCooldownPeriod(): number;
  getCooledAttackStrength(arg0: number): number;
  resetCooldown(): void;
  getClientOption(arg0: com$destroystokyo$paper$ClientOption): any;
  spigot(): org$bukkit$entity$Player$Spigot;
  spigot(): org$bukkit$entity$Entity$Spigot;
  spigot(): org$bukkit$command$CommandSender$Spigot;
}

declare class org$bukkit$entity$Player implements $org$bukkit$entity$Player {
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  getPlayerListName(): string;
  setPlayerListName(arg0: string): void;
  getPlayerListHeader(): string;
  getPlayerListFooter(): string;
  setPlayerListHeader(arg0: string): void;
  setPlayerListFooter(arg0: string): void;
  setPlayerListHeaderFooter(arg0: string, arg1: string): void;
  setCompassTarget(arg0: org$bukkit$Location): void;
  getCompassTarget(): org$bukkit$Location;
  getAddress(): any /* java.net.InetSocketAddress */;
  sendRawMessage(arg0: string): void;
  kickPlayer(arg0: string): void;
  chat(arg0: string): void;
  performCommand(arg0: string): boolean;
  isSneaking(): boolean;
  setSneaking(arg0: boolean): void;
  isSprinting(): boolean;
  setSprinting(arg0: boolean): void;
  saveData(): void;
  loadData(): void;
  setSleepingIgnored(arg0: boolean): void;
  isSleepingIgnored(): boolean;
  playNote(arg0: org$bukkit$Location, arg1: Buffer, arg2: Buffer): void;
  playNote(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Instrument,
    arg2: org$bukkit$Note
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  stopSound(arg0: org$bukkit$Sound): void;
  stopSound(arg0: string): void;
  stopSound(arg0: org$bukkit$Sound, arg1: org$bukkit$SoundCategory): void;
  stopSound(arg0: string, arg1: org$bukkit$SoundCategory): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: number
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: any
  ): void;
  sendBlockChange(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Material,
    arg2: Buffer
  ): void;
  sendBlockChange(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$block$data$BlockData
  ): void;
  sendChunkChange(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: JavaArray<Buffer>
  ): boolean;
  sendSignChange(arg0: org$bukkit$Location, arg1: JavaArray<string>): void;
  sendSignChange(
    arg0: org$bukkit$Location,
    arg1: JavaArray<string>,
    arg2: org$bukkit$DyeColor
  ): void;
  sendMap(arg0: org$bukkit$map$MapView): void;
  banPlayerFull(arg0: string): org$bukkit$BanEntry;
  banPlayerFull(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayerFull(
    arg0: string,
    arg1: any /* java.util.Date */
  ): org$bukkit$BanEntry;
  banPlayerFull(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayerIP(arg0: string, arg1: boolean): org$bukkit$BanEntry;
  banPlayerIP(arg0: string, arg1: string, arg2: boolean): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: boolean
  ): org$bukkit$BanEntry;
  banPlayerIP(arg0: string): org$bukkit$BanEntry;
  banPlayerIP(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */
  ): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayerIP(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string,
    arg3: boolean
  ): org$bukkit$BanEntry;
  sendActionBar(arg0: string): void;
  sendActionBar(arg0: string, arg1: string): void;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  sendMessage(arg0: unknown, arg1: JavaArray<unknown>): void;
  setPlayerListHeaderFooter(
    arg0: JavaArray<unknown>,
    arg1: JavaArray<unknown>
  ): void;
  setPlayerListHeaderFooter(arg0: unknown, arg1: unknown): void;
  setTitleTimes(arg0: number, arg1: number, arg2: number): void;
  setSubtitle(arg0: JavaArray<unknown>): void;
  setSubtitle(arg0: unknown): void;
  showTitle(arg0: JavaArray<unknown>): void;
  showTitle(arg0: unknown): void;
  showTitle(
    arg0: JavaArray<unknown>,
    arg1: JavaArray<unknown>,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  showTitle(
    arg0: unknown,
    arg1: unknown,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  sendTitle(arg0: com$destroystokyo$paper$Title): void;
  updateTitle(arg0: com$destroystokyo$paper$Title): void;
  hideTitle(): void;
  updateInventory(): void;
  setPlayerTime(arg0: number, arg1: boolean): void;
  getPlayerTime(): number;
  getPlayerTimeOffset(): number;
  isPlayerTimeRelative(): boolean;
  resetPlayerTime(): void;
  setPlayerWeather(arg0: org$bukkit$WeatherType): void;
  getPlayerWeather(): org$bukkit$WeatherType;
  resetPlayerWeather(): void;
  giveExp(arg0: number): void;
  giveExp(arg0: number, arg1: boolean): void;
  applyMending(arg0: number): number;
  giveExpLevels(arg0: number): void;
  getExp(): number;
  setExp(arg0: number): void;
  getLevel(): number;
  setLevel(arg0: number): void;
  getTotalExperience(): number;
  setTotalExperience(arg0: number): void;
  sendExperienceChange(arg0: number): void;
  sendExperienceChange(arg0: number, arg1: number): void;
  getExhaustion(): number;
  setExhaustion(arg0: number): void;
  getSaturation(): number;
  setSaturation(arg0: number): void;
  getFoodLevel(): number;
  setFoodLevel(arg0: number): void;
  getAllowFlight(): boolean;
  setAllowFlight(arg0: boolean): void;
  hidePlayer(arg0: org$bukkit$entity$Player): void;
  hidePlayer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$entity$Player
  ): void;
  showPlayer(arg0: org$bukkit$entity$Player): void;
  showPlayer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$entity$Player
  ): void;
  canSee(arg0: org$bukkit$entity$Player): boolean;
  isFlying(): boolean;
  setFlying(arg0: boolean): void;
  setFlySpeed(arg0: number): void;
  setWalkSpeed(arg0: number): void;
  getFlySpeed(): number;
  getWalkSpeed(): number;
  setTexturePack(arg0: string): void;
  setResourcePack(arg0: string): void;
  setResourcePack(arg0: string, arg1: JavaArray<Buffer>): void;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
  setScoreboard(arg0: org$bukkit$scoreboard$Scoreboard): void;
  isHealthScaled(): boolean;
  setHealthScaled(arg0: boolean): void;
  setHealthScale(arg0: number): void;
  getHealthScale(): number;
  getSpectatorTarget(): org$bukkit$entity$Entity;
  setSpectatorTarget(arg0: org$bukkit$entity$Entity): void;
  sendTitle(arg0: string, arg1: string): void;
  sendTitle(
    arg0: string,
    arg1: string,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  resetTitle(): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: any
  ): void;
  getAdvancementProgress(
    arg0: org$bukkit$advancement$Advancement
  ): org$bukkit$advancement$AdvancementProgress;
  getClientViewDistance(): number;
  getLocale(): string;
  getAffectsSpawning(): boolean;
  setAffectsSpawning(arg0: boolean): void;
  getViewDistance(): number;
  setViewDistance(arg0: number): void;
  updateCommands(): void;
  openBook(arg0: org$bukkit$inventory$ItemStack): void;
  setResourcePack(arg0: string, arg1: string): void;
  getResourcePackStatus(): org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  getResourcePackHash(): string;
  hasResourcePack(): boolean;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  getCooldownPeriod(): number;
  getCooledAttackStrength(arg0: number): number;
  resetCooldown(): void;
  getClientOption(arg0: com$destroystokyo$paper$ClientOption): any;
  spigot(): org$bukkit$entity$Player$Spigot;
  spigot(): org$bukkit$entity$Entity$Spigot;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  getProtocolVersion(): number;
  getVirtualHost(): any /* java.net.InetSocketAddress */;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  isOnline(): boolean;
  getName(): string;
  getUniqueId(): any /* java.util.UUID */;
  isBanned(): boolean;
  banPlayer(arg0: string): org$bukkit$BanEntry;
  banPlayer(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayer(arg0: string, arg1: any /* java.util.Date */): org$bukkit$BanEntry;
  banPlayer(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayer(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string,
    arg3: boolean
  ): org$bukkit$BanEntry;
  isWhitelisted(): boolean;
  setWhitelisted(arg0: boolean): void;
  getPlayer(): org$bukkit$entity$Player;
  getFirstPlayed(): number;
  getLastPlayed(): number;
  hasPlayedBefore(): boolean;
  getBedSpawnLocation(): org$bukkit$Location;
  getLastLogin(): number;
  getLastSeen(): number;
  incrementStatistic(arg0: org$bukkit$Statistic): void;
  decrementStatistic(arg0: org$bukkit$Statistic): void;
  incrementStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  decrementStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  setStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  getStatistic(arg0: org$bukkit$Statistic): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material
  ): void;
  getStatistic(arg0: org$bukkit$Statistic, arg1: org$bukkit$Material): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  setStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): void;
  getStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  setStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  serialize(): any /* java.util.Map */;
  isConversing(): boolean;
  acceptConversationInput(arg0: string): void;
  beginConversation(arg0: org$bukkit$conversations$Conversation): boolean;
  abandonConversation(arg0: org$bukkit$conversations$Conversation): void;
  abandonConversation(
    arg0: org$bukkit$conversations$Conversation,
    arg1: org$bukkit$conversations$ConversationAbandonedEvent
  ): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getInventory(): org$bukkit$inventory$PlayerInventory;
  getEnderChest(): org$bukkit$inventory$Inventory;
  getMainHand(): org$bukkit$inventory$MainHand;
  setWindowProperty(
    arg0: org$bukkit$inventory$InventoryView$Property,
    arg1: number
  ): boolean;
  getOpenInventory(): org$bukkit$inventory$InventoryView;
  openInventory(
    arg0: org$bukkit$inventory$Inventory
  ): org$bukkit$inventory$InventoryView;
  openWorkbench(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openEnchanting(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openInventory(arg0: org$bukkit$inventory$InventoryView): void;
  openMerchant(
    arg0: org$bukkit$entity$Villager,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openMerchant(
    arg0: org$bukkit$inventory$Merchant,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  closeInventory(): void;
  closeInventory(
    arg0: org$bukkit$event$inventory$InventoryCloseEvent$Reason
  ): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemOnCursor(): org$bukkit$inventory$ItemStack;
  setItemOnCursor(arg0: org$bukkit$inventory$ItemStack): void;
  hasCooldown(arg0: org$bukkit$Material): boolean;
  getCooldown(arg0: org$bukkit$Material): number;
  setCooldown(arg0: org$bukkit$Material, arg1: number): void;
  getSleepTicks(): number;
  getPotentialBedLocation(): org$bukkit$Location;
  setBedSpawnLocation(arg0: org$bukkit$Location): void;
  setBedSpawnLocation(arg0: org$bukkit$Location, arg1: boolean): void;
  sleep(arg0: org$bukkit$Location, arg1: boolean): boolean;
  wakeup(arg0: boolean): void;
  getBedLocation(): org$bukkit$Location;
  getGameMode(): org$bukkit$GameMode;
  setGameMode(arg0: org$bukkit$GameMode): void;
  isBlocking(): boolean;
  isHandRaised(): boolean;
  getExpToLevel(): number;
  releaseLeftShoulderEntity(): org$bukkit$entity$Entity;
  releaseRightShoulderEntity(): org$bukkit$entity$Entity;
  getAttackCooldown(): number;
  discoverRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  discoverRecipes(arg0: java$util$Collection): number;
  undiscoverRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  undiscoverRecipes(arg0: java$util$Collection): number;
  getShoulderEntityLeft(): org$bukkit$entity$Entity;
  setShoulderEntityLeft(arg0: org$bukkit$entity$Entity): void;
  getShoulderEntityRight(): org$bukkit$entity$Entity;
  setShoulderEntityRight(arg0: org$bukkit$entity$Entity): void;
  openSign(arg0: org$bukkit$block$Sign): void;
  getInventory(): org$bukkit$inventory$Inventory;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  sendPluginMessage(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
  getListeningPluginChannels(): any /* java.util.Set */;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$network$NetworkClient {
  getAddress(): any /* java.net.InetSocketAddress */;
  getProtocolVersion(): number;
  getVirtualHost(): any /* java.net.InetSocketAddress */;
}

declare class com$destroystokyo$paper$network$NetworkClient
  implements $com$destroystokyo$paper$network$NetworkClient {
  getAddress(): any /* java.net.InetSocketAddress */;
  getProtocolVersion(): number;
  getVirtualHost(): any /* java.net.InetSocketAddress */;
}


declare interface $org$bukkit$Nameable {
  getCustomName(): string;
  setCustomName(arg0: string): void;
}

declare class org$bukkit$Nameable implements $org$bukkit$Nameable {
  getCustomName(): string;
  setCustomName(arg0: string): void;
}


declare interface $org$bukkit$OfflinePlayer
  extends $org$bukkit$permissions$ServerOperator,
    $org$bukkit$entity$AnimalTamer,
    $org$bukkit$configuration$serialization$ConfigurationSerializable {
  isOnline(): boolean;
  getName(): string;
  getUniqueId(): any /* java.util.UUID */;
  isBanned(): boolean;
  banPlayer(arg0: string): org$bukkit$BanEntry;
  banPlayer(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayer(arg0: string, arg1: any /* java.util.Date */): org$bukkit$BanEntry;
  banPlayer(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayer(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string,
    arg3: boolean
  ): org$bukkit$BanEntry;
  isWhitelisted(): boolean;
  setWhitelisted(arg0: boolean): void;
  getPlayer(): org$bukkit$entity$Player;
  getFirstPlayed(): number;
  getLastPlayed(): number;
  hasPlayedBefore(): boolean;
  getBedSpawnLocation(): org$bukkit$Location;
  getLastLogin(): number;
  getLastSeen(): number;
  incrementStatistic(arg0: org$bukkit$Statistic): void;
  decrementStatistic(arg0: org$bukkit$Statistic): void;
  incrementStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  decrementStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  setStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  getStatistic(arg0: org$bukkit$Statistic): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material
  ): void;
  getStatistic(arg0: org$bukkit$Statistic, arg1: org$bukkit$Material): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  setStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): void;
  getStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  setStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
}

declare class org$bukkit$OfflinePlayer implements $org$bukkit$OfflinePlayer {
  isOnline(): boolean;
  getName(): string;
  getUniqueId(): any /* java.util.UUID */;
  isBanned(): boolean;
  banPlayer(arg0: string): org$bukkit$BanEntry;
  banPlayer(arg0: string, arg1: string): org$bukkit$BanEntry;
  banPlayer(arg0: string, arg1: any /* java.util.Date */): org$bukkit$BanEntry;
  banPlayer(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string
  ): org$bukkit$BanEntry;
  banPlayer(
    arg0: string,
    arg1: any /* java.util.Date */,
    arg2: string,
    arg3: boolean
  ): org$bukkit$BanEntry;
  isWhitelisted(): boolean;
  setWhitelisted(arg0: boolean): void;
  getPlayer(): org$bukkit$entity$Player;
  getFirstPlayed(): number;
  getLastPlayed(): number;
  hasPlayedBefore(): boolean;
  getBedSpawnLocation(): org$bukkit$Location;
  getLastLogin(): number;
  getLastSeen(): number;
  incrementStatistic(arg0: org$bukkit$Statistic): void;
  decrementStatistic(arg0: org$bukkit$Statistic): void;
  incrementStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  decrementStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  setStatistic(arg0: org$bukkit$Statistic, arg1: number): void;
  getStatistic(arg0: org$bukkit$Statistic): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material
  ): void;
  getStatistic(arg0: org$bukkit$Statistic, arg1: org$bukkit$Material): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  setStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$Material,
    arg2: number
  ): void;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): void;
  getStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType
  ): number;
  incrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  decrementStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  setStatistic(
    arg0: org$bukkit$Statistic,
    arg1: org$bukkit$entity$EntityType,
    arg2: number
  ): void;
  serialize(): any /* java.util.Map */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$configuration$serialization$ConfigurationSerializable {
  serialize(): any /* java.util.Map */;
}

declare class org$bukkit$configuration$serialization$ConfigurationSerializable
  implements $org$bukkit$configuration$serialization$ConfigurationSerializable {
  serialize(): any /* java.util.Map */;
}


declare interface $org$bukkit$entity$AnimalTamer {
  getName(): string;
  getUniqueId(): any /* java.util.UUID */;
}

declare class org$bukkit$entity$AnimalTamer
  implements $org$bukkit$entity$AnimalTamer {
  getName(): string;
  getUniqueId(): any /* java.util.UUID */;
}


declare interface $org$bukkit$BanEntry {
  getTarget(): string;
  getCreated(): any /* java.util.Date */;
  setCreated(arg0: any /* java.util.Date */): void;
  getSource(): string;
  setSource(arg0: string): void;
  getExpiration(): any /* java.util.Date */;
  setExpiration(arg0: any /* java.util.Date */): void;
  getReason(): string;
  setReason(arg0: string): void;
  save(): void;
}

declare class org$bukkit$BanEntry implements $org$bukkit$BanEntry {
  getTarget(): string;
  getCreated(): any /* java.util.Date */;
  setCreated(arg0: any /* java.util.Date */): void;
  getSource(): string;
  setSource(arg0: string): void;
  getExpiration(): any /* java.util.Date */;
  setExpiration(arg0: any /* java.util.Date */): void;
  getReason(): string;
  setReason(arg0: string): void;
  save(): void;
}


declare interface $org$bukkit$Location
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  setWorld(arg0: org$bukkit$World): void;
  isWorldLoaded(): boolean;
  getWorld(): org$bukkit$World;
  getChunk(): org$bukkit$Chunk;
  getBlock(): org$bukkit$block$Block;
  setX(arg0: number): void;
  getX(): number;
  getBlockX(): number;
  setY(arg0: number): void;
  getY(): number;
  getBlockY(): number;
  setZ(arg0: number): void;
  getZ(): number;
  getBlockZ(): number;
  setYaw(arg0: number): void;
  getYaw(): number;
  setPitch(arg0: number): void;
  getPitch(): number;
  getDirection(): org$bukkit$util$Vector;
  setDirection(arg0: org$bukkit$util$Vector): org$bukkit$Location;
  add(arg0: org$bukkit$Location): org$bukkit$Location;
  add(arg0: org$bukkit$util$Vector): org$bukkit$Location;
  add(arg0: number, arg1: number, arg2: number): org$bukkit$Location;
  subtract(arg0: org$bukkit$Location): org$bukkit$Location;
  subtract(arg0: org$bukkit$util$Vector): org$bukkit$Location;
  subtract(arg0: number, arg1: number, arg2: number): org$bukkit$Location;
  length(): number;
  lengthSquared(): number;
  distance(arg0: org$bukkit$Location): number;
  distanceSquared(arg0: org$bukkit$Location): number;
  multiply(arg0: number): org$bukkit$Location;
  zero(): org$bukkit$Location;
  isChunkLoaded(): boolean;
  isGenerated(): boolean;
  set(arg0: number, arg1: number, arg2: number): org$bukkit$Location;
  add(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$Location;
  subtract(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$Location;
  toBlockLocation(): org$bukkit$Location;
  toBlockKey(): number;
  toCenterLocation(): org$bukkit$Location;
  toHighestLocation(): org$bukkit$Location;
  toHighestLocation(
    arg0: com$destroystokyo$paper$HeightmapType
  ): org$bukkit$Location;
  createExplosion(arg0: number): boolean;
  createExplosion(arg0: number, arg1: boolean): boolean;
  createExplosion(arg0: number, arg1: boolean, arg2: boolean): boolean;
  createExplosion(arg0: org$bukkit$entity$Entity, arg1: number): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): boolean;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyLivingEntities(arg0: number): java$util$Collection;
  getNearbyLivingEntities(arg0: number, arg1: number): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(arg0: number): java$util$Collection;
  getNearbyPlayers(arg0: number, arg1: number): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  toVector(): org$bukkit$util$Vector;
  clone(): org$bukkit$Location;
  checkFinite(): void;
  serialize(): any /* java.util.Map */;
  clone(): any;
}

declare class org$bukkit$Location implements $org$bukkit$Location {
  constructor(arg0: org$bukkit$World, arg1: number, arg2: number, arg3: number);
  constructor(
    arg0: org$bukkit$World,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  );
  setWorld(arg0: org$bukkit$World): void;
  isWorldLoaded(): boolean;
  getWorld(): org$bukkit$World;
  getChunk(): org$bukkit$Chunk;
  getBlock(): org$bukkit$block$Block;
  setX(arg0: number): void;
  getX(): number;
  getBlockX(): number;
  setY(arg0: number): void;
  getY(): number;
  getBlockY(): number;
  setZ(arg0: number): void;
  getZ(): number;
  getBlockZ(): number;
  setYaw(arg0: number): void;
  getYaw(): number;
  setPitch(arg0: number): void;
  getPitch(): number;
  getDirection(): org$bukkit$util$Vector;
  setDirection(arg0: org$bukkit$util$Vector): org$bukkit$Location;
  add(arg0: org$bukkit$Location): org$bukkit$Location;
  add(arg0: org$bukkit$util$Vector): org$bukkit$Location;
  add(arg0: number, arg1: number, arg2: number): org$bukkit$Location;
  subtract(arg0: org$bukkit$Location): org$bukkit$Location;
  subtract(arg0: org$bukkit$util$Vector): org$bukkit$Location;
  subtract(arg0: number, arg1: number, arg2: number): org$bukkit$Location;
  length(): number;
  lengthSquared(): number;
  distance(arg0: org$bukkit$Location): number;
  distanceSquared(arg0: org$bukkit$Location): number;
  multiply(arg0: number): org$bukkit$Location;
  zero(): org$bukkit$Location;
  isChunkLoaded(): boolean;
  isGenerated(): boolean;
  set(arg0: number, arg1: number, arg2: number): org$bukkit$Location;
  add(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$Location;
  subtract(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$Location;
  toBlockLocation(): org$bukkit$Location;
  toBlockKey(): number;
  toCenterLocation(): org$bukkit$Location;
  toHighestLocation(): org$bukkit$Location;
  toHighestLocation(
    arg0: com$destroystokyo$paper$HeightmapType
  ): org$bukkit$Location;
  createExplosion(arg0: number): boolean;
  createExplosion(arg0: number, arg1: boolean): boolean;
  createExplosion(arg0: number, arg1: boolean, arg2: boolean): boolean;
  createExplosion(arg0: org$bukkit$entity$Entity, arg1: number): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): boolean;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyLivingEntities(arg0: number): java$util$Collection;
  getNearbyLivingEntities(arg0: number, arg1: number): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(arg0: number): java$util$Collection;
  getNearbyPlayers(arg0: number, arg1: number): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  toVector(): org$bukkit$util$Vector;
  clone(): org$bukkit$Location;
  checkFinite(): void;
  static locToBlock(arg0: number): number;
  serialize(): any /* java.util.Map */;
  static deserialize(arg0: any /* java.util.Map */): org$bukkit$Location;
  static normalizeYaw(arg0: number): number;
  static normalizePitch(arg0: number): number;
  clone(): any;
}


declare interface $org$bukkit$World
  extends $org$bukkit$plugin$messaging$PluginMessageRecipient,
    $org$bukkit$metadata$Metadatable {
  getEntityCount(): number;
  getTileEntityCount(): number;
  getTickableTileEntityCount(): number;
  getChunkCount(): number;
  getPlayerCount(): number;
  getBlockAt(arg0: number, arg1: number, arg2: number): org$bukkit$block$Block;
  getBlockAt(arg0: org$bukkit$Location): org$bukkit$block$Block;
  getBlockAtKey(arg0: number): org$bukkit$block$Block;
  getLocationAtKey(arg0: number): org$bukkit$Location;
  getHighestBlockYAt(arg0: number, arg1: number): number;
  getHighestBlockYAt(arg0: org$bukkit$Location): number;
  getHighestBlockAt(arg0: number, arg1: number): org$bukkit$block$Block;
  getHighestBlockAt(arg0: org$bukkit$Location): org$bukkit$block$Block;
  getHighestBlockYAt(
    arg0: number,
    arg1: number,
    arg2: com$destroystokyo$paper$HeightmapType
  ): number;
  getHighestBlockYAt(
    arg0: org$bukkit$Location,
    arg1: com$destroystokyo$paper$HeightmapType
  ): number;
  getHighestBlockAt(
    arg0: number,
    arg1: number,
    arg2: com$destroystokyo$paper$HeightmapType
  ): org$bukkit$block$Block;
  getHighestBlockAt(
    arg0: org$bukkit$Location,
    arg1: com$destroystokyo$paper$HeightmapType
  ): org$bukkit$block$Block;
  getHighestBlockYAt(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$HeightMap
  ): number;
  getHighestBlockYAt(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$HeightMap
  ): number;
  getHighestBlockAt(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$HeightMap
  ): org$bukkit$block$Block;
  getHighestBlockAt(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$HeightMap
  ): org$bukkit$block$Block;
  getChunkAt(arg0: number, arg1: number): org$bukkit$Chunk;
  getChunkAt(arg0: org$bukkit$Location): org$bukkit$Chunk;
  getChunkAt(arg0: org$bukkit$block$Block): org$bukkit$Chunk;
  getChunkAt(arg0: number): org$bukkit$Chunk;
  isChunkGenerated(arg0: number): boolean;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$World$ChunkLoadCallback
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$World$ChunkLoadCallback
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$World$ChunkLoadCallback
  ): void;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: boolean,
    arg3: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: boolean,
    arg2: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: boolean,
    arg2: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: number,
    arg1: number
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$block$Block
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$block$Block,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: number,
    arg1: number
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  isChunkLoaded(arg0: org$bukkit$Chunk): boolean;
  getLoadedChunks(): JavaArray<org$bukkit$Chunk>;
  loadChunk(arg0: org$bukkit$Chunk): void;
  isChunkLoaded(arg0: number, arg1: number): boolean;
  isChunkGenerated(arg0: number, arg1: number): boolean;
  isChunkInUse(arg0: number, arg1: number): boolean;
  loadChunk(arg0: number, arg1: number): void;
  loadChunk(arg0: number, arg1: number, arg2: boolean): boolean;
  unloadChunk(arg0: org$bukkit$Chunk): boolean;
  unloadChunk(arg0: number, arg1: number): boolean;
  unloadChunk(arg0: number, arg1: number, arg2: boolean): boolean;
  unloadChunkRequest(arg0: number, arg1: number): boolean;
  regenerateChunk(arg0: number, arg1: number): boolean;
  refreshChunk(arg0: number, arg1: number): boolean;
  isChunkForceLoaded(arg0: number, arg1: number): boolean;
  setChunkForceLoaded(arg0: number, arg1: number, arg2: boolean): void;
  getForceLoadedChunks(): java$util$Collection;
  addPluginChunkTicket(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$plugin$Plugin
  ): boolean;
  removePluginChunkTicket(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$plugin$Plugin
  ): boolean;
  removePluginChunkTickets(arg0: org$bukkit$plugin$Plugin): void;
  getPluginChunkTickets(arg0: number, arg1: number): java$util$Collection;
  getPluginChunkTickets(): any /* java.util.Map */;
  dropItem(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$entity$Item;
  dropItemNaturally(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$entity$Item;
  spawnArrow(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number
  ): org$bukkit$entity$Arrow;
  spawnArrow(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number,
    arg4: any /* java.lang.Class */
  ): org$bukkit$entity$AbstractArrow;
  generateTree(arg0: org$bukkit$Location, arg1: org$bukkit$TreeType): boolean;
  generateTree(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$TreeType,
    arg2: org$bukkit$BlockChangeDelegate
  ): boolean;
  spawnEntity(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType
  ): org$bukkit$entity$Entity;
  strikeLightning(arg0: org$bukkit$Location): org$bukkit$entity$LightningStrike;
  strikeLightningEffect(
    arg0: org$bukkit$Location
  ): org$bukkit$entity$LightningStrike;
  getEntities(): any /* java.util.List */;
  getLivingEntities(): any /* java.util.List */;
  getEntitiesByClass(
    arg0: JavaArray<any /* java.lang.Class */>
  ): java$util$Collection;
  getEntitiesByClass(arg0: any /* java.lang.Class */): java$util$Collection;
  getEntitiesByClasses(
    arg0: JavaArray<any /* java.lang.Class */>
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getPlayers(): any /* java.util.List */;
  getNearbyEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getEntity(arg0: any /* java.util.UUID */): org$bukkit$entity$Entity;
  getNearbyEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntities(arg0: org$bukkit$util$BoundingBox): java$util$Collection;
  getNearbyEntities(
    arg0: org$bukkit$util$BoundingBox,
    arg1: any /* java.util.function.Predicate */
  ): java$util$Collection;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number
  ): org$bukkit$util$RayTraceResult;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number
  ): org$bukkit$util$RayTraceResult;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): org$bukkit$util$RayTraceResult;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number
  ): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode,
    arg4: boolean
  ): org$bukkit$util$RayTraceResult;
  rayTrace(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode,
    arg4: boolean,
    arg5: number,
    arg6: any /* java.util.function.Predicate */
  ): org$bukkit$util$RayTraceResult;
  getName(): string;
  getUID(): any /* java.util.UUID */;
  getSpawnLocation(): org$bukkit$Location;
  setSpawnLocation(arg0: org$bukkit$Location): boolean;
  setSpawnLocation(arg0: number, arg1: number, arg2: number): boolean;
  getTime(): number;
  setTime(arg0: number): void;
  getFullTime(): number;
  setFullTime(arg0: number): void;
  isDayTime(): boolean;
  hasStorm(): boolean;
  setStorm(arg0: boolean): void;
  getWeatherDuration(): number;
  setWeatherDuration(arg0: number): void;
  isThundering(): boolean;
  setThundering(arg0: boolean): void;
  getThunderDuration(): number;
  setThunderDuration(arg0: number): void;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number
  ): boolean;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean
  ): boolean;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean,
    arg5: boolean
  ): boolean;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean,
    arg5: boolean,
    arg6: org$bukkit$entity$Entity
  ): boolean;
  createExplosion(arg0: org$bukkit$Location, arg1: number): boolean;
  createExplosion(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: boolean,
    arg4: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: number
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean
  ): boolean;
  createExplosion(arg0: org$bukkit$entity$Entity, arg1: number): boolean;
  createExplosion(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$entity$Entity
  ): boolean;
  getEnvironment(): org$bukkit$World$Environment;
  getSeed(): number;
  getPVP(): boolean;
  setPVP(arg0: boolean): void;
  getGenerator(): org$bukkit$generator$ChunkGenerator;
  save(): void;
  getPopulators(): any /* java.util.List */;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$util$Consumer
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason,
    arg3: org$bukkit$util$Consumer
  ): org$bukkit$entity$Entity;
  spawnEntity(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  ): org$bukkit$entity$Entity;
  spawnEntity(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason,
    arg3: org$bukkit$util$Consumer
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$util$Consumer,
    arg3: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  ): org$bukkit$entity$Entity;
  spawnFallingBlock(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$entity$FallingBlock;
  spawnFallingBlock(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$block$data$BlockData
  ): org$bukkit$entity$FallingBlock;
  spawnFallingBlock(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Material,
    arg2: Buffer
  ): org$bukkit$entity$FallingBlock;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: number
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: number,
    arg3: number
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: any
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: any,
    arg3: number
  ): void;
  getEmptyChunkSnapshot(
    arg0: number,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): org$bukkit$ChunkSnapshot;
  setSpawnFlags(arg0: boolean, arg1: boolean): void;
  getAllowAnimals(): boolean;
  getAllowMonsters(): boolean;
  getBiome(arg0: number, arg1: number): org$bukkit$block$Biome;
  getBiome(arg0: number, arg1: number, arg2: number): org$bukkit$block$Biome;
  setBiome(arg0: number, arg1: number, arg2: org$bukkit$block$Biome): void;
  setBiome(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$Biome
  ): void;
  getTemperature(arg0: number, arg1: number): number;
  getTemperature(arg0: number, arg1: number, arg2: number): number;
  getHumidity(arg0: number, arg1: number): number;
  getHumidity(arg0: number, arg1: number, arg2: number): number;
  getMaxHeight(): number;
  getSeaLevel(): number;
  getKeepSpawnInMemory(): boolean;
  setKeepSpawnInMemory(arg0: boolean): void;
  isAutoSave(): boolean;
  setAutoSave(arg0: boolean): void;
  setDifficulty(arg0: org$bukkit$Difficulty): void;
  getDifficulty(): org$bukkit$Difficulty;
  getWorldFolder(): any /* java.io.File */;
  getWorldType(): org$bukkit$WorldType;
  canGenerateStructures(): boolean;
  isHardcore(): boolean;
  setHardcore(arg0: boolean): void;
  getTicksPerAnimalSpawns(): number;
  setTicksPerAnimalSpawns(arg0: number): void;
  getTicksPerMonsterSpawns(): number;
  setTicksPerMonsterSpawns(arg0: number): void;
  getTicksPerWaterSpawns(): number;
  setTicksPerWaterSpawns(arg0: number): void;
  getTicksPerAmbientSpawns(): number;
  setTicksPerAmbientSpawns(arg0: number): void;
  getMonsterSpawnLimit(): number;
  setMonsterSpawnLimit(arg0: number): void;
  getAnimalSpawnLimit(): number;
  setAnimalSpawnLimit(arg0: number): void;
  getWaterAnimalSpawnLimit(): number;
  setWaterAnimalSpawnLimit(arg0: number): void;
  getAmbientSpawnLimit(): number;
  setAmbientSpawnLimit(arg0: number): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  getGameRules(): JavaArray<string>;
  getGameRuleValue(arg0: string): string;
  setGameRuleValue(arg0: string, arg1: string): boolean;
  isGameRule(arg0: string): boolean;
  getGameRuleValue(arg0: org$bukkit$GameRule): any;
  getGameRuleDefault(arg0: org$bukkit$GameRule): any;
  setGameRule(arg0: org$bukkit$GameRule, arg1: any): boolean;
  getWorldBorder(): org$bukkit$WorldBorder;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$entity$Player,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: number,
    arg10: number,
    arg11: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$entity$Player,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: number,
    arg10: number,
    arg11: any,
    arg12: boolean
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: any,
    arg8: boolean
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: any,
    arg10: boolean
  ): void;
  locateNearestStructure(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$StructureType,
    arg2: number,
    arg3: boolean
  ): org$bukkit$Location;
  getViewDistance(): number;
  setViewDistance(arg0: number): void;
  getNoTickViewDistance(): number;
  setNoTickViewDistance(arg0: number): void;
  spigot(): org$bukkit$World$Spigot;
  locateNearestRaid(arg0: org$bukkit$Location, arg1: number): org$bukkit$Raid;
  getRaids(): any /* java.util.List */;
  getEnderDragonBattle(): org$bukkit$boss$DragonBattle;
}

declare class org$bukkit$World implements $org$bukkit$World {
  getEntityCount(): number;
  getTileEntityCount(): number;
  getTickableTileEntityCount(): number;
  getChunkCount(): number;
  getPlayerCount(): number;
  getBlockAt(arg0: number, arg1: number, arg2: number): org$bukkit$block$Block;
  getBlockAt(arg0: org$bukkit$Location): org$bukkit$block$Block;
  getBlockAtKey(arg0: number): org$bukkit$block$Block;
  getLocationAtKey(arg0: number): org$bukkit$Location;
  getHighestBlockYAt(arg0: number, arg1: number): number;
  getHighestBlockYAt(arg0: org$bukkit$Location): number;
  getHighestBlockAt(arg0: number, arg1: number): org$bukkit$block$Block;
  getHighestBlockAt(arg0: org$bukkit$Location): org$bukkit$block$Block;
  getHighestBlockYAt(
    arg0: number,
    arg1: number,
    arg2: com$destroystokyo$paper$HeightmapType
  ): number;
  getHighestBlockYAt(
    arg0: org$bukkit$Location,
    arg1: com$destroystokyo$paper$HeightmapType
  ): number;
  getHighestBlockAt(
    arg0: number,
    arg1: number,
    arg2: com$destroystokyo$paper$HeightmapType
  ): org$bukkit$block$Block;
  getHighestBlockAt(
    arg0: org$bukkit$Location,
    arg1: com$destroystokyo$paper$HeightmapType
  ): org$bukkit$block$Block;
  getHighestBlockYAt(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$HeightMap
  ): number;
  getHighestBlockYAt(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$HeightMap
  ): number;
  getHighestBlockAt(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$HeightMap
  ): org$bukkit$block$Block;
  getHighestBlockAt(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$HeightMap
  ): org$bukkit$block$Block;
  getChunkAt(arg0: number, arg1: number): org$bukkit$Chunk;
  getChunkAt(arg0: org$bukkit$Location): org$bukkit$Chunk;
  getChunkAt(arg0: org$bukkit$block$Block): org$bukkit$Chunk;
  getChunkAt(arg0: number): org$bukkit$Chunk;
  isChunkGenerated(arg0: number): boolean;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$World$ChunkLoadCallback
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$World$ChunkLoadCallback
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$World$ChunkLoadCallback
  ): void;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: boolean,
    arg3: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: boolean,
    arg2: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: boolean,
    arg2: any /* java.util.function.Consumer */
  ): void;
  getChunkAtAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: org$bukkit$block$Block,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: number,
    arg1: number
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$block$Block
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: org$bukkit$block$Block,
    arg1: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsyncUrgently(
    arg0: number,
    arg1: number
  ): any /* java.util.concurrent.CompletableFuture */;
  getChunkAtAsync(
    arg0: number,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): any /* java.util.concurrent.CompletableFuture */;
  isChunkLoaded(arg0: org$bukkit$Chunk): boolean;
  getLoadedChunks(): JavaArray<org$bukkit$Chunk>;
  loadChunk(arg0: org$bukkit$Chunk): void;
  isChunkLoaded(arg0: number, arg1: number): boolean;
  isChunkGenerated(arg0: number, arg1: number): boolean;
  isChunkInUse(arg0: number, arg1: number): boolean;
  loadChunk(arg0: number, arg1: number): void;
  loadChunk(arg0: number, arg1: number, arg2: boolean): boolean;
  unloadChunk(arg0: org$bukkit$Chunk): boolean;
  unloadChunk(arg0: number, arg1: number): boolean;
  unloadChunk(arg0: number, arg1: number, arg2: boolean): boolean;
  unloadChunkRequest(arg0: number, arg1: number): boolean;
  regenerateChunk(arg0: number, arg1: number): boolean;
  refreshChunk(arg0: number, arg1: number): boolean;
  isChunkForceLoaded(arg0: number, arg1: number): boolean;
  setChunkForceLoaded(arg0: number, arg1: number, arg2: boolean): void;
  getForceLoadedChunks(): java$util$Collection;
  addPluginChunkTicket(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$plugin$Plugin
  ): boolean;
  removePluginChunkTicket(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$plugin$Plugin
  ): boolean;
  removePluginChunkTickets(arg0: org$bukkit$plugin$Plugin): void;
  getPluginChunkTickets(arg0: number, arg1: number): java$util$Collection;
  getPluginChunkTickets(): any /* java.util.Map */;
  dropItem(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$entity$Item;
  dropItemNaturally(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$entity$Item;
  spawnArrow(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number
  ): org$bukkit$entity$Arrow;
  spawnArrow(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number,
    arg4: any /* java.lang.Class */
  ): org$bukkit$entity$AbstractArrow;
  generateTree(arg0: org$bukkit$Location, arg1: org$bukkit$TreeType): boolean;
  generateTree(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$TreeType,
    arg2: org$bukkit$BlockChangeDelegate
  ): boolean;
  spawnEntity(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType
  ): org$bukkit$entity$Entity;
  strikeLightning(arg0: org$bukkit$Location): org$bukkit$entity$LightningStrike;
  strikeLightningEffect(
    arg0: org$bukkit$Location
  ): org$bukkit$entity$LightningStrike;
  getEntities(): any /* java.util.List */;
  getLivingEntities(): any /* java.util.List */;
  getEntitiesByClass(
    arg0: JavaArray<any /* java.lang.Class */>
  ): java$util$Collection;
  getEntitiesByClass(arg0: any /* java.lang.Class */): java$util$Collection;
  getEntitiesByClasses(
    arg0: JavaArray<any /* java.lang.Class */>
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyLivingEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyPlayers(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntitiesByType(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getPlayers(): any /* java.util.List */;
  getNearbyEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): java$util$Collection;
  getEntity(arg0: any /* java.util.UUID */): org$bukkit$entity$Entity;
  getNearbyEntities(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): java$util$Collection;
  getNearbyEntities(arg0: org$bukkit$util$BoundingBox): java$util$Collection;
  getNearbyEntities(
    arg0: org$bukkit$util$BoundingBox,
    arg1: any /* java.util.function.Predicate */
  ): java$util$Collection;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number
  ): org$bukkit$util$RayTraceResult;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number
  ): org$bukkit$util$RayTraceResult;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: any /* java.util.function.Predicate */
  ): org$bukkit$util$RayTraceResult;
  rayTraceEntities(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: number,
    arg4: any /* java.util.function.Predicate */
  ): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number
  ): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode,
    arg4: boolean
  ): org$bukkit$util$RayTraceResult;
  rayTrace(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode,
    arg4: boolean,
    arg5: number,
    arg6: any /* java.util.function.Predicate */
  ): org$bukkit$util$RayTraceResult;
  getName(): string;
  getUID(): any /* java.util.UUID */;
  getSpawnLocation(): org$bukkit$Location;
  setSpawnLocation(arg0: org$bukkit$Location): boolean;
  setSpawnLocation(arg0: number, arg1: number, arg2: number): boolean;
  getTime(): number;
  setTime(arg0: number): void;
  getFullTime(): number;
  setFullTime(arg0: number): void;
  isDayTime(): boolean;
  hasStorm(): boolean;
  setStorm(arg0: boolean): void;
  getWeatherDuration(): number;
  setWeatherDuration(arg0: number): void;
  isThundering(): boolean;
  setThundering(arg0: boolean): void;
  getThunderDuration(): number;
  setThunderDuration(arg0: number): void;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number
  ): boolean;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean
  ): boolean;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean,
    arg5: boolean
  ): boolean;
  createExplosion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean,
    arg5: boolean,
    arg6: org$bukkit$entity$Entity
  ): boolean;
  createExplosion(arg0: org$bukkit$Location, arg1: number): boolean;
  createExplosion(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: boolean,
    arg4: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: number
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: boolean
  ): boolean;
  createExplosion(arg0: org$bukkit$entity$Entity, arg1: number): boolean;
  createExplosion(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): boolean;
  createExplosion(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$entity$Entity
  ): boolean;
  getEnvironment(): org$bukkit$World$Environment;
  getSeed(): number;
  getPVP(): boolean;
  setPVP(arg0: boolean): void;
  getGenerator(): org$bukkit$generator$ChunkGenerator;
  save(): void;
  getPopulators(): any /* java.util.List */;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$util$Consumer
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason,
    arg3: org$bukkit$util$Consumer
  ): org$bukkit$entity$Entity;
  spawnEntity(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  ): org$bukkit$entity$Entity;
  spawnEntity(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason,
    arg3: org$bukkit$util$Consumer
  ): org$bukkit$entity$Entity;
  spawn(
    arg0: org$bukkit$Location,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$util$Consumer,
    arg3: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  ): org$bukkit$entity$Entity;
  spawnFallingBlock(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$entity$FallingBlock;
  spawnFallingBlock(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$block$data$BlockData
  ): org$bukkit$entity$FallingBlock;
  spawnFallingBlock(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Material,
    arg2: Buffer
  ): org$bukkit$entity$FallingBlock;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: number
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: number,
    arg3: number
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: any
  ): void;
  playEffect(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Effect,
    arg2: any,
    arg3: number
  ): void;
  getEmptyChunkSnapshot(
    arg0: number,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  ): org$bukkit$ChunkSnapshot;
  setSpawnFlags(arg0: boolean, arg1: boolean): void;
  getAllowAnimals(): boolean;
  getAllowMonsters(): boolean;
  getBiome(arg0: number, arg1: number): org$bukkit$block$Biome;
  getBiome(arg0: number, arg1: number, arg2: number): org$bukkit$block$Biome;
  setBiome(arg0: number, arg1: number, arg2: org$bukkit$block$Biome): void;
  setBiome(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$Biome
  ): void;
  getTemperature(arg0: number, arg1: number): number;
  getTemperature(arg0: number, arg1: number, arg2: number): number;
  getHumidity(arg0: number, arg1: number): number;
  getHumidity(arg0: number, arg1: number, arg2: number): number;
  getMaxHeight(): number;
  getSeaLevel(): number;
  getKeepSpawnInMemory(): boolean;
  setKeepSpawnInMemory(arg0: boolean): void;
  isAutoSave(): boolean;
  setAutoSave(arg0: boolean): void;
  setDifficulty(arg0: org$bukkit$Difficulty): void;
  getDifficulty(): org$bukkit$Difficulty;
  getWorldFolder(): any /* java.io.File */;
  getWorldType(): org$bukkit$WorldType;
  canGenerateStructures(): boolean;
  isHardcore(): boolean;
  setHardcore(arg0: boolean): void;
  getTicksPerAnimalSpawns(): number;
  setTicksPerAnimalSpawns(arg0: number): void;
  getTicksPerMonsterSpawns(): number;
  setTicksPerMonsterSpawns(arg0: number): void;
  getTicksPerWaterSpawns(): number;
  setTicksPerWaterSpawns(arg0: number): void;
  getTicksPerAmbientSpawns(): number;
  setTicksPerAmbientSpawns(arg0: number): void;
  getMonsterSpawnLimit(): number;
  setMonsterSpawnLimit(arg0: number): void;
  getAnimalSpawnLimit(): number;
  setAnimalSpawnLimit(arg0: number): void;
  getWaterAnimalSpawnLimit(): number;
  setWaterAnimalSpawnLimit(arg0: number): void;
  getAmbientSpawnLimit(): number;
  setAmbientSpawnLimit(arg0: number): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: number,
    arg3: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Sound,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  playSound(
    arg0: org$bukkit$Location,
    arg1: string,
    arg2: org$bukkit$SoundCategory,
    arg3: number,
    arg4: number
  ): void;
  getGameRules(): JavaArray<string>;
  getGameRuleValue(arg0: string): string;
  setGameRuleValue(arg0: string, arg1: string): boolean;
  isGameRule(arg0: string): boolean;
  getGameRuleValue(arg0: org$bukkit$GameRule): any;
  getGameRuleDefault(arg0: org$bukkit$GameRule): any;
  setGameRule(arg0: org$bukkit$GameRule, arg1: any): boolean;
  getWorldBorder(): org$bukkit$WorldBorder;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$entity$Player,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: number,
    arg10: number,
    arg11: any
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$entity$Player,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: number,
    arg10: number,
    arg11: any,
    arg12: boolean
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: org$bukkit$Location,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: any,
    arg8: boolean
  ): void;
  spawnParticle(
    arg0: org$bukkit$Particle,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: number,
    arg7: number,
    arg8: number,
    arg9: any,
    arg10: boolean
  ): void;
  locateNearestStructure(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$StructureType,
    arg2: number,
    arg3: boolean
  ): org$bukkit$Location;
  getViewDistance(): number;
  setViewDistance(arg0: number): void;
  getNoTickViewDistance(): number;
  setNoTickViewDistance(arg0: number): void;
  spigot(): org$bukkit$World$Spigot;
  locateNearestRaid(arg0: org$bukkit$Location, arg1: number): org$bukkit$Raid;
  getRaids(): any /* java.util.List */;
  getEnderDragonBattle(): org$bukkit$boss$DragonBattle;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  sendPluginMessage(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
  getListeningPluginChannels(): any /* java.util.Set */;
}


declare interface $org$bukkit$metadata$Metadatable {
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}

declare class org$bukkit$metadata$Metadatable
  implements $org$bukkit$metadata$Metadatable {
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$metadata$MetadataValue {
  value(): any;
  asInt(): number;
  asFloat(): number;
  asDouble(): number;
  asLong(): number;
  asShort(): unknown;
  asByte(): Buffer;
  asBoolean(): boolean;
  asString(): string;
  getOwningPlugin(): org$bukkit$plugin$Plugin;
  invalidate(): void;
}

declare class org$bukkit$metadata$MetadataValue
  implements $org$bukkit$metadata$MetadataValue {
  value(): any;
  asInt(): number;
  asFloat(): number;
  asDouble(): number;
  asLong(): number;
  asShort(): unknown;
  asByte(): Buffer;
  asBoolean(): boolean;
  asString(): string;
  getOwningPlugin(): org$bukkit$plugin$Plugin;
  invalidate(): void;
}


declare interface $org$bukkit$block$Block
  extends $org$bukkit$metadata$Metadatable {
  getData(): Buffer;
  getBlockData(): org$bukkit$block$data$BlockData;
  getRelative(arg0: number, arg1: number, arg2: number): org$bukkit$block$Block;
  getRelative(arg0: org$bukkit$block$BlockFace): org$bukkit$block$Block;
  getRelative(
    arg0: org$bukkit$block$BlockFace,
    arg1: number
  ): org$bukkit$block$Block;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getLightFromSky(): Buffer;
  getLightFromBlocks(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getBlockKey(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData, arg1: boolean): void;
  setType(arg0: org$bukkit$Material): void;
  setType(arg0: org$bukkit$Material, arg1: boolean): void;
  getFace(arg0: org$bukkit$block$Block): org$bukkit$block$BlockFace;
  getState(): org$bukkit$block$BlockState;
  getState(arg0: boolean): org$bukkit$block$BlockState;
  getBiome(): org$bukkit$block$Biome;
  setBiome(arg0: org$bukkit$block$Biome): void;
  isBlockPowered(): boolean;
  isBlockIndirectlyPowered(): boolean;
  isBlockFacePowered(arg0: org$bukkit$block$BlockFace): boolean;
  isBlockFaceIndirectlyPowered(arg0: org$bukkit$block$BlockFace): boolean;
  getBlockPower(arg0: org$bukkit$block$BlockFace): number;
  getBlockPower(): number;
  isEmpty(): boolean;
  isLiquid(): boolean;
  getTemperature(): number;
  getHumidity(): number;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  breakNaturally(): boolean;
  breakNaturally(arg0: org$bukkit$inventory$ItemStack): boolean;
  breakNaturally(arg0: org$bukkit$inventory$ItemStack, arg1: boolean): boolean;
  getDrops(): java$util$Collection;
  getDrops(arg0: org$bukkit$inventory$ItemStack): java$util$Collection;
  getDrops(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: org$bukkit$entity$Entity
  ): java$util$Collection;
  isPassable(): boolean;
  rayTrace(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  getSoundGroup(): com$destroystokyo$paper$block$BlockSoundGroup;
}

declare class org$bukkit$block$Block implements $org$bukkit$block$Block {
  getData(): Buffer;
  getBlockData(): org$bukkit$block$data$BlockData;
  getRelative(arg0: number, arg1: number, arg2: number): org$bukkit$block$Block;
  getRelative(arg0: org$bukkit$block$BlockFace): org$bukkit$block$Block;
  getRelative(
    arg0: org$bukkit$block$BlockFace,
    arg1: number
  ): org$bukkit$block$Block;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getLightFromSky(): Buffer;
  getLightFromBlocks(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getBlockKey(): number;
  static getBlockKey(arg0: number, arg1: number, arg2: number): number;
  static getBlockKeyX(arg0: number): number;
  static getBlockKeyY(arg0: number): number;
  static getBlockKeyZ(arg0: number): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData, arg1: boolean): void;
  setType(arg0: org$bukkit$Material): void;
  setType(arg0: org$bukkit$Material, arg1: boolean): void;
  getFace(arg0: org$bukkit$block$Block): org$bukkit$block$BlockFace;
  getState(): org$bukkit$block$BlockState;
  getState(arg0: boolean): org$bukkit$block$BlockState;
  getBiome(): org$bukkit$block$Biome;
  setBiome(arg0: org$bukkit$block$Biome): void;
  isBlockPowered(): boolean;
  isBlockIndirectlyPowered(): boolean;
  isBlockFacePowered(arg0: org$bukkit$block$BlockFace): boolean;
  isBlockFaceIndirectlyPowered(arg0: org$bukkit$block$BlockFace): boolean;
  getBlockPower(arg0: org$bukkit$block$BlockFace): number;
  getBlockPower(): number;
  isEmpty(): boolean;
  isLiquid(): boolean;
  getTemperature(): number;
  getHumidity(): number;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  breakNaturally(): boolean;
  breakNaturally(arg0: org$bukkit$inventory$ItemStack): boolean;
  breakNaturally(arg0: org$bukkit$inventory$ItemStack, arg1: boolean): boolean;
  getDrops(): java$util$Collection;
  getDrops(arg0: org$bukkit$inventory$ItemStack): java$util$Collection;
  getDrops(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: org$bukkit$entity$Entity
  ): java$util$Collection;
  isPassable(): boolean;
  rayTrace(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$util$Vector,
    arg2: number,
    arg3: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  getSoundGroup(): com$destroystokyo$paper$block$BlockSoundGroup;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$data$BlockData {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}

declare class org$bukkit$block$data$BlockData
  implements $org$bukkit$block$data$BlockData {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$Material extends $org$bukkit$Keyed {
  data: any /* java.lang.Class */;
  isEmpty(): boolean;
  getId(): number;
  isLegacy(): boolean;
  getKey(): org$bukkit$NamespacedKey;
  getMaxStackSize(): number;
  getMaxDurability(): unknown;
  createBlockData(): org$bukkit$block$data$BlockData;
  createBlockData(
    arg0: any /* java.util.function.Consumer */
  ): org$bukkit$block$data$BlockData;
  createBlockData(arg0: string): org$bukkit$block$data$BlockData;
  getData(): any /* java.lang.Class */;
  getNewData(arg0: Buffer): org$bukkit$material$MaterialData;
  isBlock(): boolean;
  isEdible(): boolean;
  isRecord(): boolean;
  isSolid(): boolean;
  isAir(): boolean;
  isTransparent(): boolean;
  isFlammable(): boolean;
  isBurnable(): boolean;
  isFuel(): boolean;
  isOccluding(): boolean;
  hasGravity(): boolean;
  isItem(): boolean;
  isInteractable(): boolean;
  getHardness(): number;
  getBlastResistance(): number;
  getCraftingRemainingItem(): org$bukkit$Material;
}

declare class org$bukkit$Material implements $org$bukkit$Material {
  static ACACIA_BOAT: org$bukkit$Material;
  static ACACIA_BUTTON: org$bukkit$Material;
  static ACACIA_DOOR: org$bukkit$Material;
  static ACACIA_FENCE: org$bukkit$Material;
  static ACACIA_FENCE_GATE: org$bukkit$Material;
  static ACACIA_LEAVES: org$bukkit$Material;
  static ACACIA_LOG: org$bukkit$Material;
  static ACACIA_PLANKS: org$bukkit$Material;
  static ACACIA_PRESSURE_PLATE: org$bukkit$Material;
  static ACACIA_SAPLING: org$bukkit$Material;
  static ACACIA_SIGN: org$bukkit$Material;
  static ACACIA_SLAB: org$bukkit$Material;
  static ACACIA_STAIRS: org$bukkit$Material;
  static ACACIA_TRAPDOOR: org$bukkit$Material;
  static ACACIA_WALL_SIGN: org$bukkit$Material;
  static ACACIA_WOOD: org$bukkit$Material;
  static ACTIVATOR_RAIL: org$bukkit$Material;
  static AIR: org$bukkit$Material;
  static ALLIUM: org$bukkit$Material;
  static ANDESITE: org$bukkit$Material;
  static ANDESITE_SLAB: org$bukkit$Material;
  static ANDESITE_STAIRS: org$bukkit$Material;
  static ANDESITE_WALL: org$bukkit$Material;
  static ANVIL: org$bukkit$Material;
  static APPLE: org$bukkit$Material;
  static ARMOR_STAND: org$bukkit$Material;
  static ARROW: org$bukkit$Material;
  static ATTACHED_MELON_STEM: org$bukkit$Material;
  static ATTACHED_PUMPKIN_STEM: org$bukkit$Material;
  static AZURE_BLUET: org$bukkit$Material;
  static BAKED_POTATO: org$bukkit$Material;
  static BAMBOO: org$bukkit$Material;
  static BAMBOO_SAPLING: org$bukkit$Material;
  static BARREL: org$bukkit$Material;
  static BARRIER: org$bukkit$Material;
  static BAT_SPAWN_EGG: org$bukkit$Material;
  static BEACON: org$bukkit$Material;
  static BEDROCK: org$bukkit$Material;
  static BEEF: org$bukkit$Material;
  static BEEHIVE: org$bukkit$Material;
  static BEETROOT: org$bukkit$Material;
  static BEETROOTS: org$bukkit$Material;
  static BEETROOT_SEEDS: org$bukkit$Material;
  static BEETROOT_SOUP: org$bukkit$Material;
  static BEE_NEST: org$bukkit$Material;
  static BEE_SPAWN_EGG: org$bukkit$Material;
  static BELL: org$bukkit$Material;
  static BIRCH_BOAT: org$bukkit$Material;
  static BIRCH_BUTTON: org$bukkit$Material;
  static BIRCH_DOOR: org$bukkit$Material;
  static BIRCH_FENCE: org$bukkit$Material;
  static BIRCH_FENCE_GATE: org$bukkit$Material;
  static BIRCH_LEAVES: org$bukkit$Material;
  static BIRCH_LOG: org$bukkit$Material;
  static BIRCH_PLANKS: org$bukkit$Material;
  static BIRCH_PRESSURE_PLATE: org$bukkit$Material;
  static BIRCH_SAPLING: org$bukkit$Material;
  static BIRCH_SIGN: org$bukkit$Material;
  static BIRCH_SLAB: org$bukkit$Material;
  static BIRCH_STAIRS: org$bukkit$Material;
  static BIRCH_TRAPDOOR: org$bukkit$Material;
  static BIRCH_WALL_SIGN: org$bukkit$Material;
  static BIRCH_WOOD: org$bukkit$Material;
  static BLACK_BANNER: org$bukkit$Material;
  static BLACK_BED: org$bukkit$Material;
  static BLACK_CARPET: org$bukkit$Material;
  static BLACK_CONCRETE: org$bukkit$Material;
  static BLACK_CONCRETE_POWDER: org$bukkit$Material;
  static BLACK_DYE: org$bukkit$Material;
  static BLACK_GLAZED_TERRACOTTA: org$bukkit$Material;
  static BLACK_SHULKER_BOX: org$bukkit$Material;
  static BLACK_STAINED_GLASS: org$bukkit$Material;
  static BLACK_STAINED_GLASS_PANE: org$bukkit$Material;
  static BLACK_TERRACOTTA: org$bukkit$Material;
  static BLACK_WALL_BANNER: org$bukkit$Material;
  static BLACK_WOOL: org$bukkit$Material;
  static BLAST_FURNACE: org$bukkit$Material;
  static BLAZE_POWDER: org$bukkit$Material;
  static BLAZE_ROD: org$bukkit$Material;
  static BLAZE_SPAWN_EGG: org$bukkit$Material;
  static BLUE_BANNER: org$bukkit$Material;
  static BLUE_BED: org$bukkit$Material;
  static BLUE_CARPET: org$bukkit$Material;
  static BLUE_CONCRETE: org$bukkit$Material;
  static BLUE_CONCRETE_POWDER: org$bukkit$Material;
  static BLUE_DYE: org$bukkit$Material;
  static BLUE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static BLUE_ICE: org$bukkit$Material;
  static BLUE_ORCHID: org$bukkit$Material;
  static BLUE_SHULKER_BOX: org$bukkit$Material;
  static BLUE_STAINED_GLASS: org$bukkit$Material;
  static BLUE_STAINED_GLASS_PANE: org$bukkit$Material;
  static BLUE_TERRACOTTA: org$bukkit$Material;
  static BLUE_WALL_BANNER: org$bukkit$Material;
  static BLUE_WOOL: org$bukkit$Material;
  static BONE: org$bukkit$Material;
  static BONE_BLOCK: org$bukkit$Material;
  static BONE_MEAL: org$bukkit$Material;
  static BOOK: org$bukkit$Material;
  static BOOKSHELF: org$bukkit$Material;
  static BOW: org$bukkit$Material;
  static BOWL: org$bukkit$Material;
  static BRAIN_CORAL: org$bukkit$Material;
  static BRAIN_CORAL_BLOCK: org$bukkit$Material;
  static BRAIN_CORAL_FAN: org$bukkit$Material;
  static BRAIN_CORAL_WALL_FAN: org$bukkit$Material;
  static BREAD: org$bukkit$Material;
  static BREWING_STAND: org$bukkit$Material;
  static BRICK: org$bukkit$Material;
  static BRICKS: org$bukkit$Material;
  static BRICK_SLAB: org$bukkit$Material;
  static BRICK_STAIRS: org$bukkit$Material;
  static BRICK_WALL: org$bukkit$Material;
  static BROWN_BANNER: org$bukkit$Material;
  static BROWN_BED: org$bukkit$Material;
  static BROWN_CARPET: org$bukkit$Material;
  static BROWN_CONCRETE: org$bukkit$Material;
  static BROWN_CONCRETE_POWDER: org$bukkit$Material;
  static BROWN_DYE: org$bukkit$Material;
  static BROWN_GLAZED_TERRACOTTA: org$bukkit$Material;
  static BROWN_MUSHROOM: org$bukkit$Material;
  static BROWN_MUSHROOM_BLOCK: org$bukkit$Material;
  static BROWN_SHULKER_BOX: org$bukkit$Material;
  static BROWN_STAINED_GLASS: org$bukkit$Material;
  static BROWN_STAINED_GLASS_PANE: org$bukkit$Material;
  static BROWN_TERRACOTTA: org$bukkit$Material;
  static BROWN_WALL_BANNER: org$bukkit$Material;
  static BROWN_WOOL: org$bukkit$Material;
  static BUBBLE_COLUMN: org$bukkit$Material;
  static BUBBLE_CORAL: org$bukkit$Material;
  static BUBBLE_CORAL_BLOCK: org$bukkit$Material;
  static BUBBLE_CORAL_FAN: org$bukkit$Material;
  static BUBBLE_CORAL_WALL_FAN: org$bukkit$Material;
  static BUCKET: org$bukkit$Material;
  static CACTUS: org$bukkit$Material;
  static CAKE: org$bukkit$Material;
  static CAMPFIRE: org$bukkit$Material;
  static CARROT: org$bukkit$Material;
  static CARROTS: org$bukkit$Material;
  static CARROT_ON_A_STICK: org$bukkit$Material;
  static CARTOGRAPHY_TABLE: org$bukkit$Material;
  static CARVED_PUMPKIN: org$bukkit$Material;
  static CAT_SPAWN_EGG: org$bukkit$Material;
  static CAULDRON: org$bukkit$Material;
  static CAVE_AIR: org$bukkit$Material;
  static CAVE_SPIDER_SPAWN_EGG: org$bukkit$Material;
  static CHAINMAIL_BOOTS: org$bukkit$Material;
  static CHAINMAIL_CHESTPLATE: org$bukkit$Material;
  static CHAINMAIL_HELMET: org$bukkit$Material;
  static CHAINMAIL_LEGGINGS: org$bukkit$Material;
  static CHAIN_COMMAND_BLOCK: org$bukkit$Material;
  static CHARCOAL: org$bukkit$Material;
  static CHEST: org$bukkit$Material;
  static CHEST_MINECART: org$bukkit$Material;
  static CHICKEN: org$bukkit$Material;
  static CHICKEN_SPAWN_EGG: org$bukkit$Material;
  static CHIPPED_ANVIL: org$bukkit$Material;
  static CHISELED_QUARTZ_BLOCK: org$bukkit$Material;
  static CHISELED_RED_SANDSTONE: org$bukkit$Material;
  static CHISELED_SANDSTONE: org$bukkit$Material;
  static CHISELED_STONE_BRICKS: org$bukkit$Material;
  static CHORUS_FLOWER: org$bukkit$Material;
  static CHORUS_FRUIT: org$bukkit$Material;
  static CHORUS_PLANT: org$bukkit$Material;
  static CLAY: org$bukkit$Material;
  static CLAY_BALL: org$bukkit$Material;
  static CLOCK: org$bukkit$Material;
  static COAL: org$bukkit$Material;
  static COAL_BLOCK: org$bukkit$Material;
  static COAL_ORE: org$bukkit$Material;
  static COARSE_DIRT: org$bukkit$Material;
  static COBBLESTONE: org$bukkit$Material;
  static COBBLESTONE_SLAB: org$bukkit$Material;
  static COBBLESTONE_STAIRS: org$bukkit$Material;
  static COBBLESTONE_WALL: org$bukkit$Material;
  static COBWEB: org$bukkit$Material;
  static COCOA: org$bukkit$Material;
  static COCOA_BEANS: org$bukkit$Material;
  static COD: org$bukkit$Material;
  static COD_BUCKET: org$bukkit$Material;
  static COD_SPAWN_EGG: org$bukkit$Material;
  static COMMAND_BLOCK: org$bukkit$Material;
  static COMMAND_BLOCK_MINECART: org$bukkit$Material;
  static COMPARATOR: org$bukkit$Material;
  static COMPASS: org$bukkit$Material;
  static COMPOSTER: org$bukkit$Material;
  static CONDUIT: org$bukkit$Material;
  static COOKED_BEEF: org$bukkit$Material;
  static COOKED_CHICKEN: org$bukkit$Material;
  static COOKED_COD: org$bukkit$Material;
  static COOKED_MUTTON: org$bukkit$Material;
  static COOKED_PORKCHOP: org$bukkit$Material;
  static COOKED_RABBIT: org$bukkit$Material;
  static COOKED_SALMON: org$bukkit$Material;
  static COOKIE: org$bukkit$Material;
  static CORNFLOWER: org$bukkit$Material;
  static COW_SPAWN_EGG: org$bukkit$Material;
  static CRACKED_STONE_BRICKS: org$bukkit$Material;
  static CRAFTING_TABLE: org$bukkit$Material;
  static CREEPER_BANNER_PATTERN: org$bukkit$Material;
  static CREEPER_HEAD: org$bukkit$Material;
  static CREEPER_SPAWN_EGG: org$bukkit$Material;
  static CREEPER_WALL_HEAD: org$bukkit$Material;
  static CROSSBOW: org$bukkit$Material;
  static CUT_RED_SANDSTONE: org$bukkit$Material;
  static CUT_RED_SANDSTONE_SLAB: org$bukkit$Material;
  static CUT_SANDSTONE: org$bukkit$Material;
  static CUT_SANDSTONE_SLAB: org$bukkit$Material;
  static CYAN_BANNER: org$bukkit$Material;
  static CYAN_BED: org$bukkit$Material;
  static CYAN_CARPET: org$bukkit$Material;
  static CYAN_CONCRETE: org$bukkit$Material;
  static CYAN_CONCRETE_POWDER: org$bukkit$Material;
  static CYAN_DYE: org$bukkit$Material;
  static CYAN_GLAZED_TERRACOTTA: org$bukkit$Material;
  static CYAN_SHULKER_BOX: org$bukkit$Material;
  static CYAN_STAINED_GLASS: org$bukkit$Material;
  static CYAN_STAINED_GLASS_PANE: org$bukkit$Material;
  static CYAN_TERRACOTTA: org$bukkit$Material;
  static CYAN_WALL_BANNER: org$bukkit$Material;
  static CYAN_WOOL: org$bukkit$Material;
  static DAMAGED_ANVIL: org$bukkit$Material;
  static DANDELION: org$bukkit$Material;
  static DARK_OAK_BOAT: org$bukkit$Material;
  static DARK_OAK_BUTTON: org$bukkit$Material;
  static DARK_OAK_DOOR: org$bukkit$Material;
  static DARK_OAK_FENCE: org$bukkit$Material;
  static DARK_OAK_FENCE_GATE: org$bukkit$Material;
  static DARK_OAK_LEAVES: org$bukkit$Material;
  static DARK_OAK_LOG: org$bukkit$Material;
  static DARK_OAK_PLANKS: org$bukkit$Material;
  static DARK_OAK_PRESSURE_PLATE: org$bukkit$Material;
  static DARK_OAK_SAPLING: org$bukkit$Material;
  static DARK_OAK_SIGN: org$bukkit$Material;
  static DARK_OAK_SLAB: org$bukkit$Material;
  static DARK_OAK_STAIRS: org$bukkit$Material;
  static DARK_OAK_TRAPDOOR: org$bukkit$Material;
  static DARK_OAK_WALL_SIGN: org$bukkit$Material;
  static DARK_OAK_WOOD: org$bukkit$Material;
  static DARK_PRISMARINE: org$bukkit$Material;
  static DARK_PRISMARINE_SLAB: org$bukkit$Material;
  static DARK_PRISMARINE_STAIRS: org$bukkit$Material;
  static DAYLIGHT_DETECTOR: org$bukkit$Material;
  static DEAD_BRAIN_CORAL: org$bukkit$Material;
  static DEAD_BRAIN_CORAL_BLOCK: org$bukkit$Material;
  static DEAD_BRAIN_CORAL_FAN: org$bukkit$Material;
  static DEAD_BRAIN_CORAL_WALL_FAN: org$bukkit$Material;
  static DEAD_BUBBLE_CORAL: org$bukkit$Material;
  static DEAD_BUBBLE_CORAL_BLOCK: org$bukkit$Material;
  static DEAD_BUBBLE_CORAL_FAN: org$bukkit$Material;
  static DEAD_BUBBLE_CORAL_WALL_FAN: org$bukkit$Material;
  static DEAD_BUSH: org$bukkit$Material;
  static DEAD_FIRE_CORAL: org$bukkit$Material;
  static DEAD_FIRE_CORAL_BLOCK: org$bukkit$Material;
  static DEAD_FIRE_CORAL_FAN: org$bukkit$Material;
  static DEAD_FIRE_CORAL_WALL_FAN: org$bukkit$Material;
  static DEAD_HORN_CORAL: org$bukkit$Material;
  static DEAD_HORN_CORAL_BLOCK: org$bukkit$Material;
  static DEAD_HORN_CORAL_FAN: org$bukkit$Material;
  static DEAD_HORN_CORAL_WALL_FAN: org$bukkit$Material;
  static DEAD_TUBE_CORAL: org$bukkit$Material;
  static DEAD_TUBE_CORAL_BLOCK: org$bukkit$Material;
  static DEAD_TUBE_CORAL_FAN: org$bukkit$Material;
  static DEAD_TUBE_CORAL_WALL_FAN: org$bukkit$Material;
  static DEBUG_STICK: org$bukkit$Material;
  static DETECTOR_RAIL: org$bukkit$Material;
  static DIAMOND: org$bukkit$Material;
  static DIAMOND_AXE: org$bukkit$Material;
  static DIAMOND_BLOCK: org$bukkit$Material;
  static DIAMOND_BOOTS: org$bukkit$Material;
  static DIAMOND_CHESTPLATE: org$bukkit$Material;
  static DIAMOND_HELMET: org$bukkit$Material;
  static DIAMOND_HOE: org$bukkit$Material;
  static DIAMOND_HORSE_ARMOR: org$bukkit$Material;
  static DIAMOND_LEGGINGS: org$bukkit$Material;
  static DIAMOND_ORE: org$bukkit$Material;
  static DIAMOND_PICKAXE: org$bukkit$Material;
  static DIAMOND_SHOVEL: org$bukkit$Material;
  static DIAMOND_SWORD: org$bukkit$Material;
  static DIORITE: org$bukkit$Material;
  static DIORITE_SLAB: org$bukkit$Material;
  static DIORITE_STAIRS: org$bukkit$Material;
  static DIORITE_WALL: org$bukkit$Material;
  static DIRT: org$bukkit$Material;
  static DISPENSER: org$bukkit$Material;
  static DOLPHIN_SPAWN_EGG: org$bukkit$Material;
  static DONKEY_SPAWN_EGG: org$bukkit$Material;
  static DRAGON_BREATH: org$bukkit$Material;
  static DRAGON_EGG: org$bukkit$Material;
  static DRAGON_HEAD: org$bukkit$Material;
  static DRAGON_WALL_HEAD: org$bukkit$Material;
  static DRIED_KELP: org$bukkit$Material;
  static DRIED_KELP_BLOCK: org$bukkit$Material;
  static DROPPER: org$bukkit$Material;
  static DROWNED_SPAWN_EGG: org$bukkit$Material;
  static EGG: org$bukkit$Material;
  static ELDER_GUARDIAN_SPAWN_EGG: org$bukkit$Material;
  static ELYTRA: org$bukkit$Material;
  static EMERALD: org$bukkit$Material;
  static EMERALD_BLOCK: org$bukkit$Material;
  static EMERALD_ORE: org$bukkit$Material;
  static ENCHANTED_BOOK: org$bukkit$Material;
  static ENCHANTED_GOLDEN_APPLE: org$bukkit$Material;
  static ENCHANTING_TABLE: org$bukkit$Material;
  static ENDERMAN_SPAWN_EGG: org$bukkit$Material;
  static ENDERMITE_SPAWN_EGG: org$bukkit$Material;
  static ENDER_CHEST: org$bukkit$Material;
  static ENDER_EYE: org$bukkit$Material;
  static ENDER_PEARL: org$bukkit$Material;
  static END_CRYSTAL: org$bukkit$Material;
  static END_GATEWAY: org$bukkit$Material;
  static END_PORTAL: org$bukkit$Material;
  static END_PORTAL_FRAME: org$bukkit$Material;
  static END_ROD: org$bukkit$Material;
  static END_STONE: org$bukkit$Material;
  static END_STONE_BRICKS: org$bukkit$Material;
  static END_STONE_BRICK_SLAB: org$bukkit$Material;
  static END_STONE_BRICK_STAIRS: org$bukkit$Material;
  static END_STONE_BRICK_WALL: org$bukkit$Material;
  static EVOKER_SPAWN_EGG: org$bukkit$Material;
  static EXPERIENCE_BOTTLE: org$bukkit$Material;
  static FARMLAND: org$bukkit$Material;
  static FEATHER: org$bukkit$Material;
  static FERMENTED_SPIDER_EYE: org$bukkit$Material;
  static FERN: org$bukkit$Material;
  static FILLED_MAP: org$bukkit$Material;
  static FIRE: org$bukkit$Material;
  static FIREWORK_ROCKET: org$bukkit$Material;
  static FIREWORK_STAR: org$bukkit$Material;
  static FIRE_CHARGE: org$bukkit$Material;
  static FIRE_CORAL: org$bukkit$Material;
  static FIRE_CORAL_BLOCK: org$bukkit$Material;
  static FIRE_CORAL_FAN: org$bukkit$Material;
  static FIRE_CORAL_WALL_FAN: org$bukkit$Material;
  static FISHING_ROD: org$bukkit$Material;
  static FLETCHING_TABLE: org$bukkit$Material;
  static FLINT: org$bukkit$Material;
  static FLINT_AND_STEEL: org$bukkit$Material;
  static FLOWER_BANNER_PATTERN: org$bukkit$Material;
  static FLOWER_POT: org$bukkit$Material;
  static FOX_SPAWN_EGG: org$bukkit$Material;
  static FROSTED_ICE: org$bukkit$Material;
  static FURNACE: org$bukkit$Material;
  static FURNACE_MINECART: org$bukkit$Material;
  static GHAST_SPAWN_EGG: org$bukkit$Material;
  static GHAST_TEAR: org$bukkit$Material;
  static GLASS: org$bukkit$Material;
  static GLASS_BOTTLE: org$bukkit$Material;
  static GLASS_PANE: org$bukkit$Material;
  static GLISTERING_MELON_SLICE: org$bukkit$Material;
  static GLOBE_BANNER_PATTERN: org$bukkit$Material;
  static GLOWSTONE: org$bukkit$Material;
  static GLOWSTONE_DUST: org$bukkit$Material;
  static GOLDEN_APPLE: org$bukkit$Material;
  static GOLDEN_AXE: org$bukkit$Material;
  static GOLDEN_BOOTS: org$bukkit$Material;
  static GOLDEN_CARROT: org$bukkit$Material;
  static GOLDEN_CHESTPLATE: org$bukkit$Material;
  static GOLDEN_HELMET: org$bukkit$Material;
  static GOLDEN_HOE: org$bukkit$Material;
  static GOLDEN_HORSE_ARMOR: org$bukkit$Material;
  static GOLDEN_LEGGINGS: org$bukkit$Material;
  static GOLDEN_PICKAXE: org$bukkit$Material;
  static GOLDEN_SHOVEL: org$bukkit$Material;
  static GOLDEN_SWORD: org$bukkit$Material;
  static GOLD_BLOCK: org$bukkit$Material;
  static GOLD_INGOT: org$bukkit$Material;
  static GOLD_NUGGET: org$bukkit$Material;
  static GOLD_ORE: org$bukkit$Material;
  static GRANITE: org$bukkit$Material;
  static GRANITE_SLAB: org$bukkit$Material;
  static GRANITE_STAIRS: org$bukkit$Material;
  static GRANITE_WALL: org$bukkit$Material;
  static GRASS: org$bukkit$Material;
  static GRASS_BLOCK: org$bukkit$Material;
  static GRASS_PATH: org$bukkit$Material;
  static GRAVEL: org$bukkit$Material;
  static GRAY_BANNER: org$bukkit$Material;
  static GRAY_BED: org$bukkit$Material;
  static GRAY_CARPET: org$bukkit$Material;
  static GRAY_CONCRETE: org$bukkit$Material;
  static GRAY_CONCRETE_POWDER: org$bukkit$Material;
  static GRAY_DYE: org$bukkit$Material;
  static GRAY_GLAZED_TERRACOTTA: org$bukkit$Material;
  static GRAY_SHULKER_BOX: org$bukkit$Material;
  static GRAY_STAINED_GLASS: org$bukkit$Material;
  static GRAY_STAINED_GLASS_PANE: org$bukkit$Material;
  static GRAY_TERRACOTTA: org$bukkit$Material;
  static GRAY_WALL_BANNER: org$bukkit$Material;
  static GRAY_WOOL: org$bukkit$Material;
  static GREEN_BANNER: org$bukkit$Material;
  static GREEN_BED: org$bukkit$Material;
  static GREEN_CARPET: org$bukkit$Material;
  static GREEN_CONCRETE: org$bukkit$Material;
  static GREEN_CONCRETE_POWDER: org$bukkit$Material;
  static GREEN_DYE: org$bukkit$Material;
  static GREEN_GLAZED_TERRACOTTA: org$bukkit$Material;
  static GREEN_SHULKER_BOX: org$bukkit$Material;
  static GREEN_STAINED_GLASS: org$bukkit$Material;
  static GREEN_STAINED_GLASS_PANE: org$bukkit$Material;
  static GREEN_TERRACOTTA: org$bukkit$Material;
  static GREEN_WALL_BANNER: org$bukkit$Material;
  static GREEN_WOOL: org$bukkit$Material;
  static GRINDSTONE: org$bukkit$Material;
  static GUARDIAN_SPAWN_EGG: org$bukkit$Material;
  static GUNPOWDER: org$bukkit$Material;
  static HAY_BLOCK: org$bukkit$Material;
  static HEART_OF_THE_SEA: org$bukkit$Material;
  static HEAVY_WEIGHTED_PRESSURE_PLATE: org$bukkit$Material;
  static HONEYCOMB: org$bukkit$Material;
  static HONEYCOMB_BLOCK: org$bukkit$Material;
  static HONEY_BLOCK: org$bukkit$Material;
  static HONEY_BOTTLE: org$bukkit$Material;
  static HOPPER: org$bukkit$Material;
  static HOPPER_MINECART: org$bukkit$Material;
  static HORN_CORAL: org$bukkit$Material;
  static HORN_CORAL_BLOCK: org$bukkit$Material;
  static HORN_CORAL_FAN: org$bukkit$Material;
  static HORN_CORAL_WALL_FAN: org$bukkit$Material;
  static HORSE_SPAWN_EGG: org$bukkit$Material;
  static HUSK_SPAWN_EGG: org$bukkit$Material;
  static ICE: org$bukkit$Material;
  static INFESTED_CHISELED_STONE_BRICKS: org$bukkit$Material;
  static INFESTED_COBBLESTONE: org$bukkit$Material;
  static INFESTED_CRACKED_STONE_BRICKS: org$bukkit$Material;
  static INFESTED_MOSSY_STONE_BRICKS: org$bukkit$Material;
  static INFESTED_STONE: org$bukkit$Material;
  static INFESTED_STONE_BRICKS: org$bukkit$Material;
  static INK_SAC: org$bukkit$Material;
  static IRON_AXE: org$bukkit$Material;
  static IRON_BARS: org$bukkit$Material;
  static IRON_BLOCK: org$bukkit$Material;
  static IRON_BOOTS: org$bukkit$Material;
  static IRON_CHESTPLATE: org$bukkit$Material;
  static IRON_DOOR: org$bukkit$Material;
  static IRON_HELMET: org$bukkit$Material;
  static IRON_HOE: org$bukkit$Material;
  static IRON_HORSE_ARMOR: org$bukkit$Material;
  static IRON_INGOT: org$bukkit$Material;
  static IRON_LEGGINGS: org$bukkit$Material;
  static IRON_NUGGET: org$bukkit$Material;
  static IRON_ORE: org$bukkit$Material;
  static IRON_PICKAXE: org$bukkit$Material;
  static IRON_SHOVEL: org$bukkit$Material;
  static IRON_SWORD: org$bukkit$Material;
  static IRON_TRAPDOOR: org$bukkit$Material;
  static ITEM_FRAME: org$bukkit$Material;
  static JACK_O_LANTERN: org$bukkit$Material;
  static JIGSAW: org$bukkit$Material;
  static JUKEBOX: org$bukkit$Material;
  static JUNGLE_BOAT: org$bukkit$Material;
  static JUNGLE_BUTTON: org$bukkit$Material;
  static JUNGLE_DOOR: org$bukkit$Material;
  static JUNGLE_FENCE: org$bukkit$Material;
  static JUNGLE_FENCE_GATE: org$bukkit$Material;
  static JUNGLE_LEAVES: org$bukkit$Material;
  static JUNGLE_LOG: org$bukkit$Material;
  static JUNGLE_PLANKS: org$bukkit$Material;
  static JUNGLE_PRESSURE_PLATE: org$bukkit$Material;
  static JUNGLE_SAPLING: org$bukkit$Material;
  static JUNGLE_SIGN: org$bukkit$Material;
  static JUNGLE_SLAB: org$bukkit$Material;
  static JUNGLE_STAIRS: org$bukkit$Material;
  static JUNGLE_TRAPDOOR: org$bukkit$Material;
  static JUNGLE_WALL_SIGN: org$bukkit$Material;
  static JUNGLE_WOOD: org$bukkit$Material;
  static KELP: org$bukkit$Material;
  static KELP_PLANT: org$bukkit$Material;
  static KNOWLEDGE_BOOK: org$bukkit$Material;
  static LADDER: org$bukkit$Material;
  static LANTERN: org$bukkit$Material;
  static LAPIS_BLOCK: org$bukkit$Material;
  static LAPIS_LAZULI: org$bukkit$Material;
  static LAPIS_ORE: org$bukkit$Material;
  static LARGE_FERN: org$bukkit$Material;
  static LAVA: org$bukkit$Material;
  static LAVA_BUCKET: org$bukkit$Material;
  static LEAD: org$bukkit$Material;
  static LEATHER: org$bukkit$Material;
  static LEATHER_BOOTS: org$bukkit$Material;
  static LEATHER_CHESTPLATE: org$bukkit$Material;
  static LEATHER_HELMET: org$bukkit$Material;
  static LEATHER_HORSE_ARMOR: org$bukkit$Material;
  static LEATHER_LEGGINGS: org$bukkit$Material;
  static LECTERN: org$bukkit$Material;
  static LEVER: org$bukkit$Material;
  static LIGHT_BLUE_BANNER: org$bukkit$Material;
  static LIGHT_BLUE_BED: org$bukkit$Material;
  static LIGHT_BLUE_CARPET: org$bukkit$Material;
  static LIGHT_BLUE_CONCRETE: org$bukkit$Material;
  static LIGHT_BLUE_CONCRETE_POWDER: org$bukkit$Material;
  static LIGHT_BLUE_DYE: org$bukkit$Material;
  static LIGHT_BLUE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LIGHT_BLUE_SHULKER_BOX: org$bukkit$Material;
  static LIGHT_BLUE_STAINED_GLASS: org$bukkit$Material;
  static LIGHT_BLUE_STAINED_GLASS_PANE: org$bukkit$Material;
  static LIGHT_BLUE_TERRACOTTA: org$bukkit$Material;
  static LIGHT_BLUE_WALL_BANNER: org$bukkit$Material;
  static LIGHT_BLUE_WOOL: org$bukkit$Material;
  static LIGHT_GRAY_BANNER: org$bukkit$Material;
  static LIGHT_GRAY_BED: org$bukkit$Material;
  static LIGHT_GRAY_CARPET: org$bukkit$Material;
  static LIGHT_GRAY_CONCRETE: org$bukkit$Material;
  static LIGHT_GRAY_CONCRETE_POWDER: org$bukkit$Material;
  static LIGHT_GRAY_DYE: org$bukkit$Material;
  static LIGHT_GRAY_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LIGHT_GRAY_SHULKER_BOX: org$bukkit$Material;
  static LIGHT_GRAY_STAINED_GLASS: org$bukkit$Material;
  static LIGHT_GRAY_STAINED_GLASS_PANE: org$bukkit$Material;
  static LIGHT_GRAY_TERRACOTTA: org$bukkit$Material;
  static LIGHT_GRAY_WALL_BANNER: org$bukkit$Material;
  static LIGHT_GRAY_WOOL: org$bukkit$Material;
  static LIGHT_WEIGHTED_PRESSURE_PLATE: org$bukkit$Material;
  static LILAC: org$bukkit$Material;
  static LILY_OF_THE_VALLEY: org$bukkit$Material;
  static LILY_PAD: org$bukkit$Material;
  static LIME_BANNER: org$bukkit$Material;
  static LIME_BED: org$bukkit$Material;
  static LIME_CARPET: org$bukkit$Material;
  static LIME_CONCRETE: org$bukkit$Material;
  static LIME_CONCRETE_POWDER: org$bukkit$Material;
  static LIME_DYE: org$bukkit$Material;
  static LIME_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LIME_SHULKER_BOX: org$bukkit$Material;
  static LIME_STAINED_GLASS: org$bukkit$Material;
  static LIME_STAINED_GLASS_PANE: org$bukkit$Material;
  static LIME_TERRACOTTA: org$bukkit$Material;
  static LIME_WALL_BANNER: org$bukkit$Material;
  static LIME_WOOL: org$bukkit$Material;
  static LINGERING_POTION: org$bukkit$Material;
  static LLAMA_SPAWN_EGG: org$bukkit$Material;
  static LOOM: org$bukkit$Material;
  static MAGENTA_BANNER: org$bukkit$Material;
  static MAGENTA_BED: org$bukkit$Material;
  static MAGENTA_CARPET: org$bukkit$Material;
  static MAGENTA_CONCRETE: org$bukkit$Material;
  static MAGENTA_CONCRETE_POWDER: org$bukkit$Material;
  static MAGENTA_DYE: org$bukkit$Material;
  static MAGENTA_GLAZED_TERRACOTTA: org$bukkit$Material;
  static MAGENTA_SHULKER_BOX: org$bukkit$Material;
  static MAGENTA_STAINED_GLASS: org$bukkit$Material;
  static MAGENTA_STAINED_GLASS_PANE: org$bukkit$Material;
  static MAGENTA_TERRACOTTA: org$bukkit$Material;
  static MAGENTA_WALL_BANNER: org$bukkit$Material;
  static MAGENTA_WOOL: org$bukkit$Material;
  static MAGMA_BLOCK: org$bukkit$Material;
  static MAGMA_CREAM: org$bukkit$Material;
  static MAGMA_CUBE_SPAWN_EGG: org$bukkit$Material;
  static MAP: org$bukkit$Material;
  static MELON: org$bukkit$Material;
  static MELON_SEEDS: org$bukkit$Material;
  static MELON_SLICE: org$bukkit$Material;
  static MELON_STEM: org$bukkit$Material;
  static MILK_BUCKET: org$bukkit$Material;
  static MINECART: org$bukkit$Material;
  static MOJANG_BANNER_PATTERN: org$bukkit$Material;
  static MOOSHROOM_SPAWN_EGG: org$bukkit$Material;
  static MOSSY_COBBLESTONE: org$bukkit$Material;
  static MOSSY_COBBLESTONE_SLAB: org$bukkit$Material;
  static MOSSY_COBBLESTONE_STAIRS: org$bukkit$Material;
  static MOSSY_COBBLESTONE_WALL: org$bukkit$Material;
  static MOSSY_STONE_BRICKS: org$bukkit$Material;
  static MOSSY_STONE_BRICK_SLAB: org$bukkit$Material;
  static MOSSY_STONE_BRICK_STAIRS: org$bukkit$Material;
  static MOSSY_STONE_BRICK_WALL: org$bukkit$Material;
  static MOVING_PISTON: org$bukkit$Material;
  static MULE_SPAWN_EGG: org$bukkit$Material;
  static MUSHROOM_STEM: org$bukkit$Material;
  static MUSHROOM_STEW: org$bukkit$Material;
  static MUSIC_DISC_11: org$bukkit$Material;
  static MUSIC_DISC_13: org$bukkit$Material;
  static MUSIC_DISC_BLOCKS: org$bukkit$Material;
  static MUSIC_DISC_CAT: org$bukkit$Material;
  static MUSIC_DISC_CHIRP: org$bukkit$Material;
  static MUSIC_DISC_FAR: org$bukkit$Material;
  static MUSIC_DISC_MALL: org$bukkit$Material;
  static MUSIC_DISC_MELLOHI: org$bukkit$Material;
  static MUSIC_DISC_STAL: org$bukkit$Material;
  static MUSIC_DISC_STRAD: org$bukkit$Material;
  static MUSIC_DISC_WAIT: org$bukkit$Material;
  static MUSIC_DISC_WARD: org$bukkit$Material;
  static MUTTON: org$bukkit$Material;
  static MYCELIUM: org$bukkit$Material;
  static NAME_TAG: org$bukkit$Material;
  static NAUTILUS_SHELL: org$bukkit$Material;
  static NETHERRACK: org$bukkit$Material;
  static NETHER_BRICK: org$bukkit$Material;
  static NETHER_BRICKS: org$bukkit$Material;
  static NETHER_BRICK_FENCE: org$bukkit$Material;
  static NETHER_BRICK_SLAB: org$bukkit$Material;
  static NETHER_BRICK_STAIRS: org$bukkit$Material;
  static NETHER_BRICK_WALL: org$bukkit$Material;
  static NETHER_PORTAL: org$bukkit$Material;
  static NETHER_QUARTZ_ORE: org$bukkit$Material;
  static NETHER_STAR: org$bukkit$Material;
  static NETHER_WART: org$bukkit$Material;
  static NETHER_WART_BLOCK: org$bukkit$Material;
  static NOTE_BLOCK: org$bukkit$Material;
  static OAK_BOAT: org$bukkit$Material;
  static OAK_BUTTON: org$bukkit$Material;
  static OAK_DOOR: org$bukkit$Material;
  static OAK_FENCE: org$bukkit$Material;
  static OAK_FENCE_GATE: org$bukkit$Material;
  static OAK_LEAVES: org$bukkit$Material;
  static OAK_LOG: org$bukkit$Material;
  static OAK_PLANKS: org$bukkit$Material;
  static OAK_PRESSURE_PLATE: org$bukkit$Material;
  static OAK_SAPLING: org$bukkit$Material;
  static OAK_SIGN: org$bukkit$Material;
  static OAK_SLAB: org$bukkit$Material;
  static OAK_STAIRS: org$bukkit$Material;
  static OAK_TRAPDOOR: org$bukkit$Material;
  static OAK_WALL_SIGN: org$bukkit$Material;
  static OAK_WOOD: org$bukkit$Material;
  static OBSERVER: org$bukkit$Material;
  static OBSIDIAN: org$bukkit$Material;
  static OCELOT_SPAWN_EGG: org$bukkit$Material;
  static ORANGE_BANNER: org$bukkit$Material;
  static ORANGE_BED: org$bukkit$Material;
  static ORANGE_CARPET: org$bukkit$Material;
  static ORANGE_CONCRETE: org$bukkit$Material;
  static ORANGE_CONCRETE_POWDER: org$bukkit$Material;
  static ORANGE_DYE: org$bukkit$Material;
  static ORANGE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static ORANGE_SHULKER_BOX: org$bukkit$Material;
  static ORANGE_STAINED_GLASS: org$bukkit$Material;
  static ORANGE_STAINED_GLASS_PANE: org$bukkit$Material;
  static ORANGE_TERRACOTTA: org$bukkit$Material;
  static ORANGE_TULIP: org$bukkit$Material;
  static ORANGE_WALL_BANNER: org$bukkit$Material;
  static ORANGE_WOOL: org$bukkit$Material;
  static OXEYE_DAISY: org$bukkit$Material;
  static PACKED_ICE: org$bukkit$Material;
  static PAINTING: org$bukkit$Material;
  static PANDA_SPAWN_EGG: org$bukkit$Material;
  static PAPER: org$bukkit$Material;
  static PARROT_SPAWN_EGG: org$bukkit$Material;
  static PEONY: org$bukkit$Material;
  static PETRIFIED_OAK_SLAB: org$bukkit$Material;
  static PHANTOM_MEMBRANE: org$bukkit$Material;
  static PHANTOM_SPAWN_EGG: org$bukkit$Material;
  static PIG_SPAWN_EGG: org$bukkit$Material;
  static PILLAGER_SPAWN_EGG: org$bukkit$Material;
  static PINK_BANNER: org$bukkit$Material;
  static PINK_BED: org$bukkit$Material;
  static PINK_CARPET: org$bukkit$Material;
  static PINK_CONCRETE: org$bukkit$Material;
  static PINK_CONCRETE_POWDER: org$bukkit$Material;
  static PINK_DYE: org$bukkit$Material;
  static PINK_GLAZED_TERRACOTTA: org$bukkit$Material;
  static PINK_SHULKER_BOX: org$bukkit$Material;
  static PINK_STAINED_GLASS: org$bukkit$Material;
  static PINK_STAINED_GLASS_PANE: org$bukkit$Material;
  static PINK_TERRACOTTA: org$bukkit$Material;
  static PINK_TULIP: org$bukkit$Material;
  static PINK_WALL_BANNER: org$bukkit$Material;
  static PINK_WOOL: org$bukkit$Material;
  static PISTON: org$bukkit$Material;
  static PISTON_HEAD: org$bukkit$Material;
  static PLAYER_HEAD: org$bukkit$Material;
  static PLAYER_WALL_HEAD: org$bukkit$Material;
  static PODZOL: org$bukkit$Material;
  static POISONOUS_POTATO: org$bukkit$Material;
  static POLAR_BEAR_SPAWN_EGG: org$bukkit$Material;
  static POLISHED_ANDESITE: org$bukkit$Material;
  static POLISHED_ANDESITE_SLAB: org$bukkit$Material;
  static POLISHED_ANDESITE_STAIRS: org$bukkit$Material;
  static POLISHED_DIORITE: org$bukkit$Material;
  static POLISHED_DIORITE_SLAB: org$bukkit$Material;
  static POLISHED_DIORITE_STAIRS: org$bukkit$Material;
  static POLISHED_GRANITE: org$bukkit$Material;
  static POLISHED_GRANITE_SLAB: org$bukkit$Material;
  static POLISHED_GRANITE_STAIRS: org$bukkit$Material;
  static POPPED_CHORUS_FRUIT: org$bukkit$Material;
  static POPPY: org$bukkit$Material;
  static PORKCHOP: org$bukkit$Material;
  static POTATO: org$bukkit$Material;
  static POTATOES: org$bukkit$Material;
  static POTION: org$bukkit$Material;
  static POTTED_ACACIA_SAPLING: org$bukkit$Material;
  static POTTED_ALLIUM: org$bukkit$Material;
  static POTTED_AZURE_BLUET: org$bukkit$Material;
  static POTTED_BAMBOO: org$bukkit$Material;
  static POTTED_BIRCH_SAPLING: org$bukkit$Material;
  static POTTED_BLUE_ORCHID: org$bukkit$Material;
  static POTTED_BROWN_MUSHROOM: org$bukkit$Material;
  static POTTED_CACTUS: org$bukkit$Material;
  static POTTED_CORNFLOWER: org$bukkit$Material;
  static POTTED_DANDELION: org$bukkit$Material;
  static POTTED_DARK_OAK_SAPLING: org$bukkit$Material;
  static POTTED_DEAD_BUSH: org$bukkit$Material;
  static POTTED_FERN: org$bukkit$Material;
  static POTTED_JUNGLE_SAPLING: org$bukkit$Material;
  static POTTED_LILY_OF_THE_VALLEY: org$bukkit$Material;
  static POTTED_OAK_SAPLING: org$bukkit$Material;
  static POTTED_ORANGE_TULIP: org$bukkit$Material;
  static POTTED_OXEYE_DAISY: org$bukkit$Material;
  static POTTED_PINK_TULIP: org$bukkit$Material;
  static POTTED_POPPY: org$bukkit$Material;
  static POTTED_RED_MUSHROOM: org$bukkit$Material;
  static POTTED_RED_TULIP: org$bukkit$Material;
  static POTTED_SPRUCE_SAPLING: org$bukkit$Material;
  static POTTED_WHITE_TULIP: org$bukkit$Material;
  static POTTED_WITHER_ROSE: org$bukkit$Material;
  static POWERED_RAIL: org$bukkit$Material;
  static PRISMARINE: org$bukkit$Material;
  static PRISMARINE_BRICKS: org$bukkit$Material;
  static PRISMARINE_BRICK_SLAB: org$bukkit$Material;
  static PRISMARINE_BRICK_STAIRS: org$bukkit$Material;
  static PRISMARINE_CRYSTALS: org$bukkit$Material;
  static PRISMARINE_SHARD: org$bukkit$Material;
  static PRISMARINE_SLAB: org$bukkit$Material;
  static PRISMARINE_STAIRS: org$bukkit$Material;
  static PRISMARINE_WALL: org$bukkit$Material;
  static PUFFERFISH: org$bukkit$Material;
  static PUFFERFISH_BUCKET: org$bukkit$Material;
  static PUFFERFISH_SPAWN_EGG: org$bukkit$Material;
  static PUMPKIN: org$bukkit$Material;
  static PUMPKIN_PIE: org$bukkit$Material;
  static PUMPKIN_SEEDS: org$bukkit$Material;
  static PUMPKIN_STEM: org$bukkit$Material;
  static PURPLE_BANNER: org$bukkit$Material;
  static PURPLE_BED: org$bukkit$Material;
  static PURPLE_CARPET: org$bukkit$Material;
  static PURPLE_CONCRETE: org$bukkit$Material;
  static PURPLE_CONCRETE_POWDER: org$bukkit$Material;
  static PURPLE_DYE: org$bukkit$Material;
  static PURPLE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static PURPLE_SHULKER_BOX: org$bukkit$Material;
  static PURPLE_STAINED_GLASS: org$bukkit$Material;
  static PURPLE_STAINED_GLASS_PANE: org$bukkit$Material;
  static PURPLE_TERRACOTTA: org$bukkit$Material;
  static PURPLE_WALL_BANNER: org$bukkit$Material;
  static PURPLE_WOOL: org$bukkit$Material;
  static PURPUR_BLOCK: org$bukkit$Material;
  static PURPUR_PILLAR: org$bukkit$Material;
  static PURPUR_SLAB: org$bukkit$Material;
  static PURPUR_STAIRS: org$bukkit$Material;
  static QUARTZ: org$bukkit$Material;
  static QUARTZ_BLOCK: org$bukkit$Material;
  static QUARTZ_PILLAR: org$bukkit$Material;
  static QUARTZ_SLAB: org$bukkit$Material;
  static QUARTZ_STAIRS: org$bukkit$Material;
  static RABBIT: org$bukkit$Material;
  static RABBIT_FOOT: org$bukkit$Material;
  static RABBIT_HIDE: org$bukkit$Material;
  static RABBIT_SPAWN_EGG: org$bukkit$Material;
  static RABBIT_STEW: org$bukkit$Material;
  static RAIL: org$bukkit$Material;
  static RAVAGER_SPAWN_EGG: org$bukkit$Material;
  static REDSTONE: org$bukkit$Material;
  static REDSTONE_BLOCK: org$bukkit$Material;
  static REDSTONE_LAMP: org$bukkit$Material;
  static REDSTONE_ORE: org$bukkit$Material;
  static REDSTONE_TORCH: org$bukkit$Material;
  static REDSTONE_WALL_TORCH: org$bukkit$Material;
  static REDSTONE_WIRE: org$bukkit$Material;
  static RED_BANNER: org$bukkit$Material;
  static RED_BED: org$bukkit$Material;
  static RED_CARPET: org$bukkit$Material;
  static RED_CONCRETE: org$bukkit$Material;
  static RED_CONCRETE_POWDER: org$bukkit$Material;
  static RED_DYE: org$bukkit$Material;
  static RED_GLAZED_TERRACOTTA: org$bukkit$Material;
  static RED_MUSHROOM: org$bukkit$Material;
  static RED_MUSHROOM_BLOCK: org$bukkit$Material;
  static RED_NETHER_BRICKS: org$bukkit$Material;
  static RED_NETHER_BRICK_SLAB: org$bukkit$Material;
  static RED_NETHER_BRICK_STAIRS: org$bukkit$Material;
  static RED_NETHER_BRICK_WALL: org$bukkit$Material;
  static RED_SAND: org$bukkit$Material;
  static RED_SANDSTONE: org$bukkit$Material;
  static RED_SANDSTONE_SLAB: org$bukkit$Material;
  static RED_SANDSTONE_STAIRS: org$bukkit$Material;
  static RED_SANDSTONE_WALL: org$bukkit$Material;
  static RED_SHULKER_BOX: org$bukkit$Material;
  static RED_STAINED_GLASS: org$bukkit$Material;
  static RED_STAINED_GLASS_PANE: org$bukkit$Material;
  static RED_TERRACOTTA: org$bukkit$Material;
  static RED_TULIP: org$bukkit$Material;
  static RED_WALL_BANNER: org$bukkit$Material;
  static RED_WOOL: org$bukkit$Material;
  static REPEATER: org$bukkit$Material;
  static REPEATING_COMMAND_BLOCK: org$bukkit$Material;
  static ROSE_BUSH: org$bukkit$Material;
  static ROTTEN_FLESH: org$bukkit$Material;
  static SADDLE: org$bukkit$Material;
  static SALMON: org$bukkit$Material;
  static SALMON_BUCKET: org$bukkit$Material;
  static SALMON_SPAWN_EGG: org$bukkit$Material;
  static SAND: org$bukkit$Material;
  static SANDSTONE: org$bukkit$Material;
  static SANDSTONE_SLAB: org$bukkit$Material;
  static SANDSTONE_STAIRS: org$bukkit$Material;
  static SANDSTONE_WALL: org$bukkit$Material;
  static SCAFFOLDING: org$bukkit$Material;
  static SCUTE: org$bukkit$Material;
  static SEAGRASS: org$bukkit$Material;
  static SEA_LANTERN: org$bukkit$Material;
  static SEA_PICKLE: org$bukkit$Material;
  static SHEARS: org$bukkit$Material;
  static SHEEP_SPAWN_EGG: org$bukkit$Material;
  static SHIELD: org$bukkit$Material;
  static SHULKER_BOX: org$bukkit$Material;
  static SHULKER_SHELL: org$bukkit$Material;
  static SHULKER_SPAWN_EGG: org$bukkit$Material;
  static SILVERFISH_SPAWN_EGG: org$bukkit$Material;
  static SKELETON_HORSE_SPAWN_EGG: org$bukkit$Material;
  static SKELETON_SKULL: org$bukkit$Material;
  static SKELETON_SPAWN_EGG: org$bukkit$Material;
  static SKELETON_WALL_SKULL: org$bukkit$Material;
  static SKULL_BANNER_PATTERN: org$bukkit$Material;
  static SLIME_BALL: org$bukkit$Material;
  static SLIME_BLOCK: org$bukkit$Material;
  static SLIME_SPAWN_EGG: org$bukkit$Material;
  static SMITHING_TABLE: org$bukkit$Material;
  static SMOKER: org$bukkit$Material;
  static SMOOTH_QUARTZ: org$bukkit$Material;
  static SMOOTH_QUARTZ_SLAB: org$bukkit$Material;
  static SMOOTH_QUARTZ_STAIRS: org$bukkit$Material;
  static SMOOTH_RED_SANDSTONE: org$bukkit$Material;
  static SMOOTH_RED_SANDSTONE_SLAB: org$bukkit$Material;
  static SMOOTH_RED_SANDSTONE_STAIRS: org$bukkit$Material;
  static SMOOTH_SANDSTONE: org$bukkit$Material;
  static SMOOTH_SANDSTONE_SLAB: org$bukkit$Material;
  static SMOOTH_SANDSTONE_STAIRS: org$bukkit$Material;
  static SMOOTH_STONE: org$bukkit$Material;
  static SMOOTH_STONE_SLAB: org$bukkit$Material;
  static SNOW: org$bukkit$Material;
  static SNOWBALL: org$bukkit$Material;
  static SNOW_BLOCK: org$bukkit$Material;
  static SOUL_SAND: org$bukkit$Material;
  static SPAWNER: org$bukkit$Material;
  static SPECTRAL_ARROW: org$bukkit$Material;
  static SPIDER_EYE: org$bukkit$Material;
  static SPIDER_SPAWN_EGG: org$bukkit$Material;
  static SPLASH_POTION: org$bukkit$Material;
  static SPONGE: org$bukkit$Material;
  static SPRUCE_BOAT: org$bukkit$Material;
  static SPRUCE_BUTTON: org$bukkit$Material;
  static SPRUCE_DOOR: org$bukkit$Material;
  static SPRUCE_FENCE: org$bukkit$Material;
  static SPRUCE_FENCE_GATE: org$bukkit$Material;
  static SPRUCE_LEAVES: org$bukkit$Material;
  static SPRUCE_LOG: org$bukkit$Material;
  static SPRUCE_PLANKS: org$bukkit$Material;
  static SPRUCE_PRESSURE_PLATE: org$bukkit$Material;
  static SPRUCE_SAPLING: org$bukkit$Material;
  static SPRUCE_SIGN: org$bukkit$Material;
  static SPRUCE_SLAB: org$bukkit$Material;
  static SPRUCE_STAIRS: org$bukkit$Material;
  static SPRUCE_TRAPDOOR: org$bukkit$Material;
  static SPRUCE_WALL_SIGN: org$bukkit$Material;
  static SPRUCE_WOOD: org$bukkit$Material;
  static SQUID_SPAWN_EGG: org$bukkit$Material;
  static STICK: org$bukkit$Material;
  static STICKY_PISTON: org$bukkit$Material;
  static STONE: org$bukkit$Material;
  static STONECUTTER: org$bukkit$Material;
  static STONE_AXE: org$bukkit$Material;
  static STONE_BRICKS: org$bukkit$Material;
  static STONE_BRICK_SLAB: org$bukkit$Material;
  static STONE_BRICK_STAIRS: org$bukkit$Material;
  static STONE_BRICK_WALL: org$bukkit$Material;
  static STONE_BUTTON: org$bukkit$Material;
  static STONE_HOE: org$bukkit$Material;
  static STONE_PICKAXE: org$bukkit$Material;
  static STONE_PRESSURE_PLATE: org$bukkit$Material;
  static STONE_SHOVEL: org$bukkit$Material;
  static STONE_SLAB: org$bukkit$Material;
  static STONE_STAIRS: org$bukkit$Material;
  static STONE_SWORD: org$bukkit$Material;
  static STRAY_SPAWN_EGG: org$bukkit$Material;
  static STRING: org$bukkit$Material;
  static STRIPPED_ACACIA_LOG: org$bukkit$Material;
  static STRIPPED_ACACIA_WOOD: org$bukkit$Material;
  static STRIPPED_BIRCH_LOG: org$bukkit$Material;
  static STRIPPED_BIRCH_WOOD: org$bukkit$Material;
  static STRIPPED_DARK_OAK_LOG: org$bukkit$Material;
  static STRIPPED_DARK_OAK_WOOD: org$bukkit$Material;
  static STRIPPED_JUNGLE_LOG: org$bukkit$Material;
  static STRIPPED_JUNGLE_WOOD: org$bukkit$Material;
  static STRIPPED_OAK_LOG: org$bukkit$Material;
  static STRIPPED_OAK_WOOD: org$bukkit$Material;
  static STRIPPED_SPRUCE_LOG: org$bukkit$Material;
  static STRIPPED_SPRUCE_WOOD: org$bukkit$Material;
  static STRUCTURE_BLOCK: org$bukkit$Material;
  static STRUCTURE_VOID: org$bukkit$Material;
  static SUGAR: org$bukkit$Material;
  static SUGAR_CANE: org$bukkit$Material;
  static SUNFLOWER: org$bukkit$Material;
  static SUSPICIOUS_STEW: org$bukkit$Material;
  static SWEET_BERRIES: org$bukkit$Material;
  static SWEET_BERRY_BUSH: org$bukkit$Material;
  static TALL_GRASS: org$bukkit$Material;
  static TALL_SEAGRASS: org$bukkit$Material;
  static TERRACOTTA: org$bukkit$Material;
  static TIPPED_ARROW: org$bukkit$Material;
  static TNT: org$bukkit$Material;
  static TNT_MINECART: org$bukkit$Material;
  static TORCH: org$bukkit$Material;
  static TOTEM_OF_UNDYING: org$bukkit$Material;
  static TRADER_LLAMA_SPAWN_EGG: org$bukkit$Material;
  static TRAPPED_CHEST: org$bukkit$Material;
  static TRIDENT: org$bukkit$Material;
  static TRIPWIRE: org$bukkit$Material;
  static TRIPWIRE_HOOK: org$bukkit$Material;
  static TROPICAL_FISH: org$bukkit$Material;
  static TROPICAL_FISH_BUCKET: org$bukkit$Material;
  static TROPICAL_FISH_SPAWN_EGG: org$bukkit$Material;
  static TUBE_CORAL: org$bukkit$Material;
  static TUBE_CORAL_BLOCK: org$bukkit$Material;
  static TUBE_CORAL_FAN: org$bukkit$Material;
  static TUBE_CORAL_WALL_FAN: org$bukkit$Material;
  static TURTLE_EGG: org$bukkit$Material;
  static TURTLE_HELMET: org$bukkit$Material;
  static TURTLE_SPAWN_EGG: org$bukkit$Material;
  static VEX_SPAWN_EGG: org$bukkit$Material;
  static VILLAGER_SPAWN_EGG: org$bukkit$Material;
  static VINDICATOR_SPAWN_EGG: org$bukkit$Material;
  static VINE: org$bukkit$Material;
  static VOID_AIR: org$bukkit$Material;
  static WALL_TORCH: org$bukkit$Material;
  static WANDERING_TRADER_SPAWN_EGG: org$bukkit$Material;
  static WATER: org$bukkit$Material;
  static WATER_BUCKET: org$bukkit$Material;
  static WET_SPONGE: org$bukkit$Material;
  static WHEAT: org$bukkit$Material;
  static WHEAT_SEEDS: org$bukkit$Material;
  static WHITE_BANNER: org$bukkit$Material;
  static WHITE_BED: org$bukkit$Material;
  static WHITE_CARPET: org$bukkit$Material;
  static WHITE_CONCRETE: org$bukkit$Material;
  static WHITE_CONCRETE_POWDER: org$bukkit$Material;
  static WHITE_DYE: org$bukkit$Material;
  static WHITE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static WHITE_SHULKER_BOX: org$bukkit$Material;
  static WHITE_STAINED_GLASS: org$bukkit$Material;
  static WHITE_STAINED_GLASS_PANE: org$bukkit$Material;
  static WHITE_TERRACOTTA: org$bukkit$Material;
  static WHITE_TULIP: org$bukkit$Material;
  static WHITE_WALL_BANNER: org$bukkit$Material;
  static WHITE_WOOL: org$bukkit$Material;
  static WITCH_SPAWN_EGG: org$bukkit$Material;
  static WITHER_ROSE: org$bukkit$Material;
  static WITHER_SKELETON_SKULL: org$bukkit$Material;
  static WITHER_SKELETON_SPAWN_EGG: org$bukkit$Material;
  static WITHER_SKELETON_WALL_SKULL: org$bukkit$Material;
  static WOLF_SPAWN_EGG: org$bukkit$Material;
  static WOODEN_AXE: org$bukkit$Material;
  static WOODEN_HOE: org$bukkit$Material;
  static WOODEN_PICKAXE: org$bukkit$Material;
  static WOODEN_SHOVEL: org$bukkit$Material;
  static WOODEN_SWORD: org$bukkit$Material;
  static WRITABLE_BOOK: org$bukkit$Material;
  static WRITTEN_BOOK: org$bukkit$Material;
  static YELLOW_BANNER: org$bukkit$Material;
  static YELLOW_BED: org$bukkit$Material;
  static YELLOW_CARPET: org$bukkit$Material;
  static YELLOW_CONCRETE: org$bukkit$Material;
  static YELLOW_CONCRETE_POWDER: org$bukkit$Material;
  static YELLOW_DYE: org$bukkit$Material;
  static YELLOW_GLAZED_TERRACOTTA: org$bukkit$Material;
  static YELLOW_SHULKER_BOX: org$bukkit$Material;
  static YELLOW_STAINED_GLASS: org$bukkit$Material;
  static YELLOW_STAINED_GLASS_PANE: org$bukkit$Material;
  static YELLOW_TERRACOTTA: org$bukkit$Material;
  static YELLOW_WALL_BANNER: org$bukkit$Material;
  static YELLOW_WOOL: org$bukkit$Material;
  static ZOMBIE_HEAD: org$bukkit$Material;
  static ZOMBIE_HORSE_SPAWN_EGG: org$bukkit$Material;
  static ZOMBIE_PIGMAN_SPAWN_EGG: org$bukkit$Material;
  static ZOMBIE_SPAWN_EGG: org$bukkit$Material;
  static ZOMBIE_VILLAGER_SPAWN_EGG: org$bukkit$Material;
  static ZOMBIE_WALL_HEAD: org$bukkit$Material;
  static LEGACY_AIR: org$bukkit$Material;
  static LEGACY_STONE: org$bukkit$Material;
  static LEGACY_GRASS: org$bukkit$Material;
  static LEGACY_DIRT: org$bukkit$Material;
  static LEGACY_COBBLESTONE: org$bukkit$Material;
  static LEGACY_WOOD: org$bukkit$Material;
  static LEGACY_SAPLING: org$bukkit$Material;
  static LEGACY_BEDROCK: org$bukkit$Material;
  static LEGACY_WATER: org$bukkit$Material;
  static LEGACY_STATIONARY_WATER: org$bukkit$Material;
  static LEGACY_LAVA: org$bukkit$Material;
  static LEGACY_STATIONARY_LAVA: org$bukkit$Material;
  static LEGACY_SAND: org$bukkit$Material;
  static LEGACY_GRAVEL: org$bukkit$Material;
  static LEGACY_GOLD_ORE: org$bukkit$Material;
  static LEGACY_IRON_ORE: org$bukkit$Material;
  static LEGACY_COAL_ORE: org$bukkit$Material;
  static LEGACY_LOG: org$bukkit$Material;
  static LEGACY_LEAVES: org$bukkit$Material;
  static LEGACY_SPONGE: org$bukkit$Material;
  static LEGACY_GLASS: org$bukkit$Material;
  static LEGACY_LAPIS_ORE: org$bukkit$Material;
  static LEGACY_LAPIS_BLOCK: org$bukkit$Material;
  static LEGACY_DISPENSER: org$bukkit$Material;
  static LEGACY_SANDSTONE: org$bukkit$Material;
  static LEGACY_NOTE_BLOCK: org$bukkit$Material;
  static LEGACY_BED_BLOCK: org$bukkit$Material;
  static LEGACY_POWERED_RAIL: org$bukkit$Material;
  static LEGACY_DETECTOR_RAIL: org$bukkit$Material;
  static LEGACY_PISTON_STICKY_BASE: org$bukkit$Material;
  static LEGACY_WEB: org$bukkit$Material;
  static LEGACY_LONG_GRASS: org$bukkit$Material;
  static LEGACY_DEAD_BUSH: org$bukkit$Material;
  static LEGACY_PISTON_BASE: org$bukkit$Material;
  static LEGACY_PISTON_EXTENSION: org$bukkit$Material;
  static LEGACY_WOOL: org$bukkit$Material;
  static LEGACY_PISTON_MOVING_PIECE: org$bukkit$Material;
  static LEGACY_YELLOW_FLOWER: org$bukkit$Material;
  static LEGACY_RED_ROSE: org$bukkit$Material;
  static LEGACY_BROWN_MUSHROOM: org$bukkit$Material;
  static LEGACY_RED_MUSHROOM: org$bukkit$Material;
  static LEGACY_GOLD_BLOCK: org$bukkit$Material;
  static LEGACY_IRON_BLOCK: org$bukkit$Material;
  static LEGACY_DOUBLE_STEP: org$bukkit$Material;
  static LEGACY_STEP: org$bukkit$Material;
  static LEGACY_BRICK: org$bukkit$Material;
  static LEGACY_TNT: org$bukkit$Material;
  static LEGACY_BOOKSHELF: org$bukkit$Material;
  static LEGACY_MOSSY_COBBLESTONE: org$bukkit$Material;
  static LEGACY_OBSIDIAN: org$bukkit$Material;
  static LEGACY_TORCH: org$bukkit$Material;
  static LEGACY_FIRE: org$bukkit$Material;
  static LEGACY_MOB_SPAWNER: org$bukkit$Material;
  static LEGACY_WOOD_STAIRS: org$bukkit$Material;
  static LEGACY_CHEST: org$bukkit$Material;
  static LEGACY_REDSTONE_WIRE: org$bukkit$Material;
  static LEGACY_DIAMOND_ORE: org$bukkit$Material;
  static LEGACY_DIAMOND_BLOCK: org$bukkit$Material;
  static LEGACY_WORKBENCH: org$bukkit$Material;
  static LEGACY_CROPS: org$bukkit$Material;
  static LEGACY_SOIL: org$bukkit$Material;
  static LEGACY_FURNACE: org$bukkit$Material;
  static LEGACY_BURNING_FURNACE: org$bukkit$Material;
  static LEGACY_SIGN_POST: org$bukkit$Material;
  static LEGACY_WOODEN_DOOR: org$bukkit$Material;
  static LEGACY_LADDER: org$bukkit$Material;
  static LEGACY_RAILS: org$bukkit$Material;
  static LEGACY_COBBLESTONE_STAIRS: org$bukkit$Material;
  static LEGACY_WALL_SIGN: org$bukkit$Material;
  static LEGACY_LEVER: org$bukkit$Material;
  static LEGACY_STONE_PLATE: org$bukkit$Material;
  static LEGACY_IRON_DOOR_BLOCK: org$bukkit$Material;
  static LEGACY_WOOD_PLATE: org$bukkit$Material;
  static LEGACY_REDSTONE_ORE: org$bukkit$Material;
  static LEGACY_GLOWING_REDSTONE_ORE: org$bukkit$Material;
  static LEGACY_REDSTONE_TORCH_OFF: org$bukkit$Material;
  static LEGACY_REDSTONE_TORCH_ON: org$bukkit$Material;
  static LEGACY_STONE_BUTTON: org$bukkit$Material;
  static LEGACY_SNOW: org$bukkit$Material;
  static LEGACY_ICE: org$bukkit$Material;
  static LEGACY_SNOW_BLOCK: org$bukkit$Material;
  static LEGACY_CACTUS: org$bukkit$Material;
  static LEGACY_CLAY: org$bukkit$Material;
  static LEGACY_SUGAR_CANE_BLOCK: org$bukkit$Material;
  static LEGACY_JUKEBOX: org$bukkit$Material;
  static LEGACY_FENCE: org$bukkit$Material;
  static LEGACY_PUMPKIN: org$bukkit$Material;
  static LEGACY_NETHERRACK: org$bukkit$Material;
  static LEGACY_SOUL_SAND: org$bukkit$Material;
  static LEGACY_GLOWSTONE: org$bukkit$Material;
  static LEGACY_PORTAL: org$bukkit$Material;
  static LEGACY_JACK_O_LANTERN: org$bukkit$Material;
  static LEGACY_CAKE_BLOCK: org$bukkit$Material;
  static LEGACY_DIODE_BLOCK_OFF: org$bukkit$Material;
  static LEGACY_DIODE_BLOCK_ON: org$bukkit$Material;
  static LEGACY_STAINED_GLASS: org$bukkit$Material;
  static LEGACY_TRAP_DOOR: org$bukkit$Material;
  static LEGACY_MONSTER_EGGS: org$bukkit$Material;
  static LEGACY_SMOOTH_BRICK: org$bukkit$Material;
  static LEGACY_HUGE_MUSHROOM_1: org$bukkit$Material;
  static LEGACY_HUGE_MUSHROOM_2: org$bukkit$Material;
  static LEGACY_IRON_FENCE: org$bukkit$Material;
  static LEGACY_THIN_GLASS: org$bukkit$Material;
  static LEGACY_MELON_BLOCK: org$bukkit$Material;
  static LEGACY_PUMPKIN_STEM: org$bukkit$Material;
  static LEGACY_MELON_STEM: org$bukkit$Material;
  static LEGACY_VINE: org$bukkit$Material;
  static LEGACY_FENCE_GATE: org$bukkit$Material;
  static LEGACY_BRICK_STAIRS: org$bukkit$Material;
  static LEGACY_SMOOTH_STAIRS: org$bukkit$Material;
  static LEGACY_MYCEL: org$bukkit$Material;
  static LEGACY_WATER_LILY: org$bukkit$Material;
  static LEGACY_NETHER_BRICK: org$bukkit$Material;
  static LEGACY_NETHER_FENCE: org$bukkit$Material;
  static LEGACY_NETHER_BRICK_STAIRS: org$bukkit$Material;
  static LEGACY_NETHER_WARTS: org$bukkit$Material;
  static LEGACY_ENCHANTMENT_TABLE: org$bukkit$Material;
  static LEGACY_BREWING_STAND: org$bukkit$Material;
  static LEGACY_CAULDRON: org$bukkit$Material;
  static LEGACY_ENDER_PORTAL: org$bukkit$Material;
  static LEGACY_ENDER_PORTAL_FRAME: org$bukkit$Material;
  static LEGACY_ENDER_STONE: org$bukkit$Material;
  static LEGACY_DRAGON_EGG: org$bukkit$Material;
  static LEGACY_REDSTONE_LAMP_OFF: org$bukkit$Material;
  static LEGACY_REDSTONE_LAMP_ON: org$bukkit$Material;
  static LEGACY_WOOD_DOUBLE_STEP: org$bukkit$Material;
  static LEGACY_WOOD_STEP: org$bukkit$Material;
  static LEGACY_COCOA: org$bukkit$Material;
  static LEGACY_SANDSTONE_STAIRS: org$bukkit$Material;
  static LEGACY_EMERALD_ORE: org$bukkit$Material;
  static LEGACY_ENDER_CHEST: org$bukkit$Material;
  static LEGACY_TRIPWIRE_HOOK: org$bukkit$Material;
  static LEGACY_TRIPWIRE: org$bukkit$Material;
  static LEGACY_EMERALD_BLOCK: org$bukkit$Material;
  static LEGACY_SPRUCE_WOOD_STAIRS: org$bukkit$Material;
  static LEGACY_BIRCH_WOOD_STAIRS: org$bukkit$Material;
  static LEGACY_JUNGLE_WOOD_STAIRS: org$bukkit$Material;
  static LEGACY_COMMAND: org$bukkit$Material;
  static LEGACY_BEACON: org$bukkit$Material;
  static LEGACY_COBBLE_WALL: org$bukkit$Material;
  static LEGACY_FLOWER_POT: org$bukkit$Material;
  static LEGACY_CARROT: org$bukkit$Material;
  static LEGACY_POTATO: org$bukkit$Material;
  static LEGACY_WOOD_BUTTON: org$bukkit$Material;
  static LEGACY_SKULL: org$bukkit$Material;
  static LEGACY_ANVIL: org$bukkit$Material;
  static LEGACY_TRAPPED_CHEST: org$bukkit$Material;
  static LEGACY_GOLD_PLATE: org$bukkit$Material;
  static LEGACY_IRON_PLATE: org$bukkit$Material;
  static LEGACY_REDSTONE_COMPARATOR_OFF: org$bukkit$Material;
  static LEGACY_REDSTONE_COMPARATOR_ON: org$bukkit$Material;
  static LEGACY_DAYLIGHT_DETECTOR: org$bukkit$Material;
  static LEGACY_REDSTONE_BLOCK: org$bukkit$Material;
  static LEGACY_QUARTZ_ORE: org$bukkit$Material;
  static LEGACY_HOPPER: org$bukkit$Material;
  static LEGACY_QUARTZ_BLOCK: org$bukkit$Material;
  static LEGACY_QUARTZ_STAIRS: org$bukkit$Material;
  static LEGACY_ACTIVATOR_RAIL: org$bukkit$Material;
  static LEGACY_DROPPER: org$bukkit$Material;
  static LEGACY_STAINED_CLAY: org$bukkit$Material;
  static LEGACY_STAINED_GLASS_PANE: org$bukkit$Material;
  static LEGACY_LEAVES_2: org$bukkit$Material;
  static LEGACY_LOG_2: org$bukkit$Material;
  static LEGACY_ACACIA_STAIRS: org$bukkit$Material;
  static LEGACY_DARK_OAK_STAIRS: org$bukkit$Material;
  static LEGACY_SLIME_BLOCK: org$bukkit$Material;
  static LEGACY_BARRIER: org$bukkit$Material;
  static LEGACY_IRON_TRAPDOOR: org$bukkit$Material;
  static LEGACY_PRISMARINE: org$bukkit$Material;
  static LEGACY_SEA_LANTERN: org$bukkit$Material;
  static LEGACY_HAY_BLOCK: org$bukkit$Material;
  static LEGACY_CARPET: org$bukkit$Material;
  static LEGACY_HARD_CLAY: org$bukkit$Material;
  static LEGACY_COAL_BLOCK: org$bukkit$Material;
  static LEGACY_PACKED_ICE: org$bukkit$Material;
  static LEGACY_DOUBLE_PLANT: org$bukkit$Material;
  static LEGACY_STANDING_BANNER: org$bukkit$Material;
  static LEGACY_WALL_BANNER: org$bukkit$Material;
  static LEGACY_DAYLIGHT_DETECTOR_INVERTED: org$bukkit$Material;
  static LEGACY_RED_SANDSTONE: org$bukkit$Material;
  static LEGACY_RED_SANDSTONE_STAIRS: org$bukkit$Material;
  static LEGACY_DOUBLE_STONE_SLAB2: org$bukkit$Material;
  static LEGACY_STONE_SLAB2: org$bukkit$Material;
  static LEGACY_SPRUCE_FENCE_GATE: org$bukkit$Material;
  static LEGACY_BIRCH_FENCE_GATE: org$bukkit$Material;
  static LEGACY_JUNGLE_FENCE_GATE: org$bukkit$Material;
  static LEGACY_DARK_OAK_FENCE_GATE: org$bukkit$Material;
  static LEGACY_ACACIA_FENCE_GATE: org$bukkit$Material;
  static LEGACY_SPRUCE_FENCE: org$bukkit$Material;
  static LEGACY_BIRCH_FENCE: org$bukkit$Material;
  static LEGACY_JUNGLE_FENCE: org$bukkit$Material;
  static LEGACY_DARK_OAK_FENCE: org$bukkit$Material;
  static LEGACY_ACACIA_FENCE: org$bukkit$Material;
  static LEGACY_SPRUCE_DOOR: org$bukkit$Material;
  static LEGACY_BIRCH_DOOR: org$bukkit$Material;
  static LEGACY_JUNGLE_DOOR: org$bukkit$Material;
  static LEGACY_ACACIA_DOOR: org$bukkit$Material;
  static LEGACY_DARK_OAK_DOOR: org$bukkit$Material;
  static LEGACY_END_ROD: org$bukkit$Material;
  static LEGACY_CHORUS_PLANT: org$bukkit$Material;
  static LEGACY_CHORUS_FLOWER: org$bukkit$Material;
  static LEGACY_PURPUR_BLOCK: org$bukkit$Material;
  static LEGACY_PURPUR_PILLAR: org$bukkit$Material;
  static LEGACY_PURPUR_STAIRS: org$bukkit$Material;
  static LEGACY_PURPUR_DOUBLE_SLAB: org$bukkit$Material;
  static LEGACY_PURPUR_SLAB: org$bukkit$Material;
  static LEGACY_END_BRICKS: org$bukkit$Material;
  static LEGACY_BEETROOT_BLOCK: org$bukkit$Material;
  static LEGACY_GRASS_PATH: org$bukkit$Material;
  static LEGACY_END_GATEWAY: org$bukkit$Material;
  static LEGACY_COMMAND_REPEATING: org$bukkit$Material;
  static LEGACY_COMMAND_CHAIN: org$bukkit$Material;
  static LEGACY_FROSTED_ICE: org$bukkit$Material;
  static LEGACY_MAGMA: org$bukkit$Material;
  static LEGACY_NETHER_WART_BLOCK: org$bukkit$Material;
  static LEGACY_RED_NETHER_BRICK: org$bukkit$Material;
  static LEGACY_BONE_BLOCK: org$bukkit$Material;
  static LEGACY_STRUCTURE_VOID: org$bukkit$Material;
  static LEGACY_OBSERVER: org$bukkit$Material;
  static LEGACY_WHITE_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_ORANGE_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_MAGENTA_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_LIGHT_BLUE_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_YELLOW_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_LIME_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_PINK_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_GRAY_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_SILVER_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_CYAN_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_PURPLE_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_BLUE_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_BROWN_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_GREEN_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_RED_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_BLACK_SHULKER_BOX: org$bukkit$Material;
  static LEGACY_WHITE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_ORANGE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_MAGENTA_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_LIGHT_BLUE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_YELLOW_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_LIME_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_PINK_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_GRAY_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_SILVER_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_CYAN_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_PURPLE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_BLUE_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_BROWN_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_GREEN_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_RED_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_BLACK_GLAZED_TERRACOTTA: org$bukkit$Material;
  static LEGACY_CONCRETE: org$bukkit$Material;
  static LEGACY_CONCRETE_POWDER: org$bukkit$Material;
  static LEGACY_STRUCTURE_BLOCK: org$bukkit$Material;
  static LEGACY_IRON_SPADE: org$bukkit$Material;
  static LEGACY_IRON_PICKAXE: org$bukkit$Material;
  static LEGACY_IRON_AXE: org$bukkit$Material;
  static LEGACY_FLINT_AND_STEEL: org$bukkit$Material;
  static LEGACY_APPLE: org$bukkit$Material;
  static LEGACY_BOW: org$bukkit$Material;
  static LEGACY_ARROW: org$bukkit$Material;
  static LEGACY_COAL: org$bukkit$Material;
  static LEGACY_DIAMOND: org$bukkit$Material;
  static LEGACY_IRON_INGOT: org$bukkit$Material;
  static LEGACY_GOLD_INGOT: org$bukkit$Material;
  static LEGACY_IRON_SWORD: org$bukkit$Material;
  static LEGACY_WOOD_SWORD: org$bukkit$Material;
  static LEGACY_WOOD_SPADE: org$bukkit$Material;
  static LEGACY_WOOD_PICKAXE: org$bukkit$Material;
  static LEGACY_WOOD_AXE: org$bukkit$Material;
  static LEGACY_STONE_SWORD: org$bukkit$Material;
  static LEGACY_STONE_SPADE: org$bukkit$Material;
  static LEGACY_STONE_PICKAXE: org$bukkit$Material;
  static LEGACY_STONE_AXE: org$bukkit$Material;
  static LEGACY_DIAMOND_SWORD: org$bukkit$Material;
  static LEGACY_DIAMOND_SPADE: org$bukkit$Material;
  static LEGACY_DIAMOND_PICKAXE: org$bukkit$Material;
  static LEGACY_DIAMOND_AXE: org$bukkit$Material;
  static LEGACY_STICK: org$bukkit$Material;
  static LEGACY_BOWL: org$bukkit$Material;
  static LEGACY_MUSHROOM_SOUP: org$bukkit$Material;
  static LEGACY_GOLD_SWORD: org$bukkit$Material;
  static LEGACY_GOLD_SPADE: org$bukkit$Material;
  static LEGACY_GOLD_PICKAXE: org$bukkit$Material;
  static LEGACY_GOLD_AXE: org$bukkit$Material;
  static LEGACY_STRING: org$bukkit$Material;
  static LEGACY_FEATHER: org$bukkit$Material;
  static LEGACY_SULPHUR: org$bukkit$Material;
  static LEGACY_WOOD_HOE: org$bukkit$Material;
  static LEGACY_STONE_HOE: org$bukkit$Material;
  static LEGACY_IRON_HOE: org$bukkit$Material;
  static LEGACY_DIAMOND_HOE: org$bukkit$Material;
  static LEGACY_GOLD_HOE: org$bukkit$Material;
  static LEGACY_SEEDS: org$bukkit$Material;
  static LEGACY_WHEAT: org$bukkit$Material;
  static LEGACY_BREAD: org$bukkit$Material;
  static LEGACY_LEATHER_HELMET: org$bukkit$Material;
  static LEGACY_LEATHER_CHESTPLATE: org$bukkit$Material;
  static LEGACY_LEATHER_LEGGINGS: org$bukkit$Material;
  static LEGACY_LEATHER_BOOTS: org$bukkit$Material;
  static LEGACY_CHAINMAIL_HELMET: org$bukkit$Material;
  static LEGACY_CHAINMAIL_CHESTPLATE: org$bukkit$Material;
  static LEGACY_CHAINMAIL_LEGGINGS: org$bukkit$Material;
  static LEGACY_CHAINMAIL_BOOTS: org$bukkit$Material;
  static LEGACY_IRON_HELMET: org$bukkit$Material;
  static LEGACY_IRON_CHESTPLATE: org$bukkit$Material;
  static LEGACY_IRON_LEGGINGS: org$bukkit$Material;
  static LEGACY_IRON_BOOTS: org$bukkit$Material;
  static LEGACY_DIAMOND_HELMET: org$bukkit$Material;
  static LEGACY_DIAMOND_CHESTPLATE: org$bukkit$Material;
  static LEGACY_DIAMOND_LEGGINGS: org$bukkit$Material;
  static LEGACY_DIAMOND_BOOTS: org$bukkit$Material;
  static LEGACY_GOLD_HELMET: org$bukkit$Material;
  static LEGACY_GOLD_CHESTPLATE: org$bukkit$Material;
  static LEGACY_GOLD_LEGGINGS: org$bukkit$Material;
  static LEGACY_GOLD_BOOTS: org$bukkit$Material;
  static LEGACY_FLINT: org$bukkit$Material;
  static LEGACY_PORK: org$bukkit$Material;
  static LEGACY_GRILLED_PORK: org$bukkit$Material;
  static LEGACY_PAINTING: org$bukkit$Material;
  static LEGACY_GOLDEN_APPLE: org$bukkit$Material;
  static LEGACY_SIGN: org$bukkit$Material;
  static LEGACY_WOOD_DOOR: org$bukkit$Material;
  static LEGACY_BUCKET: org$bukkit$Material;
  static LEGACY_WATER_BUCKET: org$bukkit$Material;
  static LEGACY_LAVA_BUCKET: org$bukkit$Material;
  static LEGACY_MINECART: org$bukkit$Material;
  static LEGACY_SADDLE: org$bukkit$Material;
  static LEGACY_IRON_DOOR: org$bukkit$Material;
  static LEGACY_REDSTONE: org$bukkit$Material;
  static LEGACY_SNOW_BALL: org$bukkit$Material;
  static LEGACY_BOAT: org$bukkit$Material;
  static LEGACY_LEATHER: org$bukkit$Material;
  static LEGACY_MILK_BUCKET: org$bukkit$Material;
  static LEGACY_CLAY_BRICK: org$bukkit$Material;
  static LEGACY_CLAY_BALL: org$bukkit$Material;
  static LEGACY_SUGAR_CANE: org$bukkit$Material;
  static LEGACY_PAPER: org$bukkit$Material;
  static LEGACY_BOOK: org$bukkit$Material;
  static LEGACY_SLIME_BALL: org$bukkit$Material;
  static LEGACY_STORAGE_MINECART: org$bukkit$Material;
  static LEGACY_POWERED_MINECART: org$bukkit$Material;
  static LEGACY_EGG: org$bukkit$Material;
  static LEGACY_COMPASS: org$bukkit$Material;
  static LEGACY_FISHING_ROD: org$bukkit$Material;
  static LEGACY_WATCH: org$bukkit$Material;
  static LEGACY_GLOWSTONE_DUST: org$bukkit$Material;
  static LEGACY_RAW_FISH: org$bukkit$Material;
  static LEGACY_COOKED_FISH: org$bukkit$Material;
  static LEGACY_INK_SACK: org$bukkit$Material;
  static LEGACY_BONE: org$bukkit$Material;
  static LEGACY_SUGAR: org$bukkit$Material;
  static LEGACY_CAKE: org$bukkit$Material;
  static LEGACY_BED: org$bukkit$Material;
  static LEGACY_DIODE: org$bukkit$Material;
  static LEGACY_COOKIE: org$bukkit$Material;
  static LEGACY_MAP: org$bukkit$Material;
  static LEGACY_SHEARS: org$bukkit$Material;
  static LEGACY_MELON: org$bukkit$Material;
  static LEGACY_PUMPKIN_SEEDS: org$bukkit$Material;
  static LEGACY_MELON_SEEDS: org$bukkit$Material;
  static LEGACY_RAW_BEEF: org$bukkit$Material;
  static LEGACY_COOKED_BEEF: org$bukkit$Material;
  static LEGACY_RAW_CHICKEN: org$bukkit$Material;
  static LEGACY_COOKED_CHICKEN: org$bukkit$Material;
  static LEGACY_ROTTEN_FLESH: org$bukkit$Material;
  static LEGACY_ENDER_PEARL: org$bukkit$Material;
  static LEGACY_BLAZE_ROD: org$bukkit$Material;
  static LEGACY_GHAST_TEAR: org$bukkit$Material;
  static LEGACY_GOLD_NUGGET: org$bukkit$Material;
  static LEGACY_NETHER_STALK: org$bukkit$Material;
  static LEGACY_POTION: org$bukkit$Material;
  static LEGACY_GLASS_BOTTLE: org$bukkit$Material;
  static LEGACY_SPIDER_EYE: org$bukkit$Material;
  static LEGACY_FERMENTED_SPIDER_EYE: org$bukkit$Material;
  static LEGACY_BLAZE_POWDER: org$bukkit$Material;
  static LEGACY_MAGMA_CREAM: org$bukkit$Material;
  static LEGACY_BREWING_STAND_ITEM: org$bukkit$Material;
  static LEGACY_CAULDRON_ITEM: org$bukkit$Material;
  static LEGACY_EYE_OF_ENDER: org$bukkit$Material;
  static LEGACY_SPECKLED_MELON: org$bukkit$Material;
  static LEGACY_MONSTER_EGG: org$bukkit$Material;
  static LEGACY_EXP_BOTTLE: org$bukkit$Material;
  static LEGACY_FIREBALL: org$bukkit$Material;
  static LEGACY_BOOK_AND_QUILL: org$bukkit$Material;
  static LEGACY_WRITTEN_BOOK: org$bukkit$Material;
  static LEGACY_EMERALD: org$bukkit$Material;
  static LEGACY_ITEM_FRAME: org$bukkit$Material;
  static LEGACY_FLOWER_POT_ITEM: org$bukkit$Material;
  static LEGACY_CARROT_ITEM: org$bukkit$Material;
  static LEGACY_POTATO_ITEM: org$bukkit$Material;
  static LEGACY_BAKED_POTATO: org$bukkit$Material;
  static LEGACY_POISONOUS_POTATO: org$bukkit$Material;
  static LEGACY_EMPTY_MAP: org$bukkit$Material;
  static LEGACY_GOLDEN_CARROT: org$bukkit$Material;
  static LEGACY_SKULL_ITEM: org$bukkit$Material;
  static LEGACY_CARROT_STICK: org$bukkit$Material;
  static LEGACY_NETHER_STAR: org$bukkit$Material;
  static LEGACY_PUMPKIN_PIE: org$bukkit$Material;
  static LEGACY_FIREWORK: org$bukkit$Material;
  static LEGACY_FIREWORK_CHARGE: org$bukkit$Material;
  static LEGACY_ENCHANTED_BOOK: org$bukkit$Material;
  static LEGACY_REDSTONE_COMPARATOR: org$bukkit$Material;
  static LEGACY_NETHER_BRICK_ITEM: org$bukkit$Material;
  static LEGACY_QUARTZ: org$bukkit$Material;
  static LEGACY_EXPLOSIVE_MINECART: org$bukkit$Material;
  static LEGACY_HOPPER_MINECART: org$bukkit$Material;
  static LEGACY_PRISMARINE_SHARD: org$bukkit$Material;
  static LEGACY_PRISMARINE_CRYSTALS: org$bukkit$Material;
  static LEGACY_RABBIT: org$bukkit$Material;
  static LEGACY_COOKED_RABBIT: org$bukkit$Material;
  static LEGACY_RABBIT_STEW: org$bukkit$Material;
  static LEGACY_RABBIT_FOOT: org$bukkit$Material;
  static LEGACY_RABBIT_HIDE: org$bukkit$Material;
  static LEGACY_ARMOR_STAND: org$bukkit$Material;
  static LEGACY_IRON_BARDING: org$bukkit$Material;
  static LEGACY_GOLD_BARDING: org$bukkit$Material;
  static LEGACY_DIAMOND_BARDING: org$bukkit$Material;
  static LEGACY_LEASH: org$bukkit$Material;
  static LEGACY_NAME_TAG: org$bukkit$Material;
  static LEGACY_COMMAND_MINECART: org$bukkit$Material;
  static LEGACY_MUTTON: org$bukkit$Material;
  static LEGACY_COOKED_MUTTON: org$bukkit$Material;
  static LEGACY_BANNER: org$bukkit$Material;
  static LEGACY_END_CRYSTAL: org$bukkit$Material;
  static LEGACY_SPRUCE_DOOR_ITEM: org$bukkit$Material;
  static LEGACY_BIRCH_DOOR_ITEM: org$bukkit$Material;
  static LEGACY_JUNGLE_DOOR_ITEM: org$bukkit$Material;
  static LEGACY_ACACIA_DOOR_ITEM: org$bukkit$Material;
  static LEGACY_DARK_OAK_DOOR_ITEM: org$bukkit$Material;
  static LEGACY_CHORUS_FRUIT: org$bukkit$Material;
  static LEGACY_CHORUS_FRUIT_POPPED: org$bukkit$Material;
  static LEGACY_BEETROOT: org$bukkit$Material;
  static LEGACY_BEETROOT_SEEDS: org$bukkit$Material;
  static LEGACY_BEETROOT_SOUP: org$bukkit$Material;
  static LEGACY_DRAGONS_BREATH: org$bukkit$Material;
  static LEGACY_SPLASH_POTION: org$bukkit$Material;
  static LEGACY_SPECTRAL_ARROW: org$bukkit$Material;
  static LEGACY_TIPPED_ARROW: org$bukkit$Material;
  static LEGACY_LINGERING_POTION: org$bukkit$Material;
  static LEGACY_SHIELD: org$bukkit$Material;
  static LEGACY_ELYTRA: org$bukkit$Material;
  static LEGACY_BOAT_SPRUCE: org$bukkit$Material;
  static LEGACY_BOAT_BIRCH: org$bukkit$Material;
  static LEGACY_BOAT_JUNGLE: org$bukkit$Material;
  static LEGACY_BOAT_ACACIA: org$bukkit$Material;
  static LEGACY_BOAT_DARK_OAK: org$bukkit$Material;
  static LEGACY_TOTEM: org$bukkit$Material;
  static LEGACY_SHULKER_SHELL: org$bukkit$Material;
  static LEGACY_IRON_NUGGET: org$bukkit$Material;
  static LEGACY_KNOWLEDGE_BOOK: org$bukkit$Material;
  static LEGACY_GOLD_RECORD: org$bukkit$Material;
  static LEGACY_GREEN_RECORD: org$bukkit$Material;
  static LEGACY_RECORD_3: org$bukkit$Material;
  static LEGACY_RECORD_4: org$bukkit$Material;
  static LEGACY_RECORD_5: org$bukkit$Material;
  static LEGACY_RECORD_6: org$bukkit$Material;
  static LEGACY_RECORD_7: org$bukkit$Material;
  static LEGACY_RECORD_8: org$bukkit$Material;
  static LEGACY_RECORD_9: org$bukkit$Material;
  static LEGACY_RECORD_10: org$bukkit$Material;
  static LEGACY_RECORD_11: org$bukkit$Material;
  static LEGACY_RECORD_12: org$bukkit$Material;
  static LEGACY_PREFIX: string;
  data: any; /* java.lang.Class */
  static values(): JavaArray<org$bukkit$Material>;
  static valueOf(arg0: string): org$bukkit$Material;
  isEmpty(): boolean;
  getId(): number;
  isLegacy(): boolean;
  getKey(): org$bukkit$NamespacedKey;
  getMaxStackSize(): number;
  getMaxDurability(): unknown;
  createBlockData(): org$bukkit$block$data$BlockData;
  createBlockData(
    arg0: any /* java.util.function.Consumer */
  ): org$bukkit$block$data$BlockData;
  createBlockData(arg0: string): org$bukkit$block$data$BlockData;
  getData(): any /* java.lang.Class */;
  getNewData(arg0: Buffer): org$bukkit$material$MaterialData;
  isBlock(): boolean;
  isEdible(): boolean;
  static getMaterial(arg0: string): org$bukkit$Material;
  static getMaterial(arg0: string, arg1: boolean): org$bukkit$Material;
  static matchMaterial(arg0: string): org$bukkit$Material;
  static matchMaterial(arg0: string, arg1: boolean): org$bukkit$Material;
  isRecord(): boolean;
  isSolid(): boolean;
  isAir(): boolean;
  isTransparent(): boolean;
  isFlammable(): boolean;
  isBurnable(): boolean;
  isFuel(): boolean;
  isOccluding(): boolean;
  hasGravity(): boolean;
  isItem(): boolean;
  isInteractable(): boolean;
  getHardness(): number;
  getBlastResistance(): number;
  getCraftingRemainingItem(): org$bukkit$Material;
}


declare interface $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
}

declare class org$bukkit$Keyed implements $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$NamespacedKey
  extends $com$destroystokyo$paper$Namespaced {
  getNamespace(): string;
  getKey(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
}

declare class org$bukkit$NamespacedKey implements $org$bukkit$NamespacedKey {
  static MINECRAFT: string;
  static BUKKIT: string;
  constructor(arg0: string, arg1: string);
  constructor(arg0: org$bukkit$plugin$Plugin, arg1: string);
  getNamespace(): string;
  getKey(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  static randomKey(): org$bukkit$NamespacedKey;
  static minecraft(arg0: string): org$bukkit$NamespacedKey;
}


declare interface $com$destroystokyo$paper$Namespaced {
  getNamespace(): string;
  getKey(): string;
}

declare class com$destroystokyo$paper$Namespaced
  implements $com$destroystokyo$paper$Namespaced {
  getNamespace(): string;
  getKey(): string;
}


declare interface $org$bukkit$material$MaterialData {
  getData(): Buffer;
  setData(arg0: Buffer): void;
  getItemType(): org$bukkit$Material;
  toItemStack(): org$bukkit$inventory$ItemStack;
  toItemStack(arg0: number): org$bukkit$inventory$ItemStack;
  toString(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$MaterialData
  implements $org$bukkit$material$MaterialData {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getData(): Buffer;
  setData(arg0: Buffer): void;
  getItemType(): org$bukkit$Material;
  toItemStack(): org$bukkit$inventory$ItemStack;
  toItemStack(arg0: number): org$bukkit$inventory$ItemStack;
  toString(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$inventory$ItemStack
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  getType(): org$bukkit$Material;
  setType(arg0: org$bukkit$Material): void;
  getAmount(): number;
  setAmount(arg0: number): void;
  getData(): org$bukkit$material$MaterialData;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setDurability(arg0: unknown): void;
  getDurability(): unknown;
  getMaxStackSize(): number;
  toString(): string;
  equals(arg0: any): boolean;
  isSimilar(arg0: org$bukkit$inventory$ItemStack): boolean;
  clone(): org$bukkit$inventory$ItemStack;
  hashCode(): number;
  containsEnchantment(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantmentLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchantments(): any /* java.util.Map */;
  addEnchantments(arg0: any /* java.util.Map */): void;
  addEnchantment(arg0: org$bukkit$enchantments$Enchantment, arg1: number): void;
  addUnsafeEnchantments(arg0: any /* java.util.Map */): void;
  addUnsafeEnchantment(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number
  ): void;
  removeEnchantment(arg0: org$bukkit$enchantments$Enchantment): number;
  serialize(): any /* java.util.Map */;
  getItemMeta(): org$bukkit$inventory$meta$ItemMeta;
  hasItemMeta(): boolean;
  setItemMeta(arg0: org$bukkit$inventory$meta$ItemMeta): boolean;
  ensureServerConversions(): org$bukkit$inventory$ItemStack;
  serializeAsBytes(): JavaArray<Buffer>;
  getI18NDisplayName(): string;
  getMaxItemUseDuration(): number;
  asOne(): org$bukkit$inventory$ItemStack;
  asQuantity(arg0: number): org$bukkit$inventory$ItemStack;
  add(): org$bukkit$inventory$ItemStack;
  add(arg0: number): org$bukkit$inventory$ItemStack;
  subtract(): org$bukkit$inventory$ItemStack;
  subtract(arg0: number): org$bukkit$inventory$ItemStack;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  clone(): any;
}

declare class org$bukkit$inventory$ItemStack
  implements $org$bukkit$inventory$ItemStack {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: number);
  constructor(arg0: org$bukkit$Material, arg1: number, arg2: unknown);
  constructor(
    arg0: org$bukkit$Material,
    arg1: number,
    arg2: unknown,
    arg3: any /* java.lang.Byte */
  );
  constructor(arg0: org$bukkit$inventory$ItemStack);
  getType(): org$bukkit$Material;
  setType(arg0: org$bukkit$Material): void;
  getAmount(): number;
  setAmount(arg0: number): void;
  getData(): org$bukkit$material$MaterialData;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setDurability(arg0: unknown): void;
  getDurability(): unknown;
  getMaxStackSize(): number;
  toString(): string;
  equals(arg0: any): boolean;
  isSimilar(arg0: org$bukkit$inventory$ItemStack): boolean;
  clone(): org$bukkit$inventory$ItemStack;
  hashCode(): number;
  containsEnchantment(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantmentLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchantments(): any /* java.util.Map */;
  addEnchantments(arg0: any /* java.util.Map */): void;
  addEnchantment(arg0: org$bukkit$enchantments$Enchantment, arg1: number): void;
  addUnsafeEnchantments(arg0: any /* java.util.Map */): void;
  addUnsafeEnchantment(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number
  ): void;
  removeEnchantment(arg0: org$bukkit$enchantments$Enchantment): number;
  serialize(): any /* java.util.Map */;
  static deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$inventory$ItemStack;
  getItemMeta(): org$bukkit$inventory$meta$ItemMeta;
  hasItemMeta(): boolean;
  setItemMeta(arg0: org$bukkit$inventory$meta$ItemMeta): boolean;
  ensureServerConversions(): org$bukkit$inventory$ItemStack;
  static deserializeBytes(
    arg0: JavaArray<Buffer>
  ): org$bukkit$inventory$ItemStack;
  serializeAsBytes(): JavaArray<Buffer>;
  getI18NDisplayName(): string;
  getMaxItemUseDuration(): number;
  asOne(): org$bukkit$inventory$ItemStack;
  asQuantity(arg0: number): org$bukkit$inventory$ItemStack;
  add(): org$bukkit$inventory$ItemStack;
  add(arg0: number): org$bukkit$inventory$ItemStack;
  subtract(): org$bukkit$inventory$ItemStack;
  subtract(arg0: number): org$bukkit$inventory$ItemStack;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  clone(): any;
}


declare interface $org$bukkit$enchantments$Enchantment
  extends $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
  getName(): string;
  getMaxLevel(): number;
  getStartLevel(): number;
  getItemTarget(): org$bukkit$enchantments$EnchantmentTarget;
  isTreasure(): boolean;
  isCursed(): boolean;
  conflictsWith(arg0: org$bukkit$enchantments$Enchantment): boolean;
  canEnchantItem(arg0: org$bukkit$inventory$ItemStack): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}

declare class org$bukkit$enchantments$Enchantment
  implements $org$bukkit$enchantments$Enchantment {
  static PROTECTION_ENVIRONMENTAL: org$bukkit$enchantments$Enchantment;
  static PROTECTION_FIRE: org$bukkit$enchantments$Enchantment;
  static PROTECTION_FALL: org$bukkit$enchantments$Enchantment;
  static PROTECTION_EXPLOSIONS: org$bukkit$enchantments$Enchantment;
  static PROTECTION_PROJECTILE: org$bukkit$enchantments$Enchantment;
  static OXYGEN: org$bukkit$enchantments$Enchantment;
  static WATER_WORKER: org$bukkit$enchantments$Enchantment;
  static THORNS: org$bukkit$enchantments$Enchantment;
  static DEPTH_STRIDER: org$bukkit$enchantments$Enchantment;
  static FROST_WALKER: org$bukkit$enchantments$Enchantment;
  static BINDING_CURSE: org$bukkit$enchantments$Enchantment;
  static DAMAGE_ALL: org$bukkit$enchantments$Enchantment;
  static DAMAGE_UNDEAD: org$bukkit$enchantments$Enchantment;
  static DAMAGE_ARTHROPODS: org$bukkit$enchantments$Enchantment;
  static KNOCKBACK: org$bukkit$enchantments$Enchantment;
  static FIRE_ASPECT: org$bukkit$enchantments$Enchantment;
  static LOOT_BONUS_MOBS: org$bukkit$enchantments$Enchantment;
  static SWEEPING_EDGE: org$bukkit$enchantments$Enchantment;
  static DIG_SPEED: org$bukkit$enchantments$Enchantment;
  static SILK_TOUCH: org$bukkit$enchantments$Enchantment;
  static DURABILITY: org$bukkit$enchantments$Enchantment;
  static LOOT_BONUS_BLOCKS: org$bukkit$enchantments$Enchantment;
  static ARROW_DAMAGE: org$bukkit$enchantments$Enchantment;
  static ARROW_KNOCKBACK: org$bukkit$enchantments$Enchantment;
  static ARROW_FIRE: org$bukkit$enchantments$Enchantment;
  static ARROW_INFINITE: org$bukkit$enchantments$Enchantment;
  static LUCK: org$bukkit$enchantments$Enchantment;
  static LURE: org$bukkit$enchantments$Enchantment;
  static LOYALTY: org$bukkit$enchantments$Enchantment;
  static IMPALING: org$bukkit$enchantments$Enchantment;
  static RIPTIDE: org$bukkit$enchantments$Enchantment;
  static CHANNELING: org$bukkit$enchantments$Enchantment;
  static MULTISHOT: org$bukkit$enchantments$Enchantment;
  static QUICK_CHARGE: org$bukkit$enchantments$Enchantment;
  static PIERCING: org$bukkit$enchantments$Enchantment;
  static MENDING: org$bukkit$enchantments$Enchantment;
  static VANISHING_CURSE: org$bukkit$enchantments$Enchantment;
  constructor(arg0: org$bukkit$NamespacedKey);
  getKey(): org$bukkit$NamespacedKey;
  getName(): string;
  getMaxLevel(): number;
  getStartLevel(): number;
  getItemTarget(): org$bukkit$enchantments$EnchantmentTarget;
  isTreasure(): boolean;
  isCursed(): boolean;
  conflictsWith(arg0: org$bukkit$enchantments$Enchantment): boolean;
  canEnchantItem(arg0: org$bukkit$inventory$ItemStack): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  static registerEnchantment(arg0: org$bukkit$enchantments$Enchantment): void;
  static isAcceptingRegistrations(): boolean;
  static stopAcceptingRegistrations(): void;
  static getByKey(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$enchantments$Enchantment;
  static getByName(arg0: string): org$bukkit$enchantments$Enchantment;
  static values(): JavaArray<org$bukkit$enchantments$Enchantment>;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget {
  includes(arg0: org$bukkit$Material): boolean;
  includes(arg0: org$bukkit$inventory$ItemStack): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget
  implements $org$bukkit$enchantments$EnchantmentTarget {
  static ALL: org$bukkit$enchantments$EnchantmentTarget;
  static ARMOR: org$bukkit$enchantments$EnchantmentTarget;
  static ARMOR_FEET: org$bukkit$enchantments$EnchantmentTarget;
  static ARMOR_LEGS: org$bukkit$enchantments$EnchantmentTarget;
  static ARMOR_TORSO: org$bukkit$enchantments$EnchantmentTarget;
  static ARMOR_HEAD: org$bukkit$enchantments$EnchantmentTarget;
  static WEAPON: org$bukkit$enchantments$EnchantmentTarget;
  static TOOL: org$bukkit$enchantments$EnchantmentTarget;
  static BOW: org$bukkit$enchantments$EnchantmentTarget;
  static FISHING_ROD: org$bukkit$enchantments$EnchantmentTarget;
  static BREAKABLE: org$bukkit$enchantments$EnchantmentTarget;
  static WEARABLE: org$bukkit$enchantments$EnchantmentTarget;
  static TRIDENT: org$bukkit$enchantments$EnchantmentTarget;
  static CROSSBOW: org$bukkit$enchantments$EnchantmentTarget;
  static values(): JavaArray<org$bukkit$enchantments$EnchantmentTarget>;
  static valueOf(arg0: string): org$bukkit$enchantments$EnchantmentTarget;
  includes(arg0: org$bukkit$Material): boolean;
  includes(arg0: org$bukkit$inventory$ItemStack): boolean;
  constructor(
    arg0: string,
    arg1: number,
    arg2: org$bukkit$enchantments$EnchantmentTarget$1
  );
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$1 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$1
  implements $org$bukkit$enchantments$EnchantmentTarget$1 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$inventory$meta$ItemMeta
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable,
    $org$bukkit$persistence$PersistentDataHolder {
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
}

declare class org$bukkit$inventory$meta$ItemMeta
  implements $org$bukkit$inventory$meta$ItemMeta {
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  serialize(): any /* java.util.Map */;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$persistence$PersistentDataHolder {
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}

declare class org$bukkit$persistence$PersistentDataHolder
  implements $org$bukkit$persistence$PersistentDataHolder {
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$persistence$PersistentDataContainer {
  set(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType,
    arg2: any
  ): void;
  has(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType
  ): boolean;
  get(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType
  ): any;
  getOrDefault(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType,
    arg2: any
  ): any;
  remove(arg0: org$bukkit$NamespacedKey): void;
  isEmpty(): boolean;
  getAdapterContext(): org$bukkit$persistence$PersistentDataAdapterContext;
}

declare class org$bukkit$persistence$PersistentDataContainer
  implements $org$bukkit$persistence$PersistentDataContainer {
  set(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType,
    arg2: any
  ): void;
  has(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType
  ): boolean;
  get(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType
  ): any;
  getOrDefault(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$persistence$PersistentDataType,
    arg2: any
  ): any;
  remove(arg0: org$bukkit$NamespacedKey): void;
  isEmpty(): boolean;
  getAdapterContext(): org$bukkit$persistence$PersistentDataAdapterContext;
}


declare interface $org$bukkit$persistence$PersistentDataType {
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
}

declare class org$bukkit$persistence$PersistentDataType
  implements $org$bukkit$persistence$PersistentDataType {
  static BYTE: org$bukkit$persistence$PersistentDataType;
  static SHORT: org$bukkit$persistence$PersistentDataType;
  static INTEGER: org$bukkit$persistence$PersistentDataType;
  static LONG: org$bukkit$persistence$PersistentDataType;
  static FLOAT: org$bukkit$persistence$PersistentDataType;
  static DOUBLE: org$bukkit$persistence$PersistentDataType;
  static STRING: org$bukkit$persistence$PersistentDataType;
  static BYTE_ARRAY: org$bukkit$persistence$PersistentDataType;
  static INTEGER_ARRAY: org$bukkit$persistence$PersistentDataType;
  static LONG_ARRAY: org$bukkit$persistence$PersistentDataType;
  static TAG_CONTAINER: org$bukkit$persistence$PersistentDataType;
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
}


declare interface $org$bukkit$persistence$PersistentDataAdapterContext {
  newPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}

declare class org$bukkit$persistence$PersistentDataAdapterContext
  implements $org$bukkit$persistence$PersistentDataAdapterContext {
  newPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$ItemFlag {}

declare class org$bukkit$inventory$ItemFlag
  implements $org$bukkit$inventory$ItemFlag {
  static HIDE_ENCHANTS: org$bukkit$inventory$ItemFlag;
  static HIDE_ATTRIBUTES: org$bukkit$inventory$ItemFlag;
  static HIDE_UNBREAKABLE: org$bukkit$inventory$ItemFlag;
  static HIDE_DESTROYS: org$bukkit$inventory$ItemFlag;
  static HIDE_PLACED_ON: org$bukkit$inventory$ItemFlag;
  static HIDE_POTION_EFFECTS: org$bukkit$inventory$ItemFlag;
  static values(): JavaArray<org$bukkit$inventory$ItemFlag>;
  static valueOf(arg0: string): org$bukkit$inventory$ItemFlag;
}


declare interface $com$google$common$collect$Multimap {
  size(): number;
  isEmpty(): boolean;
  containsKey(arg0: any): boolean;
  containsValue(arg0: any): boolean;
  containsEntry(arg0: any, arg1: any): boolean;
  put(arg0: any, arg1: any): boolean;
  remove(arg0: any, arg1: any): boolean;
  putAll(arg0: any, arg1: any /* java.lang.Iterable */): boolean;
  putAll(arg0: com$google$common$collect$Multimap): boolean;
  replaceValues(
    arg0: any,
    arg1: any /* java.lang.Iterable */
  ): java$util$Collection;
  removeAll(arg0: any): java$util$Collection;
  clear(): void;
  get(arg0: any): java$util$Collection;
  keySet(): any /* java.util.Set */;
  keys(): com$google$common$collect$Multiset;
  values(): java$util$Collection;
  entries(): java$util$Collection;
  asMap(): any /* java.util.Map */;
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class com$google$common$collect$Multimap
  implements $com$google$common$collect$Multimap {
  size(): number;
  isEmpty(): boolean;
  containsKey(arg0: any): boolean;
  containsValue(arg0: any): boolean;
  containsEntry(arg0: any, arg1: any): boolean;
  put(arg0: any, arg1: any): boolean;
  remove(arg0: any, arg1: any): boolean;
  putAll(arg0: any, arg1: any /* java.lang.Iterable */): boolean;
  putAll(arg0: com$google$common$collect$Multimap): boolean;
  replaceValues(
    arg0: any,
    arg1: any /* java.lang.Iterable */
  ): java$util$Collection;
  removeAll(arg0: any): java$util$Collection;
  clear(): void;
  get(arg0: any): java$util$Collection;
  keySet(): any /* java.util.Set */;
  keys(): com$google$common$collect$Multiset;
  values(): java$util$Collection;
  entries(): java$util$Collection;
  asMap(): any /* java.util.Map */;
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $com$google$common$collect$Multiset
  extends $java$util$Collection {
  count(arg0: any): number;
  add(arg0: any, arg1: number): number;
  remove(arg0: any, arg1: number): number;
  setCount(arg0: any, arg1: number): number;
  setCount(arg0: any, arg1: number, arg2: number): boolean;
  elementSet(): any /* java.util.Set */;
  entrySet(): any /* java.util.Set */;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  iterator(): any /* java.util.Iterator */;
  contains(arg0: any): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  retainAll(arg0: java$util$Collection): boolean;
}

declare class com$google$common$collect$Multiset
  implements $com$google$common$collect$Multiset {
  count(arg0: any): number;
  add(arg0: any, arg1: number): number;
  remove(arg0: any, arg1: number): number;
  setCount(arg0: any, arg1: number): number;
  setCount(arg0: any, arg1: number, arg2: number): boolean;
  elementSet(): any /* java.util.Set */;
  entrySet(): any /* java.util.Set */;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  iterator(): any /* java.util.Iterator */;
  contains(arg0: any): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  size(): number;
  isEmpty(): boolean;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  addAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  clear(): void;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}


declare interface $org$bukkit$inventory$EquipmentSlot {}

declare class org$bukkit$inventory$EquipmentSlot
  implements $org$bukkit$inventory$EquipmentSlot {
  static HAND: org$bukkit$inventory$EquipmentSlot;
  static OFF_HAND: org$bukkit$inventory$EquipmentSlot;
  static FEET: org$bukkit$inventory$EquipmentSlot;
  static LEGS: org$bukkit$inventory$EquipmentSlot;
  static CHEST: org$bukkit$inventory$EquipmentSlot;
  static HEAD: org$bukkit$inventory$EquipmentSlot;
  static values(): JavaArray<org$bukkit$inventory$EquipmentSlot>;
  static valueOf(arg0: string): org$bukkit$inventory$EquipmentSlot;
}


declare interface $org$bukkit$attribute$Attribute {}

declare class org$bukkit$attribute$Attribute
  implements $org$bukkit$attribute$Attribute {
  static GENERIC_MAX_HEALTH: org$bukkit$attribute$Attribute;
  static GENERIC_FOLLOW_RANGE: org$bukkit$attribute$Attribute;
  static GENERIC_KNOCKBACK_RESISTANCE: org$bukkit$attribute$Attribute;
  static GENERIC_MOVEMENT_SPEED: org$bukkit$attribute$Attribute;
  static GENERIC_FLYING_SPEED: org$bukkit$attribute$Attribute;
  static GENERIC_ATTACK_DAMAGE: org$bukkit$attribute$Attribute;
  static GENERIC_ATTACK_SPEED: org$bukkit$attribute$Attribute;
  static GENERIC_ARMOR: org$bukkit$attribute$Attribute;
  static GENERIC_ARMOR_TOUGHNESS: org$bukkit$attribute$Attribute;
  static GENERIC_LUCK: org$bukkit$attribute$Attribute;
  static HORSE_JUMP_STRENGTH: org$bukkit$attribute$Attribute;
  static ZOMBIE_SPAWN_REINFORCEMENTS: org$bukkit$attribute$Attribute;
  static values(): JavaArray<org$bukkit$attribute$Attribute>;
  static valueOf(arg0: string): org$bukkit$attribute$Attribute;
}


declare interface $org$bukkit$attribute$AttributeModifier
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  getUniqueId(): any /* java.util.UUID */;
  getName(): string;
  getAmount(): number;
  getOperation(): org$bukkit$attribute$AttributeModifier$Operation;
  getSlot(): org$bukkit$inventory$EquipmentSlot;
  serialize(): any /* java.util.Map */;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}

declare class org$bukkit$attribute$AttributeModifier
  implements $org$bukkit$attribute$AttributeModifier {
  constructor(
    arg0: string,
    arg1: number,
    arg2: org$bukkit$attribute$AttributeModifier$Operation
  );
  constructor(
    arg0: any /* java.util.UUID */,
    arg1: string,
    arg2: number,
    arg3: org$bukkit$attribute$AttributeModifier$Operation
  );
  constructor(
    arg0: any /* java.util.UUID */,
    arg1: string,
    arg2: number,
    arg3: org$bukkit$attribute$AttributeModifier$Operation,
    arg4: org$bukkit$inventory$EquipmentSlot
  );
  getUniqueId(): any /* java.util.UUID */;
  getName(): string;
  getAmount(): number;
  getOperation(): org$bukkit$attribute$AttributeModifier$Operation;
  getSlot(): org$bukkit$inventory$EquipmentSlot;
  serialize(): any /* java.util.Map */;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  static deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$attribute$AttributeModifier;
}


declare interface $org$bukkit$attribute$AttributeModifier$Operation {}

declare class org$bukkit$attribute$AttributeModifier$Operation
  implements $org$bukkit$attribute$AttributeModifier$Operation {
  static ADD_NUMBER: org$bukkit$attribute$AttributeModifier$Operation;
  static ADD_SCALAR: org$bukkit$attribute$AttributeModifier$Operation;
  static MULTIPLY_SCALAR_1: org$bukkit$attribute$AttributeModifier$Operation;
  static values(): JavaArray<org$bukkit$attribute$AttributeModifier$Operation>;
  static valueOf(
    arg0: string
  ): org$bukkit$attribute$AttributeModifier$Operation;
}


declare interface $org$bukkit$inventory$meta$tags$CustomItemTagContainer {
  setCustomTag(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$meta$tags$ItemTagType,
    arg2: any
  ): void;
  hasCustomTag(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$meta$tags$ItemTagType
  ): boolean;
  getCustomTag(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$meta$tags$ItemTagType
  ): any;
  removeCustomTag(arg0: org$bukkit$NamespacedKey): void;
  isEmpty(): boolean;
  getAdapterContext(): org$bukkit$inventory$meta$tags$ItemTagAdapterContext;
}

declare class org$bukkit$inventory$meta$tags$CustomItemTagContainer
  implements $org$bukkit$inventory$meta$tags$CustomItemTagContainer {
  setCustomTag(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$meta$tags$ItemTagType,
    arg2: any
  ): void;
  hasCustomTag(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$meta$tags$ItemTagType
  ): boolean;
  getCustomTag(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$meta$tags$ItemTagType
  ): any;
  removeCustomTag(arg0: org$bukkit$NamespacedKey): void;
  isEmpty(): boolean;
  getAdapterContext(): org$bukkit$inventory$meta$tags$ItemTagAdapterContext;
}


declare interface $org$bukkit$inventory$meta$tags$ItemTagType {
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
}

declare class org$bukkit$inventory$meta$tags$ItemTagType
  implements $org$bukkit$inventory$meta$tags$ItemTagType {
  static BYTE: org$bukkit$inventory$meta$tags$ItemTagType;
  static SHORT: org$bukkit$inventory$meta$tags$ItemTagType;
  static INTEGER: org$bukkit$inventory$meta$tags$ItemTagType;
  static LONG: org$bukkit$inventory$meta$tags$ItemTagType;
  static FLOAT: org$bukkit$inventory$meta$tags$ItemTagType;
  static DOUBLE: org$bukkit$inventory$meta$tags$ItemTagType;
  static STRING: org$bukkit$inventory$meta$tags$ItemTagType;
  static BYTE_ARRAY: org$bukkit$inventory$meta$tags$ItemTagType;
  static INTEGER_ARRAY: org$bukkit$inventory$meta$tags$ItemTagType;
  static LONG_ARRAY: org$bukkit$inventory$meta$tags$ItemTagType;
  static TAG_CONTAINER: org$bukkit$inventory$meta$tags$ItemTagType;
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
}


declare interface $org$bukkit$inventory$meta$tags$ItemTagAdapterContext {
  newTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
}

declare class org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  implements $org$bukkit$inventory$meta$tags$ItemTagAdapterContext {
  newTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
}


declare interface $org$bukkit$block$BlockFace {
  getModX(): number;
  getModY(): number;
  getModZ(): number;
  getDirection(): org$bukkit$util$Vector;
  getOppositeFace(): org$bukkit$block$BlockFace;
}

declare class org$bukkit$block$BlockFace
  implements $org$bukkit$block$BlockFace {
  static NORTH: org$bukkit$block$BlockFace;
  static EAST: org$bukkit$block$BlockFace;
  static SOUTH: org$bukkit$block$BlockFace;
  static WEST: org$bukkit$block$BlockFace;
  static UP: org$bukkit$block$BlockFace;
  static DOWN: org$bukkit$block$BlockFace;
  static NORTH_EAST: org$bukkit$block$BlockFace;
  static NORTH_WEST: org$bukkit$block$BlockFace;
  static SOUTH_EAST: org$bukkit$block$BlockFace;
  static SOUTH_WEST: org$bukkit$block$BlockFace;
  static WEST_NORTH_WEST: org$bukkit$block$BlockFace;
  static NORTH_NORTH_WEST: org$bukkit$block$BlockFace;
  static NORTH_NORTH_EAST: org$bukkit$block$BlockFace;
  static EAST_NORTH_EAST: org$bukkit$block$BlockFace;
  static EAST_SOUTH_EAST: org$bukkit$block$BlockFace;
  static SOUTH_SOUTH_EAST: org$bukkit$block$BlockFace;
  static SOUTH_SOUTH_WEST: org$bukkit$block$BlockFace;
  static WEST_SOUTH_WEST: org$bukkit$block$BlockFace;
  static SELF: org$bukkit$block$BlockFace;
  static values(): JavaArray<org$bukkit$block$BlockFace>;
  static valueOf(arg0: string): org$bukkit$block$BlockFace;
  getModX(): number;
  getModY(): number;
  getModZ(): number;
  getDirection(): org$bukkit$util$Vector;
  getOppositeFace(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$util$Vector
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  add(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  subtract(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  multiply(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  divide(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  copy(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  length(): number;
  lengthSquared(): number;
  distance(arg0: org$bukkit$util$Vector): number;
  distanceSquared(arg0: org$bukkit$util$Vector): number;
  angle(arg0: org$bukkit$util$Vector): number;
  midpoint(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  getMidpoint(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  multiply(arg0: number): org$bukkit$util$Vector;
  multiply(arg0: number): org$bukkit$util$Vector;
  multiply(arg0: number): org$bukkit$util$Vector;
  dot(arg0: org$bukkit$util$Vector): number;
  crossProduct(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  getCrossProduct(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  normalize(): org$bukkit$util$Vector;
  zero(): org$bukkit$util$Vector;
  isInAABB(arg0: org$bukkit$util$Vector, arg1: org$bukkit$util$Vector): boolean;
  isInSphere(arg0: org$bukkit$util$Vector, arg1: number): boolean;
  isNormalized(): boolean;
  rotateAroundX(arg0: number): org$bukkit$util$Vector;
  rotateAroundY(arg0: number): org$bukkit$util$Vector;
  rotateAroundZ(arg0: number): org$bukkit$util$Vector;
  rotateAroundAxis(
    arg0: org$bukkit$util$Vector,
    arg1: number
  ): org$bukkit$util$Vector;
  rotateAroundNonUnitAxis(
    arg0: org$bukkit$util$Vector,
    arg1: number
  ): org$bukkit$util$Vector;
  getX(): number;
  getBlockX(): number;
  getY(): number;
  getBlockY(): number;
  getZ(): number;
  getBlockZ(): number;
  setX(arg0: number): org$bukkit$util$Vector;
  setX(arg0: number): org$bukkit$util$Vector;
  setX(arg0: number): org$bukkit$util$Vector;
  setY(arg0: number): org$bukkit$util$Vector;
  setY(arg0: number): org$bukkit$util$Vector;
  setY(arg0: number): org$bukkit$util$Vector;
  setZ(arg0: number): org$bukkit$util$Vector;
  setZ(arg0: number): org$bukkit$util$Vector;
  setZ(arg0: number): org$bukkit$util$Vector;
  equals(arg0: any): boolean;
  hashCode(): number;
  clone(): org$bukkit$util$Vector;
  toString(): string;
  toLocation(arg0: org$bukkit$World): org$bukkit$Location;
  toLocation(
    arg0: org$bukkit$World,
    arg1: number,
    arg2: number
  ): org$bukkit$Location;
  toBlockVector(): org$bukkit$util$BlockVector;
  checkFinite(): void;
  serialize(): any /* java.util.Map */;
  clone(): any;
}

declare class org$bukkit$util$Vector implements $org$bukkit$util$Vector {
  constructor();
  constructor(arg0: number, arg1: number, arg2: number);
  add(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  subtract(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  multiply(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  divide(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  copy(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  length(): number;
  lengthSquared(): number;
  distance(arg0: org$bukkit$util$Vector): number;
  distanceSquared(arg0: org$bukkit$util$Vector): number;
  angle(arg0: org$bukkit$util$Vector): number;
  midpoint(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  getMidpoint(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  multiply(arg0: number): org$bukkit$util$Vector;
  dot(arg0: org$bukkit$util$Vector): number;
  crossProduct(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  getCrossProduct(arg0: org$bukkit$util$Vector): org$bukkit$util$Vector;
  normalize(): org$bukkit$util$Vector;
  zero(): org$bukkit$util$Vector;
  isInAABB(arg0: org$bukkit$util$Vector, arg1: org$bukkit$util$Vector): boolean;
  isInSphere(arg0: org$bukkit$util$Vector, arg1: number): boolean;
  isNormalized(): boolean;
  rotateAroundX(arg0: number): org$bukkit$util$Vector;
  rotateAroundY(arg0: number): org$bukkit$util$Vector;
  rotateAroundZ(arg0: number): org$bukkit$util$Vector;
  rotateAroundAxis(
    arg0: org$bukkit$util$Vector,
    arg1: number
  ): org$bukkit$util$Vector;
  rotateAroundNonUnitAxis(
    arg0: org$bukkit$util$Vector,
    arg1: number
  ): org$bukkit$util$Vector;
  getX(): number;
  getBlockX(): number;
  getY(): number;
  getBlockY(): number;
  getZ(): number;
  getBlockZ(): number;
  setX(arg0: number): org$bukkit$util$Vector;
  setY(arg0: number): org$bukkit$util$Vector;
  setZ(arg0: number): org$bukkit$util$Vector;
  equals(arg0: any): boolean;
  hashCode(): number;
  clone(): org$bukkit$util$Vector;
  toString(): string;
  toLocation(arg0: org$bukkit$World): org$bukkit$Location;
  toLocation(
    arg0: org$bukkit$World,
    arg1: number,
    arg2: number
  ): org$bukkit$Location;
  toBlockVector(): org$bukkit$util$BlockVector;
  checkFinite(): void;
  static getEpsilon(): number;
  static getMinimum(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$util$Vector;
  static getMaximum(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$util$Vector;
  static getRandom(): org$bukkit$util$Vector;
  serialize(): any /* java.util.Map */;
  static deserialize(arg0: any /* java.util.Map */): org$bukkit$util$Vector;
  clone(): any;
}


declare interface $org$bukkit$util$BlockVector {
  equals(arg0: any): boolean;
  hashCode(): number;
  clone(): org$bukkit$util$BlockVector;
  clone(): org$bukkit$util$Vector;
  clone(): any;
}

declare class org$bukkit$util$BlockVector
  implements $org$bukkit$util$BlockVector {
  constructor();
  constructor(arg0: org$bukkit$util$Vector);
  constructor(arg0: number, arg1: number, arg2: number);
  equals(arg0: any): boolean;
  hashCode(): number;
  clone(): org$bukkit$util$BlockVector;
  static deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$util$BlockVector;
  clone(): org$bukkit$util$Vector;
  clone(): any;
  serialize(): any /* java.util.Map */;
}


declare interface $org$bukkit$Chunk {
  getX(): number;
  getZ(): number;
  getChunkKey(): number;
  getWorld(): org$bukkit$World;
  getBlock(arg0: number, arg1: number, arg2: number): org$bukkit$block$Block;
  getChunkSnapshot(): org$bukkit$ChunkSnapshot;
  getChunkSnapshot(
    arg0: boolean,
    arg1: boolean,
    arg2: boolean
  ): org$bukkit$ChunkSnapshot;
  getEntities(): JavaArray<org$bukkit$entity$Entity>;
  getTileEntities(): JavaArray<org$bukkit$block$BlockState>;
  getTileEntities(arg0: boolean): JavaArray<org$bukkit$block$BlockState>;
  isLoaded(): boolean;
  load(arg0: boolean): boolean;
  load(): boolean;
  unload(arg0: boolean): boolean;
  unload(): boolean;
  isSlimeChunk(): boolean;
  isForceLoaded(): boolean;
  setForceLoaded(arg0: boolean): void;
  addPluginChunkTicket(arg0: org$bukkit$plugin$Plugin): boolean;
  removePluginChunkTicket(arg0: org$bukkit$plugin$Plugin): boolean;
  getPluginChunkTickets(): java$util$Collection;
  getInhabitedTime(): number;
  setInhabitedTime(arg0: number): void;
  contains(arg0: org$bukkit$block$data$BlockData): boolean;
}

declare class org$bukkit$Chunk implements $org$bukkit$Chunk {
  getX(): number;
  getZ(): number;
  getChunkKey(): number;
  static getChunkKey(arg0: org$bukkit$Location): number;
  static getChunkKey(arg0: number, arg1: number): number;
  getWorld(): org$bukkit$World;
  getBlock(arg0: number, arg1: number, arg2: number): org$bukkit$block$Block;
  getChunkSnapshot(): org$bukkit$ChunkSnapshot;
  getChunkSnapshot(
    arg0: boolean,
    arg1: boolean,
    arg2: boolean
  ): org$bukkit$ChunkSnapshot;
  getEntities(): JavaArray<org$bukkit$entity$Entity>;
  getTileEntities(): JavaArray<org$bukkit$block$BlockState>;
  getTileEntities(arg0: boolean): JavaArray<org$bukkit$block$BlockState>;
  isLoaded(): boolean;
  load(arg0: boolean): boolean;
  load(): boolean;
  unload(arg0: boolean): boolean;
  unload(): boolean;
  isSlimeChunk(): boolean;
  isForceLoaded(): boolean;
  setForceLoaded(arg0: boolean): void;
  addPluginChunkTicket(arg0: org$bukkit$plugin$Plugin): boolean;
  removePluginChunkTicket(arg0: org$bukkit$plugin$Plugin): boolean;
  getPluginChunkTickets(): java$util$Collection;
  getInhabitedTime(): number;
  setInhabitedTime(arg0: number): void;
  contains(arg0: org$bukkit$block$data$BlockData): boolean;
}


declare interface $org$bukkit$ChunkSnapshot {
  getX(): number;
  getZ(): number;
  getWorldName(): string;
  getBlockType(arg0: number, arg1: number, arg2: number): org$bukkit$Material;
  getBlockData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$block$data$BlockData;
  getData(arg0: number, arg1: number, arg2: number): number;
  getBlockSkyLight(arg0: number, arg1: number, arg2: number): number;
  getBlockEmittedLight(arg0: number, arg1: number, arg2: number): number;
  getHighestBlockYAt(arg0: number, arg1: number): number;
  getBiome(arg0: number, arg1: number): org$bukkit$block$Biome;
  getBiome(arg0: number, arg1: number, arg2: number): org$bukkit$block$Biome;
  getRawBiomeTemperature(arg0: number, arg1: number): number;
  getRawBiomeTemperature(arg0: number, arg1: number, arg2: number): number;
  getCaptureFullTime(): number;
  isSectionEmpty(arg0: number): boolean;
  contains(arg0: org$bukkit$block$data$BlockData): boolean;
}

declare class org$bukkit$ChunkSnapshot implements $org$bukkit$ChunkSnapshot {
  getX(): number;
  getZ(): number;
  getWorldName(): string;
  getBlockType(arg0: number, arg1: number, arg2: number): org$bukkit$Material;
  getBlockData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$block$data$BlockData;
  getData(arg0: number, arg1: number, arg2: number): number;
  getBlockSkyLight(arg0: number, arg1: number, arg2: number): number;
  getBlockEmittedLight(arg0: number, arg1: number, arg2: number): number;
  getHighestBlockYAt(arg0: number, arg1: number): number;
  getBiome(arg0: number, arg1: number): org$bukkit$block$Biome;
  getBiome(arg0: number, arg1: number, arg2: number): org$bukkit$block$Biome;
  getRawBiomeTemperature(arg0: number, arg1: number): number;
  getRawBiomeTemperature(arg0: number, arg1: number, arg2: number): number;
  getCaptureFullTime(): number;
  isSectionEmpty(arg0: number): boolean;
  contains(arg0: org$bukkit$block$data$BlockData): boolean;
}


declare interface $org$bukkit$block$Biome extends $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
}

declare class org$bukkit$block$Biome implements $org$bukkit$block$Biome {
  static OCEAN: org$bukkit$block$Biome;
  static PLAINS: org$bukkit$block$Biome;
  static DESERT: org$bukkit$block$Biome;
  static MOUNTAINS: org$bukkit$block$Biome;
  static FOREST: org$bukkit$block$Biome;
  static TAIGA: org$bukkit$block$Biome;
  static SWAMP: org$bukkit$block$Biome;
  static RIVER: org$bukkit$block$Biome;
  static NETHER: org$bukkit$block$Biome;
  static THE_END: org$bukkit$block$Biome;
  static FROZEN_OCEAN: org$bukkit$block$Biome;
  static FROZEN_RIVER: org$bukkit$block$Biome;
  static SNOWY_TUNDRA: org$bukkit$block$Biome;
  static SNOWY_MOUNTAINS: org$bukkit$block$Biome;
  static MUSHROOM_FIELDS: org$bukkit$block$Biome;
  static MUSHROOM_FIELD_SHORE: org$bukkit$block$Biome;
  static BEACH: org$bukkit$block$Biome;
  static DESERT_HILLS: org$bukkit$block$Biome;
  static WOODED_HILLS: org$bukkit$block$Biome;
  static TAIGA_HILLS: org$bukkit$block$Biome;
  static MOUNTAIN_EDGE: org$bukkit$block$Biome;
  static JUNGLE: org$bukkit$block$Biome;
  static JUNGLE_HILLS: org$bukkit$block$Biome;
  static JUNGLE_EDGE: org$bukkit$block$Biome;
  static DEEP_OCEAN: org$bukkit$block$Biome;
  static STONE_SHORE: org$bukkit$block$Biome;
  static SNOWY_BEACH: org$bukkit$block$Biome;
  static BIRCH_FOREST: org$bukkit$block$Biome;
  static BIRCH_FOREST_HILLS: org$bukkit$block$Biome;
  static DARK_FOREST: org$bukkit$block$Biome;
  static SNOWY_TAIGA: org$bukkit$block$Biome;
  static SNOWY_TAIGA_HILLS: org$bukkit$block$Biome;
  static GIANT_TREE_TAIGA: org$bukkit$block$Biome;
  static GIANT_TREE_TAIGA_HILLS: org$bukkit$block$Biome;
  static WOODED_MOUNTAINS: org$bukkit$block$Biome;
  static SAVANNA: org$bukkit$block$Biome;
  static SAVANNA_PLATEAU: org$bukkit$block$Biome;
  static BADLANDS: org$bukkit$block$Biome;
  static WOODED_BADLANDS_PLATEAU: org$bukkit$block$Biome;
  static BADLANDS_PLATEAU: org$bukkit$block$Biome;
  static SMALL_END_ISLANDS: org$bukkit$block$Biome;
  static END_MIDLANDS: org$bukkit$block$Biome;
  static END_HIGHLANDS: org$bukkit$block$Biome;
  static END_BARRENS: org$bukkit$block$Biome;
  static WARM_OCEAN: org$bukkit$block$Biome;
  static LUKEWARM_OCEAN: org$bukkit$block$Biome;
  static COLD_OCEAN: org$bukkit$block$Biome;
  static DEEP_WARM_OCEAN: org$bukkit$block$Biome;
  static DEEP_LUKEWARM_OCEAN: org$bukkit$block$Biome;
  static DEEP_COLD_OCEAN: org$bukkit$block$Biome;
  static DEEP_FROZEN_OCEAN: org$bukkit$block$Biome;
  static THE_VOID: org$bukkit$block$Biome;
  static SUNFLOWER_PLAINS: org$bukkit$block$Biome;
  static DESERT_LAKES: org$bukkit$block$Biome;
  static GRAVELLY_MOUNTAINS: org$bukkit$block$Biome;
  static FLOWER_FOREST: org$bukkit$block$Biome;
  static TAIGA_MOUNTAINS: org$bukkit$block$Biome;
  static SWAMP_HILLS: org$bukkit$block$Biome;
  static ICE_SPIKES: org$bukkit$block$Biome;
  static MODIFIED_JUNGLE: org$bukkit$block$Biome;
  static MODIFIED_JUNGLE_EDGE: org$bukkit$block$Biome;
  static TALL_BIRCH_FOREST: org$bukkit$block$Biome;
  static TALL_BIRCH_HILLS: org$bukkit$block$Biome;
  static DARK_FOREST_HILLS: org$bukkit$block$Biome;
  static SNOWY_TAIGA_MOUNTAINS: org$bukkit$block$Biome;
  static GIANT_SPRUCE_TAIGA: org$bukkit$block$Biome;
  static GIANT_SPRUCE_TAIGA_HILLS: org$bukkit$block$Biome;
  static MODIFIED_GRAVELLY_MOUNTAINS: org$bukkit$block$Biome;
  static SHATTERED_SAVANNA: org$bukkit$block$Biome;
  static SHATTERED_SAVANNA_PLATEAU: org$bukkit$block$Biome;
  static ERODED_BADLANDS: org$bukkit$block$Biome;
  static MODIFIED_WOODED_BADLANDS_PLATEAU: org$bukkit$block$Biome;
  static MODIFIED_BADLANDS_PLATEAU: org$bukkit$block$Biome;
  static BAMBOO_JUNGLE: org$bukkit$block$Biome;
  static BAMBOO_JUNGLE_HILLS: org$bukkit$block$Biome;
  static values(): JavaArray<org$bukkit$block$Biome>;
  static valueOf(arg0: string): org$bukkit$block$Biome;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$entity$Entity
  extends $org$bukkit$metadata$Metadatable,
    $org$bukkit$command$CommandSender,
    $org$bukkit$Nameable,
    $org$bukkit$persistence$PersistentDataHolder {
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  getServer(): org$bukkit$Server;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  spigot(): org$bukkit$command$CommandSender$Spigot;
}

declare class org$bukkit$entity$Entity implements $org$bukkit$entity$Entity {
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  getServer(): org$bukkit$Server;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getName(): string;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$util$BoundingBox
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  resize(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): org$bukkit$util$BoundingBox;
  getMinX(): number;
  getMinY(): number;
  getMinZ(): number;
  getMin(): org$bukkit$util$Vector;
  getMaxX(): number;
  getMaxY(): number;
  getMaxZ(): number;
  getMax(): org$bukkit$util$Vector;
  getWidthX(): number;
  getWidthZ(): number;
  getHeight(): number;
  getVolume(): number;
  getCenterX(): number;
  getCenterY(): number;
  getCenterZ(): number;
  getCenter(): org$bukkit$util$Vector;
  copy(arg0: org$bukkit$util$BoundingBox): org$bukkit$util$BoundingBox;
  expand(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): org$bukkit$util$BoundingBox;
  expand(arg0: number, arg1: number, arg2: number): org$bukkit$util$BoundingBox;
  expand(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  expand(arg0: number): org$bukkit$util$BoundingBox;
  expand(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$util$BoundingBox;
  expand(
    arg0: org$bukkit$util$Vector,
    arg1: number
  ): org$bukkit$util$BoundingBox;
  expand(
    arg0: org$bukkit$block$BlockFace,
    arg1: number
  ): org$bukkit$util$BoundingBox;
  expandDirectional(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$util$BoundingBox;
  expandDirectional(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  union(arg0: number, arg1: number, arg2: number): org$bukkit$util$BoundingBox;
  union(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  union(arg0: org$bukkit$Location): org$bukkit$util$BoundingBox;
  union(arg0: org$bukkit$util$BoundingBox): org$bukkit$util$BoundingBox;
  intersection(arg0: org$bukkit$util$BoundingBox): org$bukkit$util$BoundingBox;
  shift(arg0: number, arg1: number, arg2: number): org$bukkit$util$BoundingBox;
  shift(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  shift(arg0: org$bukkit$Location): org$bukkit$util$BoundingBox;
  overlaps(arg0: org$bukkit$util$BoundingBox): boolean;
  overlaps(arg0: org$bukkit$util$Vector, arg1: org$bukkit$util$Vector): boolean;
  contains(arg0: number, arg1: number, arg2: number): boolean;
  contains(arg0: org$bukkit$util$Vector): boolean;
  contains(arg0: org$bukkit$util$BoundingBox): boolean;
  contains(arg0: org$bukkit$util$Vector, arg1: org$bukkit$util$Vector): boolean;
  rayTrace(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$util$Vector,
    arg2: number
  ): org$bukkit$util$RayTraceResult;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  clone(): org$bukkit$util$BoundingBox;
  serialize(): any /* java.util.Map */;
  clone(): any;
}

declare class org$bukkit$util$BoundingBox
  implements $org$bukkit$util$BoundingBox {
  static of(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$util$BoundingBox;
  static of(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$Location
  ): org$bukkit$util$BoundingBox;
  static of(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$Block
  ): org$bukkit$util$BoundingBox;
  static of(arg0: org$bukkit$block$Block): org$bukkit$util$BoundingBox;
  static of(
    arg0: org$bukkit$util$Vector,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$util$BoundingBox;
  static of(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$util$BoundingBox;
  constructor();
  constructor(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  );
  resize(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): org$bukkit$util$BoundingBox;
  getMinX(): number;
  getMinY(): number;
  getMinZ(): number;
  getMin(): org$bukkit$util$Vector;
  getMaxX(): number;
  getMaxY(): number;
  getMaxZ(): number;
  getMax(): org$bukkit$util$Vector;
  getWidthX(): number;
  getWidthZ(): number;
  getHeight(): number;
  getVolume(): number;
  getCenterX(): number;
  getCenterY(): number;
  getCenterZ(): number;
  getCenter(): org$bukkit$util$Vector;
  copy(arg0: org$bukkit$util$BoundingBox): org$bukkit$util$BoundingBox;
  expand(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): org$bukkit$util$BoundingBox;
  expand(arg0: number, arg1: number, arg2: number): org$bukkit$util$BoundingBox;
  expand(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  expand(arg0: number): org$bukkit$util$BoundingBox;
  expand(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$util$BoundingBox;
  expand(
    arg0: org$bukkit$util$Vector,
    arg1: number
  ): org$bukkit$util$BoundingBox;
  expand(
    arg0: org$bukkit$block$BlockFace,
    arg1: number
  ): org$bukkit$util$BoundingBox;
  expandDirectional(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$util$BoundingBox;
  expandDirectional(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  union(arg0: number, arg1: number, arg2: number): org$bukkit$util$BoundingBox;
  union(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  union(arg0: org$bukkit$Location): org$bukkit$util$BoundingBox;
  union(arg0: org$bukkit$util$BoundingBox): org$bukkit$util$BoundingBox;
  intersection(arg0: org$bukkit$util$BoundingBox): org$bukkit$util$BoundingBox;
  shift(arg0: number, arg1: number, arg2: number): org$bukkit$util$BoundingBox;
  shift(arg0: org$bukkit$util$Vector): org$bukkit$util$BoundingBox;
  shift(arg0: org$bukkit$Location): org$bukkit$util$BoundingBox;
  overlaps(arg0: org$bukkit$util$BoundingBox): boolean;
  overlaps(arg0: org$bukkit$util$Vector, arg1: org$bukkit$util$Vector): boolean;
  contains(arg0: number, arg1: number, arg2: number): boolean;
  contains(arg0: org$bukkit$util$Vector): boolean;
  contains(arg0: org$bukkit$util$BoundingBox): boolean;
  contains(arg0: org$bukkit$util$Vector, arg1: org$bukkit$util$Vector): boolean;
  rayTrace(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$util$Vector,
    arg2: number
  ): org$bukkit$util$RayTraceResult;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  clone(): org$bukkit$util$BoundingBox;
  serialize(): any /* java.util.Map */;
  static deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$util$BoundingBox;
  clone(): any;
}


declare interface $org$bukkit$util$RayTraceResult {
  getHitPosition(): org$bukkit$util$Vector;
  getHitBlock(): org$bukkit$block$Block;
  getHitBlockFace(): org$bukkit$block$BlockFace;
  getHitEntity(): org$bukkit$entity$Entity;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
}

declare class org$bukkit$util$RayTraceResult
  implements $org$bukkit$util$RayTraceResult {
  constructor(arg0: org$bukkit$util$Vector);
  constructor(arg0: org$bukkit$util$Vector, arg1: org$bukkit$block$BlockFace);
  constructor(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace
  );
  constructor(arg0: org$bukkit$util$Vector, arg1: org$bukkit$entity$Entity);
  constructor(
    arg0: org$bukkit$util$Vector,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$block$BlockFace
  );
  getHitPosition(): org$bukkit$util$Vector;
  getHitBlock(): org$bukkit$block$Block;
  getHitBlockFace(): org$bukkit$block$BlockFace;
  getHitEntity(): org$bukkit$entity$Entity;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
}


declare interface $org$bukkit$event$player$PlayerTeleportEvent$TeleportCause {}

declare class org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  implements $org$bukkit$event$player$PlayerTeleportEvent$TeleportCause {
  static ENDER_PEARL: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static COMMAND: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static PLUGIN: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static NETHER_PORTAL: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static END_PORTAL: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static SPECTATE: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static END_GATEWAY: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static CHORUS_FRUIT: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static UNKNOWN: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  static values(): JavaArray<
    org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
}


declare interface $org$bukkit$event$entity$EntityDamageEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getOriginalDamage(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  ): number;
  setDamage(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier,
    arg1: number
  ): void;
  getDamage(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  ): number;
  isApplicable(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  ): boolean;
  getDamage(): number;
  getFinalDamage(): number;
  setDamage(arg0: number): void;
  getCause(): org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityDamageEvent
  implements $org$bukkit$event$entity$EntityDamageEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$entity$EntityDamageEvent$DamageCause,
    arg2: number
  );
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$entity$EntityDamageEvent$DamageCause,
    arg2: any /* java.util.Map */,
    arg3: any /* java.util.Map */
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getOriginalDamage(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  ): number;
  setDamage(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier,
    arg1: number
  ): void;
  getDamage(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  ): number;
  isApplicable(
    arg0: org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  ): boolean;
  getDamage(): number;
  getFinalDamage(): number;
  setDamage(arg0: number): void;
  getCause(): org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$Cancellable
  implements $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityDamageEvent$DamageCause {}

declare class org$bukkit$event$entity$EntityDamageEvent$DamageCause
  implements $org$bukkit$event$entity$EntityDamageEvent$DamageCause {
  static CONTACT: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static ENTITY_ATTACK: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static ENTITY_SWEEP_ATTACK: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static PROJECTILE: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static SUFFOCATION: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static FALL: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static FIRE: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static FIRE_TICK: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static MELTING: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static LAVA: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static DROWNING: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static BLOCK_EXPLOSION: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static ENTITY_EXPLOSION: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static VOID: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static LIGHTNING: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static SUICIDE: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static STARVATION: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static POISON: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static MAGIC: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static WITHER: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static FALLING_BLOCK: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static THORNS: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static DRAGON_BREATH: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static CUSTOM: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static FLY_INTO_WALL: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static HOT_FLOOR: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static CRAMMING: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static DRYOUT: org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityDamageEvent$DamageCause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityDamageEvent$DamageCause;
}


declare interface $org$bukkit$event$entity$EntityDamageEvent$DamageModifier {}

declare class org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  implements $org$bukkit$event$entity$EntityDamageEvent$DamageModifier {
  static BASE: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static HARD_HAT: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static BLOCKING: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static ARMOR: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static RESISTANCE: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static MAGIC: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static ABSORPTION: org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityDamageEvent$DamageModifier
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
}


declare interface $com$google$common$base$Function {
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}

declare class com$google$common$base$Function
  implements $com$google$common$base$Function {
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $org$bukkit$EntityEffect {
  getData(): Buffer;
  getApplicable(): any /* java.lang.Class */;
}

declare class org$bukkit$EntityEffect implements $org$bukkit$EntityEffect {
  static ARROW_PARTICLES: org$bukkit$EntityEffect;
  static RABBIT_JUMP: org$bukkit$EntityEffect;
  static HURT: org$bukkit$EntityEffect;
  static DEATH: org$bukkit$EntityEffect;
  static WOLF_SMOKE: org$bukkit$EntityEffect;
  static WOLF_HEARTS: org$bukkit$EntityEffect;
  static WOLF_SHAKE: org$bukkit$EntityEffect;
  static SHEEP_EAT: org$bukkit$EntityEffect;
  static IRON_GOLEM_ROSE: org$bukkit$EntityEffect;
  static VILLAGER_HEART: org$bukkit$EntityEffect;
  static VILLAGER_ANGRY: org$bukkit$EntityEffect;
  static VILLAGER_HAPPY: org$bukkit$EntityEffect;
  static WITCH_MAGIC: org$bukkit$EntityEffect;
  static ZOMBIE_TRANSFORM: org$bukkit$EntityEffect;
  static FIREWORK_EXPLODE: org$bukkit$EntityEffect;
  static LOVE_HEARTS: org$bukkit$EntityEffect;
  static SQUID_ROTATE: org$bukkit$EntityEffect;
  static ENTITY_POOF: org$bukkit$EntityEffect;
  static GUARDIAN_TARGET: org$bukkit$EntityEffect;
  static SHIELD_BLOCK: org$bukkit$EntityEffect;
  static SHIELD_BREAK: org$bukkit$EntityEffect;
  static ARMOR_STAND_HIT: org$bukkit$EntityEffect;
  static THORNS_HURT: org$bukkit$EntityEffect;
  static IRON_GOLEM_SHEATH: org$bukkit$EntityEffect;
  static TOTEM_RESURRECT: org$bukkit$EntityEffect;
  static HURT_DROWN: org$bukkit$EntityEffect;
  static HURT_EXPLOSION: org$bukkit$EntityEffect;
  static values(): JavaArray<org$bukkit$EntityEffect>;
  static valueOf(arg0: string): org$bukkit$EntityEffect;
  getData(): Buffer;
  getApplicable(): any /* java.lang.Class */;
  static getByData(arg0: Buffer): org$bukkit$EntityEffect;
}


declare interface $org$bukkit$entity$EntityType extends $org$bukkit$Keyed {
  getName(): string;
  getKey(): org$bukkit$NamespacedKey;
  getEntityClass(): any /* java.lang.Class */;
  getTypeId(): unknown;
  isSpawnable(): boolean;
  isAlive(): boolean;
}

declare class org$bukkit$entity$EntityType
  implements $org$bukkit$entity$EntityType {
  static DROPPED_ITEM: org$bukkit$entity$EntityType;
  static EXPERIENCE_ORB: org$bukkit$entity$EntityType;
  static AREA_EFFECT_CLOUD: org$bukkit$entity$EntityType;
  static ELDER_GUARDIAN: org$bukkit$entity$EntityType;
  static WITHER_SKELETON: org$bukkit$entity$EntityType;
  static STRAY: org$bukkit$entity$EntityType;
  static EGG: org$bukkit$entity$EntityType;
  static LEASH_HITCH: org$bukkit$entity$EntityType;
  static PAINTING: org$bukkit$entity$EntityType;
  static ARROW: org$bukkit$entity$EntityType;
  static SNOWBALL: org$bukkit$entity$EntityType;
  static FIREBALL: org$bukkit$entity$EntityType;
  static SMALL_FIREBALL: org$bukkit$entity$EntityType;
  static ENDER_PEARL: org$bukkit$entity$EntityType;
  static ENDER_SIGNAL: org$bukkit$entity$EntityType;
  static SPLASH_POTION: org$bukkit$entity$EntityType;
  static THROWN_EXP_BOTTLE: org$bukkit$entity$EntityType;
  static ITEM_FRAME: org$bukkit$entity$EntityType;
  static WITHER_SKULL: org$bukkit$entity$EntityType;
  static PRIMED_TNT: org$bukkit$entity$EntityType;
  static FALLING_BLOCK: org$bukkit$entity$EntityType;
  static FIREWORK: org$bukkit$entity$EntityType;
  static HUSK: org$bukkit$entity$EntityType;
  static SPECTRAL_ARROW: org$bukkit$entity$EntityType;
  static SHULKER_BULLET: org$bukkit$entity$EntityType;
  static DRAGON_FIREBALL: org$bukkit$entity$EntityType;
  static ZOMBIE_VILLAGER: org$bukkit$entity$EntityType;
  static SKELETON_HORSE: org$bukkit$entity$EntityType;
  static ZOMBIE_HORSE: org$bukkit$entity$EntityType;
  static ARMOR_STAND: org$bukkit$entity$EntityType;
  static DONKEY: org$bukkit$entity$EntityType;
  static MULE: org$bukkit$entity$EntityType;
  static EVOKER_FANGS: org$bukkit$entity$EntityType;
  static EVOKER: org$bukkit$entity$EntityType;
  static VEX: org$bukkit$entity$EntityType;
  static VINDICATOR: org$bukkit$entity$EntityType;
  static ILLUSIONER: org$bukkit$entity$EntityType;
  static MINECART_COMMAND: org$bukkit$entity$EntityType;
  static BOAT: org$bukkit$entity$EntityType;
  static MINECART: org$bukkit$entity$EntityType;
  static MINECART_CHEST: org$bukkit$entity$EntityType;
  static MINECART_FURNACE: org$bukkit$entity$EntityType;
  static MINECART_TNT: org$bukkit$entity$EntityType;
  static MINECART_HOPPER: org$bukkit$entity$EntityType;
  static MINECART_MOB_SPAWNER: org$bukkit$entity$EntityType;
  static CREEPER: org$bukkit$entity$EntityType;
  static SKELETON: org$bukkit$entity$EntityType;
  static SPIDER: org$bukkit$entity$EntityType;
  static GIANT: org$bukkit$entity$EntityType;
  static ZOMBIE: org$bukkit$entity$EntityType;
  static SLIME: org$bukkit$entity$EntityType;
  static GHAST: org$bukkit$entity$EntityType;
  static PIG_ZOMBIE: org$bukkit$entity$EntityType;
  static ENDERMAN: org$bukkit$entity$EntityType;
  static CAVE_SPIDER: org$bukkit$entity$EntityType;
  static SILVERFISH: org$bukkit$entity$EntityType;
  static BLAZE: org$bukkit$entity$EntityType;
  static MAGMA_CUBE: org$bukkit$entity$EntityType;
  static ENDER_DRAGON: org$bukkit$entity$EntityType;
  static WITHER: org$bukkit$entity$EntityType;
  static BAT: org$bukkit$entity$EntityType;
  static WITCH: org$bukkit$entity$EntityType;
  static ENDERMITE: org$bukkit$entity$EntityType;
  static GUARDIAN: org$bukkit$entity$EntityType;
  static SHULKER: org$bukkit$entity$EntityType;
  static PIG: org$bukkit$entity$EntityType;
  static SHEEP: org$bukkit$entity$EntityType;
  static COW: org$bukkit$entity$EntityType;
  static CHICKEN: org$bukkit$entity$EntityType;
  static SQUID: org$bukkit$entity$EntityType;
  static WOLF: org$bukkit$entity$EntityType;
  static MUSHROOM_COW: org$bukkit$entity$EntityType;
  static SNOWMAN: org$bukkit$entity$EntityType;
  static OCELOT: org$bukkit$entity$EntityType;
  static IRON_GOLEM: org$bukkit$entity$EntityType;
  static HORSE: org$bukkit$entity$EntityType;
  static RABBIT: org$bukkit$entity$EntityType;
  static POLAR_BEAR: org$bukkit$entity$EntityType;
  static LLAMA: org$bukkit$entity$EntityType;
  static LLAMA_SPIT: org$bukkit$entity$EntityType;
  static PARROT: org$bukkit$entity$EntityType;
  static VILLAGER: org$bukkit$entity$EntityType;
  static ENDER_CRYSTAL: org$bukkit$entity$EntityType;
  static TURTLE: org$bukkit$entity$EntityType;
  static PHANTOM: org$bukkit$entity$EntityType;
  static TRIDENT: org$bukkit$entity$EntityType;
  static COD: org$bukkit$entity$EntityType;
  static SALMON: org$bukkit$entity$EntityType;
  static PUFFERFISH: org$bukkit$entity$EntityType;
  static TROPICAL_FISH: org$bukkit$entity$EntityType;
  static DROWNED: org$bukkit$entity$EntityType;
  static DOLPHIN: org$bukkit$entity$EntityType;
  static CAT: org$bukkit$entity$EntityType;
  static PANDA: org$bukkit$entity$EntityType;
  static PILLAGER: org$bukkit$entity$EntityType;
  static RAVAGER: org$bukkit$entity$EntityType;
  static TRADER_LLAMA: org$bukkit$entity$EntityType;
  static WANDERING_TRADER: org$bukkit$entity$EntityType;
  static FOX: org$bukkit$entity$EntityType;
  static BEE: org$bukkit$entity$EntityType;
  static FISHING_HOOK: org$bukkit$entity$EntityType;
  static LIGHTNING: org$bukkit$entity$EntityType;
  static PLAYER: org$bukkit$entity$EntityType;
  static UNKNOWN: org$bukkit$entity$EntityType;
  static values(): JavaArray<org$bukkit$entity$EntityType>;
  static valueOf(arg0: string): org$bukkit$entity$EntityType;
  getName(): string;
  getKey(): org$bukkit$NamespacedKey;
  getEntityClass(): any /* java.lang.Class */;
  getTypeId(): unknown;
  static fromName(arg0: string): org$bukkit$entity$EntityType;
  static fromId(arg0: number): org$bukkit$entity$EntityType;
  isSpawnable(): boolean;
  isAlive(): boolean;
}


declare interface $org$bukkit$block$PistonMoveReaction {
  getId(): number;
}

declare class org$bukkit$block$PistonMoveReaction
  implements $org$bukkit$block$PistonMoveReaction {
  static MOVE: org$bukkit$block$PistonMoveReaction;
  static BREAK: org$bukkit$block$PistonMoveReaction;
  static BLOCK: org$bukkit$block$PistonMoveReaction;
  static IGNORE: org$bukkit$block$PistonMoveReaction;
  static PUSH_ONLY: org$bukkit$block$PistonMoveReaction;
  static values(): JavaArray<org$bukkit$block$PistonMoveReaction>;
  static valueOf(arg0: string): org$bukkit$block$PistonMoveReaction;
  getId(): number;
  static getById(arg0: number): org$bukkit$block$PistonMoveReaction;
}


declare interface $org$bukkit$entity$Pose {}

declare class org$bukkit$entity$Pose implements $org$bukkit$entity$Pose {
  static STANDING: org$bukkit$entity$Pose;
  static FALL_FLYING: org$bukkit$entity$Pose;
  static SLEEPING: org$bukkit$entity$Pose;
  static SWIMMING: org$bukkit$entity$Pose;
  static SPIN_ATTACK: org$bukkit$entity$Pose;
  static SNEAKING: org$bukkit$entity$Pose;
  static DYING: org$bukkit$entity$Pose;
  static values(): JavaArray<org$bukkit$entity$Pose>;
  static valueOf(arg0: string): org$bukkit$entity$Pose;
}


declare interface $org$bukkit$entity$Entity$Spigot {}

declare class org$bukkit$entity$Entity$Spigot
  implements $org$bukkit$entity$Entity$Spigot {
  constructor();
}


declare interface $org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason {}

declare class org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  implements $org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason {
  static NATURAL: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static JOCKEY: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static CHUNK_GEN: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static SPAWNER: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static EGG: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static SPAWNER_EGG: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static LIGHTNING: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static BUILD_SNOWMAN: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static BUILD_IRONGOLEM: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static BUILD_WITHER: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static VILLAGE_DEFENSE: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static VILLAGE_INVASION: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static BREEDING: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static SLIME_SPLIT: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static REINFORCEMENTS: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static NETHER_PORTAL: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static DISPENSE_EGG: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static INFECTION: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static CURED: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static OCELOT_BABY: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static SILVERFISH_BLOCK: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static MOUNT: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static TRAP: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static ENDER_PEARL: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static SHOULDER_ENTITY: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static DROWNED: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static SHEARED: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static EXPLOSION: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static RAID: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static PATROL: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static BEEHIVE: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static CUSTOM: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static DEFAULT: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  static values(): JavaArray<
    org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
}


declare interface $org$bukkit$command$CommandSender$Spigot {
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
}

declare class org$bukkit$command$CommandSender$Spigot
  implements $org$bukkit$command$CommandSender$Spigot {
  constructor();
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
}


declare interface $org$bukkit$block$BlockState
  extends $org$bukkit$metadata$Metadatable {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
}

declare class org$bukkit$block$BlockState
  implements $org$bukkit$block$BlockState {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$FluidCollisionMode {}

declare class org$bukkit$FluidCollisionMode
  implements $org$bukkit$FluidCollisionMode {
  static NEVER: org$bukkit$FluidCollisionMode;
  static SOURCE_ONLY: org$bukkit$FluidCollisionMode;
  static ALWAYS: org$bukkit$FluidCollisionMode;
  static values(): JavaArray<org$bukkit$FluidCollisionMode>;
  static valueOf(arg0: string): org$bukkit$FluidCollisionMode;
}


declare interface $com$destroystokyo$paper$block$BlockSoundGroup {
  getBreakSound(): org$bukkit$Sound;
  getStepSound(): org$bukkit$Sound;
  getPlaceSound(): org$bukkit$Sound;
  getHitSound(): org$bukkit$Sound;
  getFallSound(): org$bukkit$Sound;
}

declare class com$destroystokyo$paper$block$BlockSoundGroup
  implements $com$destroystokyo$paper$block$BlockSoundGroup {
  getBreakSound(): org$bukkit$Sound;
  getStepSound(): org$bukkit$Sound;
  getPlaceSound(): org$bukkit$Sound;
  getHitSound(): org$bukkit$Sound;
  getFallSound(): org$bukkit$Sound;
}


declare interface $org$bukkit$Sound {}

declare class org$bukkit$Sound implements $org$bukkit$Sound {
  static AMBIENT_CAVE: org$bukkit$Sound;
  static AMBIENT_UNDERWATER_ENTER: org$bukkit$Sound;
  static AMBIENT_UNDERWATER_EXIT: org$bukkit$Sound;
  static AMBIENT_UNDERWATER_LOOP: org$bukkit$Sound;
  static AMBIENT_UNDERWATER_LOOP_ADDITIONS: org$bukkit$Sound;
  static AMBIENT_UNDERWATER_LOOP_ADDITIONS_RARE: org$bukkit$Sound;
  static AMBIENT_UNDERWATER_LOOP_ADDITIONS_ULTRA_RARE: org$bukkit$Sound;
  static BLOCK_ANVIL_BREAK: org$bukkit$Sound;
  static BLOCK_ANVIL_DESTROY: org$bukkit$Sound;
  static BLOCK_ANVIL_FALL: org$bukkit$Sound;
  static BLOCK_ANVIL_HIT: org$bukkit$Sound;
  static BLOCK_ANVIL_LAND: org$bukkit$Sound;
  static BLOCK_ANVIL_PLACE: org$bukkit$Sound;
  static BLOCK_ANVIL_STEP: org$bukkit$Sound;
  static BLOCK_ANVIL_USE: org$bukkit$Sound;
  static BLOCK_BAMBOO_BREAK: org$bukkit$Sound;
  static BLOCK_BAMBOO_FALL: org$bukkit$Sound;
  static BLOCK_BAMBOO_HIT: org$bukkit$Sound;
  static BLOCK_BAMBOO_PLACE: org$bukkit$Sound;
  static BLOCK_BAMBOO_SAPLING_BREAK: org$bukkit$Sound;
  static BLOCK_BAMBOO_SAPLING_HIT: org$bukkit$Sound;
  static BLOCK_BAMBOO_SAPLING_PLACE: org$bukkit$Sound;
  static BLOCK_BAMBOO_STEP: org$bukkit$Sound;
  static BLOCK_BARREL_CLOSE: org$bukkit$Sound;
  static BLOCK_BARREL_OPEN: org$bukkit$Sound;
  static BLOCK_BEACON_ACTIVATE: org$bukkit$Sound;
  static BLOCK_BEACON_AMBIENT: org$bukkit$Sound;
  static BLOCK_BEACON_DEACTIVATE: org$bukkit$Sound;
  static BLOCK_BEACON_POWER_SELECT: org$bukkit$Sound;
  static BLOCK_BEEHIVE_DRIP: org$bukkit$Sound;
  static BLOCK_BEEHIVE_ENTER: org$bukkit$Sound;
  static BLOCK_BEEHIVE_EXIT: org$bukkit$Sound;
  static BLOCK_BEEHIVE_SHEAR: org$bukkit$Sound;
  static BLOCK_BEEHIVE_WORK: org$bukkit$Sound;
  static BLOCK_BELL_RESONATE: org$bukkit$Sound;
  static BLOCK_BELL_USE: org$bukkit$Sound;
  static BLOCK_BLASTFURNACE_FIRE_CRACKLE: org$bukkit$Sound;
  static BLOCK_BREWING_STAND_BREW: org$bukkit$Sound;
  static BLOCK_BUBBLE_COLUMN_BUBBLE_POP: org$bukkit$Sound;
  static BLOCK_BUBBLE_COLUMN_UPWARDS_AMBIENT: org$bukkit$Sound;
  static BLOCK_BUBBLE_COLUMN_UPWARDS_INSIDE: org$bukkit$Sound;
  static BLOCK_BUBBLE_COLUMN_WHIRLPOOL_AMBIENT: org$bukkit$Sound;
  static BLOCK_BUBBLE_COLUMN_WHIRLPOOL_INSIDE: org$bukkit$Sound;
  static BLOCK_CAMPFIRE_CRACKLE: org$bukkit$Sound;
  static BLOCK_CHEST_CLOSE: org$bukkit$Sound;
  static BLOCK_CHEST_LOCKED: org$bukkit$Sound;
  static BLOCK_CHEST_OPEN: org$bukkit$Sound;
  static BLOCK_CHORUS_FLOWER_DEATH: org$bukkit$Sound;
  static BLOCK_CHORUS_FLOWER_GROW: org$bukkit$Sound;
  static BLOCK_COMPARATOR_CLICK: org$bukkit$Sound;
  static BLOCK_COMPOSTER_EMPTY: org$bukkit$Sound;
  static BLOCK_COMPOSTER_FILL: org$bukkit$Sound;
  static BLOCK_COMPOSTER_FILL_SUCCESS: org$bukkit$Sound;
  static BLOCK_COMPOSTER_READY: org$bukkit$Sound;
  static BLOCK_CONDUIT_ACTIVATE: org$bukkit$Sound;
  static BLOCK_CONDUIT_AMBIENT: org$bukkit$Sound;
  static BLOCK_CONDUIT_AMBIENT_SHORT: org$bukkit$Sound;
  static BLOCK_CONDUIT_ATTACK_TARGET: org$bukkit$Sound;
  static BLOCK_CONDUIT_DEACTIVATE: org$bukkit$Sound;
  static BLOCK_CORAL_BLOCK_BREAK: org$bukkit$Sound;
  static BLOCK_CORAL_BLOCK_FALL: org$bukkit$Sound;
  static BLOCK_CORAL_BLOCK_HIT: org$bukkit$Sound;
  static BLOCK_CORAL_BLOCK_PLACE: org$bukkit$Sound;
  static BLOCK_CORAL_BLOCK_STEP: org$bukkit$Sound;
  static BLOCK_CROP_BREAK: org$bukkit$Sound;
  static BLOCK_DISPENSER_DISPENSE: org$bukkit$Sound;
  static BLOCK_DISPENSER_FAIL: org$bukkit$Sound;
  static BLOCK_DISPENSER_LAUNCH: org$bukkit$Sound;
  static BLOCK_ENCHANTMENT_TABLE_USE: org$bukkit$Sound;
  static BLOCK_ENDER_CHEST_CLOSE: org$bukkit$Sound;
  static BLOCK_ENDER_CHEST_OPEN: org$bukkit$Sound;
  static BLOCK_END_GATEWAY_SPAWN: org$bukkit$Sound;
  static BLOCK_END_PORTAL_FRAME_FILL: org$bukkit$Sound;
  static BLOCK_END_PORTAL_SPAWN: org$bukkit$Sound;
  static BLOCK_FENCE_GATE_CLOSE: org$bukkit$Sound;
  static BLOCK_FENCE_GATE_OPEN: org$bukkit$Sound;
  static BLOCK_FIRE_AMBIENT: org$bukkit$Sound;
  static BLOCK_FIRE_EXTINGUISH: org$bukkit$Sound;
  static BLOCK_FURNACE_FIRE_CRACKLE: org$bukkit$Sound;
  static BLOCK_GLASS_BREAK: org$bukkit$Sound;
  static BLOCK_GLASS_FALL: org$bukkit$Sound;
  static BLOCK_GLASS_HIT: org$bukkit$Sound;
  static BLOCK_GLASS_PLACE: org$bukkit$Sound;
  static BLOCK_GLASS_STEP: org$bukkit$Sound;
  static BLOCK_GRASS_BREAK: org$bukkit$Sound;
  static BLOCK_GRASS_FALL: org$bukkit$Sound;
  static BLOCK_GRASS_HIT: org$bukkit$Sound;
  static BLOCK_GRASS_PLACE: org$bukkit$Sound;
  static BLOCK_GRASS_STEP: org$bukkit$Sound;
  static BLOCK_GRAVEL_BREAK: org$bukkit$Sound;
  static BLOCK_GRAVEL_FALL: org$bukkit$Sound;
  static BLOCK_GRAVEL_HIT: org$bukkit$Sound;
  static BLOCK_GRAVEL_PLACE: org$bukkit$Sound;
  static BLOCK_GRAVEL_STEP: org$bukkit$Sound;
  static BLOCK_GRINDSTONE_USE: org$bukkit$Sound;
  static BLOCK_HONEY_BLOCK_BREAK: org$bukkit$Sound;
  static BLOCK_HONEY_BLOCK_FALL: org$bukkit$Sound;
  static BLOCK_HONEY_BLOCK_HIT: org$bukkit$Sound;
  static BLOCK_HONEY_BLOCK_PLACE: org$bukkit$Sound;
  static BLOCK_HONEY_BLOCK_SLIDE: org$bukkit$Sound;
  static BLOCK_HONEY_BLOCK_STEP: org$bukkit$Sound;
  static BLOCK_IRON_DOOR_CLOSE: org$bukkit$Sound;
  static BLOCK_IRON_DOOR_OPEN: org$bukkit$Sound;
  static BLOCK_IRON_TRAPDOOR_CLOSE: org$bukkit$Sound;
  static BLOCK_IRON_TRAPDOOR_OPEN: org$bukkit$Sound;
  static BLOCK_LADDER_BREAK: org$bukkit$Sound;
  static BLOCK_LADDER_FALL: org$bukkit$Sound;
  static BLOCK_LADDER_HIT: org$bukkit$Sound;
  static BLOCK_LADDER_PLACE: org$bukkit$Sound;
  static BLOCK_LADDER_STEP: org$bukkit$Sound;
  static BLOCK_LANTERN_BREAK: org$bukkit$Sound;
  static BLOCK_LANTERN_FALL: org$bukkit$Sound;
  static BLOCK_LANTERN_HIT: org$bukkit$Sound;
  static BLOCK_LANTERN_PLACE: org$bukkit$Sound;
  static BLOCK_LANTERN_STEP: org$bukkit$Sound;
  static BLOCK_LAVA_AMBIENT: org$bukkit$Sound;
  static BLOCK_LAVA_EXTINGUISH: org$bukkit$Sound;
  static BLOCK_LAVA_POP: org$bukkit$Sound;
  static BLOCK_LEVER_CLICK: org$bukkit$Sound;
  static BLOCK_LILY_PAD_PLACE: org$bukkit$Sound;
  static BLOCK_METAL_BREAK: org$bukkit$Sound;
  static BLOCK_METAL_FALL: org$bukkit$Sound;
  static BLOCK_METAL_HIT: org$bukkit$Sound;
  static BLOCK_METAL_PLACE: org$bukkit$Sound;
  static BLOCK_METAL_PRESSURE_PLATE_CLICK_OFF: org$bukkit$Sound;
  static BLOCK_METAL_PRESSURE_PLATE_CLICK_ON: org$bukkit$Sound;
  static BLOCK_METAL_STEP: org$bukkit$Sound;
  static BLOCK_NETHER_WART_BREAK: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_BANJO: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_BASEDRUM: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_BASS: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_BELL: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_BIT: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_CHIME: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_COW_BELL: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_DIDGERIDOO: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_FLUTE: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_GUITAR: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_HARP: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_HAT: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_IRON_XYLOPHONE: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_PLING: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_SNARE: org$bukkit$Sound;
  static BLOCK_NOTE_BLOCK_XYLOPHONE: org$bukkit$Sound;
  static BLOCK_PISTON_CONTRACT: org$bukkit$Sound;
  static BLOCK_PISTON_EXTEND: org$bukkit$Sound;
  static BLOCK_PORTAL_AMBIENT: org$bukkit$Sound;
  static BLOCK_PORTAL_TRAVEL: org$bukkit$Sound;
  static BLOCK_PORTAL_TRIGGER: org$bukkit$Sound;
  static BLOCK_PUMPKIN_CARVE: org$bukkit$Sound;
  static BLOCK_REDSTONE_TORCH_BURNOUT: org$bukkit$Sound;
  static BLOCK_SAND_BREAK: org$bukkit$Sound;
  static BLOCK_SAND_FALL: org$bukkit$Sound;
  static BLOCK_SAND_HIT: org$bukkit$Sound;
  static BLOCK_SAND_PLACE: org$bukkit$Sound;
  static BLOCK_SAND_STEP: org$bukkit$Sound;
  static BLOCK_SCAFFOLDING_BREAK: org$bukkit$Sound;
  static BLOCK_SCAFFOLDING_FALL: org$bukkit$Sound;
  static BLOCK_SCAFFOLDING_HIT: org$bukkit$Sound;
  static BLOCK_SCAFFOLDING_PLACE: org$bukkit$Sound;
  static BLOCK_SCAFFOLDING_STEP: org$bukkit$Sound;
  static BLOCK_SHULKER_BOX_CLOSE: org$bukkit$Sound;
  static BLOCK_SHULKER_BOX_OPEN: org$bukkit$Sound;
  static BLOCK_SLIME_BLOCK_BREAK: org$bukkit$Sound;
  static BLOCK_SLIME_BLOCK_FALL: org$bukkit$Sound;
  static BLOCK_SLIME_BLOCK_HIT: org$bukkit$Sound;
  static BLOCK_SLIME_BLOCK_PLACE: org$bukkit$Sound;
  static BLOCK_SLIME_BLOCK_STEP: org$bukkit$Sound;
  static BLOCK_SMOKER_SMOKE: org$bukkit$Sound;
  static BLOCK_SNOW_BREAK: org$bukkit$Sound;
  static BLOCK_SNOW_FALL: org$bukkit$Sound;
  static BLOCK_SNOW_HIT: org$bukkit$Sound;
  static BLOCK_SNOW_PLACE: org$bukkit$Sound;
  static BLOCK_SNOW_STEP: org$bukkit$Sound;
  static BLOCK_STONE_BREAK: org$bukkit$Sound;
  static BLOCK_STONE_BUTTON_CLICK_OFF: org$bukkit$Sound;
  static BLOCK_STONE_BUTTON_CLICK_ON: org$bukkit$Sound;
  static BLOCK_STONE_FALL: org$bukkit$Sound;
  static BLOCK_STONE_HIT: org$bukkit$Sound;
  static BLOCK_STONE_PLACE: org$bukkit$Sound;
  static BLOCK_STONE_PRESSURE_PLATE_CLICK_OFF: org$bukkit$Sound;
  static BLOCK_STONE_PRESSURE_PLATE_CLICK_ON: org$bukkit$Sound;
  static BLOCK_STONE_STEP: org$bukkit$Sound;
  static BLOCK_SWEET_BERRY_BUSH_BREAK: org$bukkit$Sound;
  static BLOCK_SWEET_BERRY_BUSH_PLACE: org$bukkit$Sound;
  static BLOCK_TRIPWIRE_ATTACH: org$bukkit$Sound;
  static BLOCK_TRIPWIRE_CLICK_OFF: org$bukkit$Sound;
  static BLOCK_TRIPWIRE_CLICK_ON: org$bukkit$Sound;
  static BLOCK_TRIPWIRE_DETACH: org$bukkit$Sound;
  static BLOCK_WATER_AMBIENT: org$bukkit$Sound;
  static BLOCK_WET_GRASS_BREAK: org$bukkit$Sound;
  static BLOCK_WET_GRASS_FALL: org$bukkit$Sound;
  static BLOCK_WET_GRASS_HIT: org$bukkit$Sound;
  static BLOCK_WET_GRASS_PLACE: org$bukkit$Sound;
  static BLOCK_WET_GRASS_STEP: org$bukkit$Sound;
  static BLOCK_WOODEN_BUTTON_CLICK_OFF: org$bukkit$Sound;
  static BLOCK_WOODEN_BUTTON_CLICK_ON: org$bukkit$Sound;
  static BLOCK_WOODEN_DOOR_CLOSE: org$bukkit$Sound;
  static BLOCK_WOODEN_DOOR_OPEN: org$bukkit$Sound;
  static BLOCK_WOODEN_PRESSURE_PLATE_CLICK_OFF: org$bukkit$Sound;
  static BLOCK_WOODEN_PRESSURE_PLATE_CLICK_ON: org$bukkit$Sound;
  static BLOCK_WOODEN_TRAPDOOR_CLOSE: org$bukkit$Sound;
  static BLOCK_WOODEN_TRAPDOOR_OPEN: org$bukkit$Sound;
  static BLOCK_WOOD_BREAK: org$bukkit$Sound;
  static BLOCK_WOOD_FALL: org$bukkit$Sound;
  static BLOCK_WOOD_HIT: org$bukkit$Sound;
  static BLOCK_WOOD_PLACE: org$bukkit$Sound;
  static BLOCK_WOOD_STEP: org$bukkit$Sound;
  static BLOCK_WOOL_BREAK: org$bukkit$Sound;
  static BLOCK_WOOL_FALL: org$bukkit$Sound;
  static BLOCK_WOOL_HIT: org$bukkit$Sound;
  static BLOCK_WOOL_PLACE: org$bukkit$Sound;
  static BLOCK_WOOL_STEP: org$bukkit$Sound;
  static ENCHANT_THORNS_HIT: org$bukkit$Sound;
  static ENTITY_ARMOR_STAND_BREAK: org$bukkit$Sound;
  static ENTITY_ARMOR_STAND_FALL: org$bukkit$Sound;
  static ENTITY_ARMOR_STAND_HIT: org$bukkit$Sound;
  static ENTITY_ARMOR_STAND_PLACE: org$bukkit$Sound;
  static ENTITY_ARROW_HIT: org$bukkit$Sound;
  static ENTITY_ARROW_HIT_PLAYER: org$bukkit$Sound;
  static ENTITY_ARROW_SHOOT: org$bukkit$Sound;
  static ENTITY_BAT_AMBIENT: org$bukkit$Sound;
  static ENTITY_BAT_DEATH: org$bukkit$Sound;
  static ENTITY_BAT_HURT: org$bukkit$Sound;
  static ENTITY_BAT_LOOP: org$bukkit$Sound;
  static ENTITY_BAT_TAKEOFF: org$bukkit$Sound;
  static ENTITY_BEE_DEATH: org$bukkit$Sound;
  static ENTITY_BEE_HURT: org$bukkit$Sound;
  static ENTITY_BEE_LOOP: org$bukkit$Sound;
  static ENTITY_BEE_LOOP_AGGRESSIVE: org$bukkit$Sound;
  static ENTITY_BEE_POLLINATE: org$bukkit$Sound;
  static ENTITY_BEE_STING: org$bukkit$Sound;
  static ENTITY_BLAZE_AMBIENT: org$bukkit$Sound;
  static ENTITY_BLAZE_BURN: org$bukkit$Sound;
  static ENTITY_BLAZE_DEATH: org$bukkit$Sound;
  static ENTITY_BLAZE_HURT: org$bukkit$Sound;
  static ENTITY_BLAZE_SHOOT: org$bukkit$Sound;
  static ENTITY_BOAT_PADDLE_LAND: org$bukkit$Sound;
  static ENTITY_BOAT_PADDLE_WATER: org$bukkit$Sound;
  static ENTITY_CAT_AMBIENT: org$bukkit$Sound;
  static ENTITY_CAT_BEG_FOR_FOOD: org$bukkit$Sound;
  static ENTITY_CAT_DEATH: org$bukkit$Sound;
  static ENTITY_CAT_EAT: org$bukkit$Sound;
  static ENTITY_CAT_HISS: org$bukkit$Sound;
  static ENTITY_CAT_HURT: org$bukkit$Sound;
  static ENTITY_CAT_PURR: org$bukkit$Sound;
  static ENTITY_CAT_PURREOW: org$bukkit$Sound;
  static ENTITY_CAT_STRAY_AMBIENT: org$bukkit$Sound;
  static ENTITY_CHICKEN_AMBIENT: org$bukkit$Sound;
  static ENTITY_CHICKEN_DEATH: org$bukkit$Sound;
  static ENTITY_CHICKEN_EGG: org$bukkit$Sound;
  static ENTITY_CHICKEN_HURT: org$bukkit$Sound;
  static ENTITY_CHICKEN_STEP: org$bukkit$Sound;
  static ENTITY_COD_AMBIENT: org$bukkit$Sound;
  static ENTITY_COD_DEATH: org$bukkit$Sound;
  static ENTITY_COD_FLOP: org$bukkit$Sound;
  static ENTITY_COD_HURT: org$bukkit$Sound;
  static ENTITY_COW_AMBIENT: org$bukkit$Sound;
  static ENTITY_COW_DEATH: org$bukkit$Sound;
  static ENTITY_COW_HURT: org$bukkit$Sound;
  static ENTITY_COW_MILK: org$bukkit$Sound;
  static ENTITY_COW_STEP: org$bukkit$Sound;
  static ENTITY_CREEPER_DEATH: org$bukkit$Sound;
  static ENTITY_CREEPER_HURT: org$bukkit$Sound;
  static ENTITY_CREEPER_PRIMED: org$bukkit$Sound;
  static ENTITY_DOLPHIN_AMBIENT: org$bukkit$Sound;
  static ENTITY_DOLPHIN_AMBIENT_WATER: org$bukkit$Sound;
  static ENTITY_DOLPHIN_ATTACK: org$bukkit$Sound;
  static ENTITY_DOLPHIN_DEATH: org$bukkit$Sound;
  static ENTITY_DOLPHIN_EAT: org$bukkit$Sound;
  static ENTITY_DOLPHIN_HURT: org$bukkit$Sound;
  static ENTITY_DOLPHIN_JUMP: org$bukkit$Sound;
  static ENTITY_DOLPHIN_PLAY: org$bukkit$Sound;
  static ENTITY_DOLPHIN_SPLASH: org$bukkit$Sound;
  static ENTITY_DOLPHIN_SWIM: org$bukkit$Sound;
  static ENTITY_DONKEY_AMBIENT: org$bukkit$Sound;
  static ENTITY_DONKEY_ANGRY: org$bukkit$Sound;
  static ENTITY_DONKEY_CHEST: org$bukkit$Sound;
  static ENTITY_DONKEY_DEATH: org$bukkit$Sound;
  static ENTITY_DONKEY_HURT: org$bukkit$Sound;
  static ENTITY_DRAGON_FIREBALL_EXPLODE: org$bukkit$Sound;
  static ENTITY_DROWNED_AMBIENT: org$bukkit$Sound;
  static ENTITY_DROWNED_AMBIENT_WATER: org$bukkit$Sound;
  static ENTITY_DROWNED_DEATH: org$bukkit$Sound;
  static ENTITY_DROWNED_DEATH_WATER: org$bukkit$Sound;
  static ENTITY_DROWNED_HURT: org$bukkit$Sound;
  static ENTITY_DROWNED_HURT_WATER: org$bukkit$Sound;
  static ENTITY_DROWNED_SHOOT: org$bukkit$Sound;
  static ENTITY_DROWNED_STEP: org$bukkit$Sound;
  static ENTITY_DROWNED_SWIM: org$bukkit$Sound;
  static ENTITY_EGG_THROW: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_AMBIENT: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_AMBIENT_LAND: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_CURSE: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_DEATH: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_DEATH_LAND: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_FLOP: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_HURT: org$bukkit$Sound;
  static ENTITY_ELDER_GUARDIAN_HURT_LAND: org$bukkit$Sound;
  static ENTITY_ENDERMAN_AMBIENT: org$bukkit$Sound;
  static ENTITY_ENDERMAN_DEATH: org$bukkit$Sound;
  static ENTITY_ENDERMAN_HURT: org$bukkit$Sound;
  static ENTITY_ENDERMAN_SCREAM: org$bukkit$Sound;
  static ENTITY_ENDERMAN_STARE: org$bukkit$Sound;
  static ENTITY_ENDERMAN_TELEPORT: org$bukkit$Sound;
  static ENTITY_ENDERMITE_AMBIENT: org$bukkit$Sound;
  static ENTITY_ENDERMITE_DEATH: org$bukkit$Sound;
  static ENTITY_ENDERMITE_HURT: org$bukkit$Sound;
  static ENTITY_ENDERMITE_STEP: org$bukkit$Sound;
  static ENTITY_ENDER_DRAGON_AMBIENT: org$bukkit$Sound;
  static ENTITY_ENDER_DRAGON_DEATH: org$bukkit$Sound;
  static ENTITY_ENDER_DRAGON_FLAP: org$bukkit$Sound;
  static ENTITY_ENDER_DRAGON_GROWL: org$bukkit$Sound;
  static ENTITY_ENDER_DRAGON_HURT: org$bukkit$Sound;
  static ENTITY_ENDER_DRAGON_SHOOT: org$bukkit$Sound;
  static ENTITY_ENDER_EYE_DEATH: org$bukkit$Sound;
  static ENTITY_ENDER_EYE_LAUNCH: org$bukkit$Sound;
  static ENTITY_ENDER_PEARL_THROW: org$bukkit$Sound;
  static ENTITY_EVOKER_AMBIENT: org$bukkit$Sound;
  static ENTITY_EVOKER_CAST_SPELL: org$bukkit$Sound;
  static ENTITY_EVOKER_CELEBRATE: org$bukkit$Sound;
  static ENTITY_EVOKER_DEATH: org$bukkit$Sound;
  static ENTITY_EVOKER_FANGS_ATTACK: org$bukkit$Sound;
  static ENTITY_EVOKER_HURT: org$bukkit$Sound;
  static ENTITY_EVOKER_PREPARE_ATTACK: org$bukkit$Sound;
  static ENTITY_EVOKER_PREPARE_SUMMON: org$bukkit$Sound;
  static ENTITY_EVOKER_PREPARE_WOLOLO: org$bukkit$Sound;
  static ENTITY_EXPERIENCE_BOTTLE_THROW: org$bukkit$Sound;
  static ENTITY_EXPERIENCE_ORB_PICKUP: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_BLAST: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_BLAST_FAR: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_LARGE_BLAST: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_LARGE_BLAST_FAR: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_LAUNCH: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_SHOOT: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_TWINKLE: org$bukkit$Sound;
  static ENTITY_FIREWORK_ROCKET_TWINKLE_FAR: org$bukkit$Sound;
  static ENTITY_FISHING_BOBBER_RETRIEVE: org$bukkit$Sound;
  static ENTITY_FISHING_BOBBER_SPLASH: org$bukkit$Sound;
  static ENTITY_FISHING_BOBBER_THROW: org$bukkit$Sound;
  static ENTITY_FISH_SWIM: org$bukkit$Sound;
  static ENTITY_FOX_AGGRO: org$bukkit$Sound;
  static ENTITY_FOX_AMBIENT: org$bukkit$Sound;
  static ENTITY_FOX_BITE: org$bukkit$Sound;
  static ENTITY_FOX_DEATH: org$bukkit$Sound;
  static ENTITY_FOX_EAT: org$bukkit$Sound;
  static ENTITY_FOX_HURT: org$bukkit$Sound;
  static ENTITY_FOX_SCREECH: org$bukkit$Sound;
  static ENTITY_FOX_SLEEP: org$bukkit$Sound;
  static ENTITY_FOX_SNIFF: org$bukkit$Sound;
  static ENTITY_FOX_SPIT: org$bukkit$Sound;
  static ENTITY_GENERIC_BIG_FALL: org$bukkit$Sound;
  static ENTITY_GENERIC_BURN: org$bukkit$Sound;
  static ENTITY_GENERIC_DEATH: org$bukkit$Sound;
  static ENTITY_GENERIC_DRINK: org$bukkit$Sound;
  static ENTITY_GENERIC_EAT: org$bukkit$Sound;
  static ENTITY_GENERIC_EXPLODE: org$bukkit$Sound;
  static ENTITY_GENERIC_EXTINGUISH_FIRE: org$bukkit$Sound;
  static ENTITY_GENERIC_HURT: org$bukkit$Sound;
  static ENTITY_GENERIC_SMALL_FALL: org$bukkit$Sound;
  static ENTITY_GENERIC_SPLASH: org$bukkit$Sound;
  static ENTITY_GENERIC_SWIM: org$bukkit$Sound;
  static ENTITY_GHAST_AMBIENT: org$bukkit$Sound;
  static ENTITY_GHAST_DEATH: org$bukkit$Sound;
  static ENTITY_GHAST_HURT: org$bukkit$Sound;
  static ENTITY_GHAST_SCREAM: org$bukkit$Sound;
  static ENTITY_GHAST_SHOOT: org$bukkit$Sound;
  static ENTITY_GHAST_WARN: org$bukkit$Sound;
  static ENTITY_GUARDIAN_AMBIENT: org$bukkit$Sound;
  static ENTITY_GUARDIAN_AMBIENT_LAND: org$bukkit$Sound;
  static ENTITY_GUARDIAN_ATTACK: org$bukkit$Sound;
  static ENTITY_GUARDIAN_DEATH: org$bukkit$Sound;
  static ENTITY_GUARDIAN_DEATH_LAND: org$bukkit$Sound;
  static ENTITY_GUARDIAN_FLOP: org$bukkit$Sound;
  static ENTITY_GUARDIAN_HURT: org$bukkit$Sound;
  static ENTITY_GUARDIAN_HURT_LAND: org$bukkit$Sound;
  static ENTITY_HORSE_AMBIENT: org$bukkit$Sound;
  static ENTITY_HORSE_ANGRY: org$bukkit$Sound;
  static ENTITY_HORSE_ARMOR: org$bukkit$Sound;
  static ENTITY_HORSE_BREATHE: org$bukkit$Sound;
  static ENTITY_HORSE_DEATH: org$bukkit$Sound;
  static ENTITY_HORSE_EAT: org$bukkit$Sound;
  static ENTITY_HORSE_GALLOP: org$bukkit$Sound;
  static ENTITY_HORSE_HURT: org$bukkit$Sound;
  static ENTITY_HORSE_JUMP: org$bukkit$Sound;
  static ENTITY_HORSE_LAND: org$bukkit$Sound;
  static ENTITY_HORSE_SADDLE: org$bukkit$Sound;
  static ENTITY_HORSE_STEP: org$bukkit$Sound;
  static ENTITY_HORSE_STEP_WOOD: org$bukkit$Sound;
  static ENTITY_HOSTILE_BIG_FALL: org$bukkit$Sound;
  static ENTITY_HOSTILE_DEATH: org$bukkit$Sound;
  static ENTITY_HOSTILE_HURT: org$bukkit$Sound;
  static ENTITY_HOSTILE_SMALL_FALL: org$bukkit$Sound;
  static ENTITY_HOSTILE_SPLASH: org$bukkit$Sound;
  static ENTITY_HOSTILE_SWIM: org$bukkit$Sound;
  static ENTITY_HUSK_AMBIENT: org$bukkit$Sound;
  static ENTITY_HUSK_CONVERTED_TO_ZOMBIE: org$bukkit$Sound;
  static ENTITY_HUSK_DEATH: org$bukkit$Sound;
  static ENTITY_HUSK_HURT: org$bukkit$Sound;
  static ENTITY_HUSK_STEP: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_AMBIENT: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_CAST_SPELL: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_DEATH: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_HURT: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_MIRROR_MOVE: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_PREPARE_BLINDNESS: org$bukkit$Sound;
  static ENTITY_ILLUSIONER_PREPARE_MIRROR: org$bukkit$Sound;
  static ENTITY_IRON_GOLEM_ATTACK: org$bukkit$Sound;
  static ENTITY_IRON_GOLEM_DAMAGE: org$bukkit$Sound;
  static ENTITY_IRON_GOLEM_DEATH: org$bukkit$Sound;
  static ENTITY_IRON_GOLEM_HURT: org$bukkit$Sound;
  static ENTITY_IRON_GOLEM_REPAIR: org$bukkit$Sound;
  static ENTITY_IRON_GOLEM_STEP: org$bukkit$Sound;
  static ENTITY_ITEM_BREAK: org$bukkit$Sound;
  static ENTITY_ITEM_FRAME_ADD_ITEM: org$bukkit$Sound;
  static ENTITY_ITEM_FRAME_BREAK: org$bukkit$Sound;
  static ENTITY_ITEM_FRAME_PLACE: org$bukkit$Sound;
  static ENTITY_ITEM_FRAME_REMOVE_ITEM: org$bukkit$Sound;
  static ENTITY_ITEM_FRAME_ROTATE_ITEM: org$bukkit$Sound;
  static ENTITY_ITEM_PICKUP: org$bukkit$Sound;
  static ENTITY_LEASH_KNOT_BREAK: org$bukkit$Sound;
  static ENTITY_LEASH_KNOT_PLACE: org$bukkit$Sound;
  static ENTITY_LIGHTNING_BOLT_IMPACT: org$bukkit$Sound;
  static ENTITY_LIGHTNING_BOLT_THUNDER: org$bukkit$Sound;
  static ENTITY_LINGERING_POTION_THROW: org$bukkit$Sound;
  static ENTITY_LLAMA_AMBIENT: org$bukkit$Sound;
  static ENTITY_LLAMA_ANGRY: org$bukkit$Sound;
  static ENTITY_LLAMA_CHEST: org$bukkit$Sound;
  static ENTITY_LLAMA_DEATH: org$bukkit$Sound;
  static ENTITY_LLAMA_EAT: org$bukkit$Sound;
  static ENTITY_LLAMA_HURT: org$bukkit$Sound;
  static ENTITY_LLAMA_SPIT: org$bukkit$Sound;
  static ENTITY_LLAMA_STEP: org$bukkit$Sound;
  static ENTITY_LLAMA_SWAG: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_DEATH: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_DEATH_SMALL: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_HURT: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_HURT_SMALL: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_JUMP: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_SQUISH: org$bukkit$Sound;
  static ENTITY_MAGMA_CUBE_SQUISH_SMALL: org$bukkit$Sound;
  static ENTITY_MINECART_INSIDE: org$bukkit$Sound;
  static ENTITY_MINECART_RIDING: org$bukkit$Sound;
  static ENTITY_MOOSHROOM_CONVERT: org$bukkit$Sound;
  static ENTITY_MOOSHROOM_EAT: org$bukkit$Sound;
  static ENTITY_MOOSHROOM_MILK: org$bukkit$Sound;
  static ENTITY_MOOSHROOM_SHEAR: org$bukkit$Sound;
  static ENTITY_MOOSHROOM_SUSPICIOUS_MILK: org$bukkit$Sound;
  static ENTITY_MULE_AMBIENT: org$bukkit$Sound;
  static ENTITY_MULE_CHEST: org$bukkit$Sound;
  static ENTITY_MULE_DEATH: org$bukkit$Sound;
  static ENTITY_MULE_HURT: org$bukkit$Sound;
  static ENTITY_OCELOT_AMBIENT: org$bukkit$Sound;
  static ENTITY_OCELOT_DEATH: org$bukkit$Sound;
  static ENTITY_OCELOT_HURT: org$bukkit$Sound;
  static ENTITY_PAINTING_BREAK: org$bukkit$Sound;
  static ENTITY_PAINTING_PLACE: org$bukkit$Sound;
  static ENTITY_PANDA_AGGRESSIVE_AMBIENT: org$bukkit$Sound;
  static ENTITY_PANDA_AMBIENT: org$bukkit$Sound;
  static ENTITY_PANDA_BITE: org$bukkit$Sound;
  static ENTITY_PANDA_CANT_BREED: org$bukkit$Sound;
  static ENTITY_PANDA_DEATH: org$bukkit$Sound;
  static ENTITY_PANDA_EAT: org$bukkit$Sound;
  static ENTITY_PANDA_HURT: org$bukkit$Sound;
  static ENTITY_PANDA_PRE_SNEEZE: org$bukkit$Sound;
  static ENTITY_PANDA_SNEEZE: org$bukkit$Sound;
  static ENTITY_PANDA_STEP: org$bukkit$Sound;
  static ENTITY_PANDA_WORRIED_AMBIENT: org$bukkit$Sound;
  static ENTITY_PARROT_AMBIENT: org$bukkit$Sound;
  static ENTITY_PARROT_DEATH: org$bukkit$Sound;
  static ENTITY_PARROT_EAT: org$bukkit$Sound;
  static ENTITY_PARROT_FLY: org$bukkit$Sound;
  static ENTITY_PARROT_HURT: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_BLAZE: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_CREEPER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_DROWNED: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_ELDER_GUARDIAN: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_ENDERMITE: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_ENDER_DRAGON: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_EVOKER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_GHAST: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_GUARDIAN: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_HUSK: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_ILLUSIONER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_MAGMA_CUBE: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_PHANTOM: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_PILLAGER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_RAVAGER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_SHULKER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_SILVERFISH: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_SKELETON: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_SLIME: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_SPIDER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_STRAY: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_VEX: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_VINDICATOR: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_WITCH: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_WITHER: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_WITHER_SKELETON: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_ZOMBIE: org$bukkit$Sound;
  static ENTITY_PARROT_IMITATE_ZOMBIE_VILLAGER: org$bukkit$Sound;
  static ENTITY_PARROT_STEP: org$bukkit$Sound;
  static ENTITY_PHANTOM_AMBIENT: org$bukkit$Sound;
  static ENTITY_PHANTOM_BITE: org$bukkit$Sound;
  static ENTITY_PHANTOM_DEATH: org$bukkit$Sound;
  static ENTITY_PHANTOM_FLAP: org$bukkit$Sound;
  static ENTITY_PHANTOM_HURT: org$bukkit$Sound;
  static ENTITY_PHANTOM_SWOOP: org$bukkit$Sound;
  static ENTITY_PIG_AMBIENT: org$bukkit$Sound;
  static ENTITY_PIG_DEATH: org$bukkit$Sound;
  static ENTITY_PIG_HURT: org$bukkit$Sound;
  static ENTITY_PIG_SADDLE: org$bukkit$Sound;
  static ENTITY_PIG_STEP: org$bukkit$Sound;
  static ENTITY_PILLAGER_AMBIENT: org$bukkit$Sound;
  static ENTITY_PILLAGER_CELEBRATE: org$bukkit$Sound;
  static ENTITY_PILLAGER_DEATH: org$bukkit$Sound;
  static ENTITY_PILLAGER_HURT: org$bukkit$Sound;
  static ENTITY_PLAYER_ATTACK_CRIT: org$bukkit$Sound;
  static ENTITY_PLAYER_ATTACK_KNOCKBACK: org$bukkit$Sound;
  static ENTITY_PLAYER_ATTACK_NODAMAGE: org$bukkit$Sound;
  static ENTITY_PLAYER_ATTACK_STRONG: org$bukkit$Sound;
  static ENTITY_PLAYER_ATTACK_SWEEP: org$bukkit$Sound;
  static ENTITY_PLAYER_ATTACK_WEAK: org$bukkit$Sound;
  static ENTITY_PLAYER_BIG_FALL: org$bukkit$Sound;
  static ENTITY_PLAYER_BREATH: org$bukkit$Sound;
  static ENTITY_PLAYER_BURP: org$bukkit$Sound;
  static ENTITY_PLAYER_DEATH: org$bukkit$Sound;
  static ENTITY_PLAYER_HURT: org$bukkit$Sound;
  static ENTITY_PLAYER_HURT_DROWN: org$bukkit$Sound;
  static ENTITY_PLAYER_HURT_ON_FIRE: org$bukkit$Sound;
  static ENTITY_PLAYER_HURT_SWEET_BERRY_BUSH: org$bukkit$Sound;
  static ENTITY_PLAYER_LEVELUP: org$bukkit$Sound;
  static ENTITY_PLAYER_SMALL_FALL: org$bukkit$Sound;
  static ENTITY_PLAYER_SPLASH: org$bukkit$Sound;
  static ENTITY_PLAYER_SPLASH_HIGH_SPEED: org$bukkit$Sound;
  static ENTITY_PLAYER_SWIM: org$bukkit$Sound;
  static ENTITY_POLAR_BEAR_AMBIENT: org$bukkit$Sound;
  static ENTITY_POLAR_BEAR_AMBIENT_BABY: org$bukkit$Sound;
  static ENTITY_POLAR_BEAR_DEATH: org$bukkit$Sound;
  static ENTITY_POLAR_BEAR_HURT: org$bukkit$Sound;
  static ENTITY_POLAR_BEAR_STEP: org$bukkit$Sound;
  static ENTITY_POLAR_BEAR_WARNING: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_AMBIENT: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_BLOW_OUT: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_BLOW_UP: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_DEATH: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_FLOP: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_HURT: org$bukkit$Sound;
  static ENTITY_PUFFER_FISH_STING: org$bukkit$Sound;
  static ENTITY_RABBIT_AMBIENT: org$bukkit$Sound;
  static ENTITY_RABBIT_ATTACK: org$bukkit$Sound;
  static ENTITY_RABBIT_DEATH: org$bukkit$Sound;
  static ENTITY_RABBIT_HURT: org$bukkit$Sound;
  static ENTITY_RABBIT_JUMP: org$bukkit$Sound;
  static ENTITY_RAVAGER_AMBIENT: org$bukkit$Sound;
  static ENTITY_RAVAGER_ATTACK: org$bukkit$Sound;
  static ENTITY_RAVAGER_CELEBRATE: org$bukkit$Sound;
  static ENTITY_RAVAGER_DEATH: org$bukkit$Sound;
  static ENTITY_RAVAGER_HURT: org$bukkit$Sound;
  static ENTITY_RAVAGER_ROAR: org$bukkit$Sound;
  static ENTITY_RAVAGER_STEP: org$bukkit$Sound;
  static ENTITY_RAVAGER_STUNNED: org$bukkit$Sound;
  static ENTITY_SALMON_AMBIENT: org$bukkit$Sound;
  static ENTITY_SALMON_DEATH: org$bukkit$Sound;
  static ENTITY_SALMON_FLOP: org$bukkit$Sound;
  static ENTITY_SALMON_HURT: org$bukkit$Sound;
  static ENTITY_SHEEP_AMBIENT: org$bukkit$Sound;
  static ENTITY_SHEEP_DEATH: org$bukkit$Sound;
  static ENTITY_SHEEP_HURT: org$bukkit$Sound;
  static ENTITY_SHEEP_SHEAR: org$bukkit$Sound;
  static ENTITY_SHEEP_STEP: org$bukkit$Sound;
  static ENTITY_SHULKER_AMBIENT: org$bukkit$Sound;
  static ENTITY_SHULKER_BULLET_HIT: org$bukkit$Sound;
  static ENTITY_SHULKER_BULLET_HURT: org$bukkit$Sound;
  static ENTITY_SHULKER_CLOSE: org$bukkit$Sound;
  static ENTITY_SHULKER_DEATH: org$bukkit$Sound;
  static ENTITY_SHULKER_HURT: org$bukkit$Sound;
  static ENTITY_SHULKER_HURT_CLOSED: org$bukkit$Sound;
  static ENTITY_SHULKER_OPEN: org$bukkit$Sound;
  static ENTITY_SHULKER_SHOOT: org$bukkit$Sound;
  static ENTITY_SHULKER_TELEPORT: org$bukkit$Sound;
  static ENTITY_SILVERFISH_AMBIENT: org$bukkit$Sound;
  static ENTITY_SILVERFISH_DEATH: org$bukkit$Sound;
  static ENTITY_SILVERFISH_HURT: org$bukkit$Sound;
  static ENTITY_SILVERFISH_STEP: org$bukkit$Sound;
  static ENTITY_SKELETON_AMBIENT: org$bukkit$Sound;
  static ENTITY_SKELETON_DEATH: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_AMBIENT: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_AMBIENT_WATER: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_DEATH: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_GALLOP_WATER: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_HURT: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_JUMP_WATER: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_STEP_WATER: org$bukkit$Sound;
  static ENTITY_SKELETON_HORSE_SWIM: org$bukkit$Sound;
  static ENTITY_SKELETON_HURT: org$bukkit$Sound;
  static ENTITY_SKELETON_SHOOT: org$bukkit$Sound;
  static ENTITY_SKELETON_STEP: org$bukkit$Sound;
  static ENTITY_SLIME_ATTACK: org$bukkit$Sound;
  static ENTITY_SLIME_DEATH: org$bukkit$Sound;
  static ENTITY_SLIME_DEATH_SMALL: org$bukkit$Sound;
  static ENTITY_SLIME_HURT: org$bukkit$Sound;
  static ENTITY_SLIME_HURT_SMALL: org$bukkit$Sound;
  static ENTITY_SLIME_JUMP: org$bukkit$Sound;
  static ENTITY_SLIME_JUMP_SMALL: org$bukkit$Sound;
  static ENTITY_SLIME_SQUISH: org$bukkit$Sound;
  static ENTITY_SLIME_SQUISH_SMALL: org$bukkit$Sound;
  static ENTITY_SNOWBALL_THROW: org$bukkit$Sound;
  static ENTITY_SNOW_GOLEM_AMBIENT: org$bukkit$Sound;
  static ENTITY_SNOW_GOLEM_DEATH: org$bukkit$Sound;
  static ENTITY_SNOW_GOLEM_HURT: org$bukkit$Sound;
  static ENTITY_SNOW_GOLEM_SHOOT: org$bukkit$Sound;
  static ENTITY_SPIDER_AMBIENT: org$bukkit$Sound;
  static ENTITY_SPIDER_DEATH: org$bukkit$Sound;
  static ENTITY_SPIDER_HURT: org$bukkit$Sound;
  static ENTITY_SPIDER_STEP: org$bukkit$Sound;
  static ENTITY_SPLASH_POTION_BREAK: org$bukkit$Sound;
  static ENTITY_SPLASH_POTION_THROW: org$bukkit$Sound;
  static ENTITY_SQUID_AMBIENT: org$bukkit$Sound;
  static ENTITY_SQUID_DEATH: org$bukkit$Sound;
  static ENTITY_SQUID_HURT: org$bukkit$Sound;
  static ENTITY_SQUID_SQUIRT: org$bukkit$Sound;
  static ENTITY_STRAY_AMBIENT: org$bukkit$Sound;
  static ENTITY_STRAY_DEATH: org$bukkit$Sound;
  static ENTITY_STRAY_HURT: org$bukkit$Sound;
  static ENTITY_STRAY_STEP: org$bukkit$Sound;
  static ENTITY_TNT_PRIMED: org$bukkit$Sound;
  static ENTITY_TROPICAL_FISH_AMBIENT: org$bukkit$Sound;
  static ENTITY_TROPICAL_FISH_DEATH: org$bukkit$Sound;
  static ENTITY_TROPICAL_FISH_FLOP: org$bukkit$Sound;
  static ENTITY_TROPICAL_FISH_HURT: org$bukkit$Sound;
  static ENTITY_TURTLE_AMBIENT_LAND: org$bukkit$Sound;
  static ENTITY_TURTLE_DEATH: org$bukkit$Sound;
  static ENTITY_TURTLE_DEATH_BABY: org$bukkit$Sound;
  static ENTITY_TURTLE_EGG_BREAK: org$bukkit$Sound;
  static ENTITY_TURTLE_EGG_CRACK: org$bukkit$Sound;
  static ENTITY_TURTLE_EGG_HATCH: org$bukkit$Sound;
  static ENTITY_TURTLE_HURT: org$bukkit$Sound;
  static ENTITY_TURTLE_HURT_BABY: org$bukkit$Sound;
  static ENTITY_TURTLE_LAY_EGG: org$bukkit$Sound;
  static ENTITY_TURTLE_SHAMBLE: org$bukkit$Sound;
  static ENTITY_TURTLE_SHAMBLE_BABY: org$bukkit$Sound;
  static ENTITY_TURTLE_SWIM: org$bukkit$Sound;
  static ENTITY_VEX_AMBIENT: org$bukkit$Sound;
  static ENTITY_VEX_CHARGE: org$bukkit$Sound;
  static ENTITY_VEX_DEATH: org$bukkit$Sound;
  static ENTITY_VEX_HURT: org$bukkit$Sound;
  static ENTITY_VILLAGER_AMBIENT: org$bukkit$Sound;
  static ENTITY_VILLAGER_CELEBRATE: org$bukkit$Sound;
  static ENTITY_VILLAGER_DEATH: org$bukkit$Sound;
  static ENTITY_VILLAGER_HURT: org$bukkit$Sound;
  static ENTITY_VILLAGER_NO: org$bukkit$Sound;
  static ENTITY_VILLAGER_TRADE: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_ARMORER: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_BUTCHER: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_CARTOGRAPHER: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_CLERIC: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_FARMER: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_FISHERMAN: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_FLETCHER: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_LEATHERWORKER: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_LIBRARIAN: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_MASON: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_SHEPHERD: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_TOOLSMITH: org$bukkit$Sound;
  static ENTITY_VILLAGER_WORK_WEAPONSMITH: org$bukkit$Sound;
  static ENTITY_VILLAGER_YES: org$bukkit$Sound;
  static ENTITY_VINDICATOR_AMBIENT: org$bukkit$Sound;
  static ENTITY_VINDICATOR_CELEBRATE: org$bukkit$Sound;
  static ENTITY_VINDICATOR_DEATH: org$bukkit$Sound;
  static ENTITY_VINDICATOR_HURT: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_AMBIENT: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_DEATH: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_DISAPPEARED: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_DRINK_MILK: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_DRINK_POTION: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_HURT: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_NO: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_REAPPEARED: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_TRADE: org$bukkit$Sound;
  static ENTITY_WANDERING_TRADER_YES: org$bukkit$Sound;
  static ENTITY_WITCH_AMBIENT: org$bukkit$Sound;
  static ENTITY_WITCH_CELEBRATE: org$bukkit$Sound;
  static ENTITY_WITCH_DEATH: org$bukkit$Sound;
  static ENTITY_WITCH_DRINK: org$bukkit$Sound;
  static ENTITY_WITCH_HURT: org$bukkit$Sound;
  static ENTITY_WITCH_THROW: org$bukkit$Sound;
  static ENTITY_WITHER_AMBIENT: org$bukkit$Sound;
  static ENTITY_WITHER_BREAK_BLOCK: org$bukkit$Sound;
  static ENTITY_WITHER_DEATH: org$bukkit$Sound;
  static ENTITY_WITHER_HURT: org$bukkit$Sound;
  static ENTITY_WITHER_SHOOT: org$bukkit$Sound;
  static ENTITY_WITHER_SKELETON_AMBIENT: org$bukkit$Sound;
  static ENTITY_WITHER_SKELETON_DEATH: org$bukkit$Sound;
  static ENTITY_WITHER_SKELETON_HURT: org$bukkit$Sound;
  static ENTITY_WITHER_SKELETON_STEP: org$bukkit$Sound;
  static ENTITY_WITHER_SPAWN: org$bukkit$Sound;
  static ENTITY_WOLF_AMBIENT: org$bukkit$Sound;
  static ENTITY_WOLF_DEATH: org$bukkit$Sound;
  static ENTITY_WOLF_GROWL: org$bukkit$Sound;
  static ENTITY_WOLF_HOWL: org$bukkit$Sound;
  static ENTITY_WOLF_HURT: org$bukkit$Sound;
  static ENTITY_WOLF_PANT: org$bukkit$Sound;
  static ENTITY_WOLF_SHAKE: org$bukkit$Sound;
  static ENTITY_WOLF_STEP: org$bukkit$Sound;
  static ENTITY_WOLF_WHINE: org$bukkit$Sound;
  static ENTITY_ZOMBIE_AMBIENT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_ATTACK_IRON_DOOR: org$bukkit$Sound;
  static ENTITY_ZOMBIE_ATTACK_WOODEN_DOOR: org$bukkit$Sound;
  static ENTITY_ZOMBIE_BREAK_WOODEN_DOOR: org$bukkit$Sound;
  static ENTITY_ZOMBIE_CONVERTED_TO_DROWNED: org$bukkit$Sound;
  static ENTITY_ZOMBIE_DEATH: org$bukkit$Sound;
  static ENTITY_ZOMBIE_DESTROY_EGG: org$bukkit$Sound;
  static ENTITY_ZOMBIE_HORSE_AMBIENT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_HORSE_DEATH: org$bukkit$Sound;
  static ENTITY_ZOMBIE_HORSE_HURT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_HURT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_INFECT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_PIGMAN_AMBIENT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_PIGMAN_ANGRY: org$bukkit$Sound;
  static ENTITY_ZOMBIE_PIGMAN_DEATH: org$bukkit$Sound;
  static ENTITY_ZOMBIE_PIGMAN_HURT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_STEP: org$bukkit$Sound;
  static ENTITY_ZOMBIE_VILLAGER_AMBIENT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_VILLAGER_CONVERTED: org$bukkit$Sound;
  static ENTITY_ZOMBIE_VILLAGER_CURE: org$bukkit$Sound;
  static ENTITY_ZOMBIE_VILLAGER_DEATH: org$bukkit$Sound;
  static ENTITY_ZOMBIE_VILLAGER_HURT: org$bukkit$Sound;
  static ENTITY_ZOMBIE_VILLAGER_STEP: org$bukkit$Sound;
  static EVENT_RAID_HORN: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_CHAIN: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_DIAMOND: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_ELYTRA: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_GENERIC: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_GOLD: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_IRON: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_LEATHER: org$bukkit$Sound;
  static ITEM_ARMOR_EQUIP_TURTLE: org$bukkit$Sound;
  static ITEM_AXE_STRIP: org$bukkit$Sound;
  static ITEM_BOOK_PAGE_TURN: org$bukkit$Sound;
  static ITEM_BOOK_PUT: org$bukkit$Sound;
  static ITEM_BOTTLE_EMPTY: org$bukkit$Sound;
  static ITEM_BOTTLE_FILL: org$bukkit$Sound;
  static ITEM_BOTTLE_FILL_DRAGONBREATH: org$bukkit$Sound;
  static ITEM_BUCKET_EMPTY: org$bukkit$Sound;
  static ITEM_BUCKET_EMPTY_FISH: org$bukkit$Sound;
  static ITEM_BUCKET_EMPTY_LAVA: org$bukkit$Sound;
  static ITEM_BUCKET_FILL: org$bukkit$Sound;
  static ITEM_BUCKET_FILL_FISH: org$bukkit$Sound;
  static ITEM_BUCKET_FILL_LAVA: org$bukkit$Sound;
  static ITEM_CHORUS_FRUIT_TELEPORT: org$bukkit$Sound;
  static ITEM_CROP_PLANT: org$bukkit$Sound;
  static ITEM_CROSSBOW_HIT: org$bukkit$Sound;
  static ITEM_CROSSBOW_LOADING_END: org$bukkit$Sound;
  static ITEM_CROSSBOW_LOADING_MIDDLE: org$bukkit$Sound;
  static ITEM_CROSSBOW_LOADING_START: org$bukkit$Sound;
  static ITEM_CROSSBOW_QUICK_CHARGE_1: org$bukkit$Sound;
  static ITEM_CROSSBOW_QUICK_CHARGE_2: org$bukkit$Sound;
  static ITEM_CROSSBOW_QUICK_CHARGE_3: org$bukkit$Sound;
  static ITEM_CROSSBOW_SHOOT: org$bukkit$Sound;
  static ITEM_ELYTRA_FLYING: org$bukkit$Sound;
  static ITEM_FIRECHARGE_USE: org$bukkit$Sound;
  static ITEM_FLINTANDSTEEL_USE: org$bukkit$Sound;
  static ITEM_HOE_TILL: org$bukkit$Sound;
  static ITEM_HONEY_BOTTLE_DRINK: org$bukkit$Sound;
  static ITEM_NETHER_WART_PLANT: org$bukkit$Sound;
  static ITEM_SHIELD_BLOCK: org$bukkit$Sound;
  static ITEM_SHIELD_BREAK: org$bukkit$Sound;
  static ITEM_SHOVEL_FLATTEN: org$bukkit$Sound;
  static ITEM_SWEET_BERRIES_PICK_FROM_BUSH: org$bukkit$Sound;
  static ITEM_TOTEM_USE: org$bukkit$Sound;
  static ITEM_TRIDENT_HIT: org$bukkit$Sound;
  static ITEM_TRIDENT_HIT_GROUND: org$bukkit$Sound;
  static ITEM_TRIDENT_RETURN: org$bukkit$Sound;
  static ITEM_TRIDENT_RIPTIDE_1: org$bukkit$Sound;
  static ITEM_TRIDENT_RIPTIDE_2: org$bukkit$Sound;
  static ITEM_TRIDENT_RIPTIDE_3: org$bukkit$Sound;
  static ITEM_TRIDENT_THROW: org$bukkit$Sound;
  static ITEM_TRIDENT_THUNDER: org$bukkit$Sound;
  static MUSIC_CREATIVE: org$bukkit$Sound;
  static MUSIC_CREDITS: org$bukkit$Sound;
  static MUSIC_DISC_11: org$bukkit$Sound;
  static MUSIC_DISC_13: org$bukkit$Sound;
  static MUSIC_DISC_BLOCKS: org$bukkit$Sound;
  static MUSIC_DISC_CAT: org$bukkit$Sound;
  static MUSIC_DISC_CHIRP: org$bukkit$Sound;
  static MUSIC_DISC_FAR: org$bukkit$Sound;
  static MUSIC_DISC_MALL: org$bukkit$Sound;
  static MUSIC_DISC_MELLOHI: org$bukkit$Sound;
  static MUSIC_DISC_STAL: org$bukkit$Sound;
  static MUSIC_DISC_STRAD: org$bukkit$Sound;
  static MUSIC_DISC_WAIT: org$bukkit$Sound;
  static MUSIC_DISC_WARD: org$bukkit$Sound;
  static MUSIC_DRAGON: org$bukkit$Sound;
  static MUSIC_END: org$bukkit$Sound;
  static MUSIC_GAME: org$bukkit$Sound;
  static MUSIC_MENU: org$bukkit$Sound;
  static MUSIC_NETHER: org$bukkit$Sound;
  static MUSIC_UNDER_WATER: org$bukkit$Sound;
  static UI_BUTTON_CLICK: org$bukkit$Sound;
  static UI_CARTOGRAPHY_TABLE_TAKE_RESULT: org$bukkit$Sound;
  static UI_LOOM_SELECT_PATTERN: org$bukkit$Sound;
  static UI_LOOM_TAKE_RESULT: org$bukkit$Sound;
  static UI_STONECUTTER_SELECT_RECIPE: org$bukkit$Sound;
  static UI_STONECUTTER_TAKE_RESULT: org$bukkit$Sound;
  static UI_TOAST_CHALLENGE_COMPLETE: org$bukkit$Sound;
  static UI_TOAST_IN: org$bukkit$Sound;
  static UI_TOAST_OUT: org$bukkit$Sound;
  static WEATHER_RAIN: org$bukkit$Sound;
  static WEATHER_RAIN_ABOVE: org$bukkit$Sound;
  static values(): JavaArray<org$bukkit$Sound>;
  static valueOf(arg0: string): org$bukkit$Sound;
}


declare interface $com$destroystokyo$paper$HeightmapType {}

declare class com$destroystokyo$paper$HeightmapType
  implements $com$destroystokyo$paper$HeightmapType {
  static LIGHT_BLOCKING: com$destroystokyo$paper$HeightmapType;
  static ANY: com$destroystokyo$paper$HeightmapType;
  static SOLID: com$destroystokyo$paper$HeightmapType;
  static SOLID_OR_LIQUID: com$destroystokyo$paper$HeightmapType;
  static SOLID_OR_LIQUID_NO_LEAVES: com$destroystokyo$paper$HeightmapType;
  static values(): JavaArray<com$destroystokyo$paper$HeightmapType>;
  static valueOf(arg0: string): com$destroystokyo$paper$HeightmapType;
}


declare interface $org$bukkit$HeightMap {}

declare class org$bukkit$HeightMap implements $org$bukkit$HeightMap {
  static MOTION_BLOCKING: org$bukkit$HeightMap;
  static MOTION_BLOCKING_NO_LEAVES: org$bukkit$HeightMap;
  static OCEAN_FLOOR: org$bukkit$HeightMap;
  static OCEAN_FLOOR_WG: org$bukkit$HeightMap;
  static WORLD_SURFACE: org$bukkit$HeightMap;
  static WORLD_SURFACE_WG: org$bukkit$HeightMap;
  static values(): JavaArray<org$bukkit$HeightMap>;
  static valueOf(arg0: string): org$bukkit$HeightMap;
}


declare interface $org$bukkit$World$ChunkLoadCallback {
  onLoad(arg0: org$bukkit$Chunk): void;
  accept(arg0: org$bukkit$Chunk): void;
  accept(arg0: any): void;
}

declare class org$bukkit$World$ChunkLoadCallback
  implements $org$bukkit$World$ChunkLoadCallback {
  onLoad(arg0: org$bukkit$Chunk): void;
  accept(arg0: org$bukkit$Chunk): void;
  accept(arg0: any): void;
}


declare interface $org$bukkit$entity$Item extends $org$bukkit$entity$Entity {
  getItemStack(): org$bukkit$inventory$ItemStack;
  setItemStack(arg0: org$bukkit$inventory$ItemStack): void;
  getPickupDelay(): number;
  setPickupDelay(arg0: number): void;
  canMobPickup(): boolean;
  setCanMobPickup(arg0: boolean): void;
  getOwner(): any /* java.util.UUID */;
  setOwner(arg0: any /* java.util.UUID */): void;
  getThrower(): any /* java.util.UUID */;
  setThrower(arg0: any /* java.util.UUID */): void;
}

declare class org$bukkit$entity$Item implements $org$bukkit$entity$Item {
  getItemStack(): org$bukkit$inventory$ItemStack;
  setItemStack(arg0: org$bukkit$inventory$ItemStack): void;
  getPickupDelay(): number;
  setPickupDelay(arg0: number): void;
  canMobPickup(): boolean;
  setCanMobPickup(arg0: boolean): void;
  getOwner(): any /* java.util.UUID */;
  setOwner(arg0: any /* java.util.UUID */): void;
  getThrower(): any /* java.util.UUID */;
  setThrower(arg0: any /* java.util.UUID */): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Arrow
  extends $org$bukkit$entity$AbstractArrow {
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): void;
}

declare class org$bukkit$entity$Arrow implements $org$bukkit$entity$Arrow {
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getKnockbackStrength(): number;
  setKnockbackStrength(arg0: number): void;
  getDamage(): number;
  setDamage(arg0: number): void;
  getPierceLevel(): number;
  setPierceLevel(arg0: number): void;
  isCritical(): boolean;
  setCritical(arg0: boolean): void;
  isInBlock(): boolean;
  getAttachedBlock(): org$bukkit$block$Block;
  getPickupStatus(): org$bukkit$entity$AbstractArrow$PickupStatus;
  setPickupStatus(arg0: org$bukkit$entity$AbstractArrow$PickupStatus): void;
  isShotFromCrossbow(): boolean;
  setShotFromCrossbow(arg0: boolean): void;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getPickupRule(): org$bukkit$entity$AbstractArrow$PickupRule;
  setPickupRule(arg0: org$bukkit$entity$AbstractArrow$PickupRule): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$AbstractArrow
  extends $org$bukkit$entity$Projectile {
  getKnockbackStrength(): number;
  setKnockbackStrength(arg0: number): void;
  getDamage(): number;
  setDamage(arg0: number): void;
  getPierceLevel(): number;
  setPierceLevel(arg0: number): void;
  isCritical(): boolean;
  setCritical(arg0: boolean): void;
  isInBlock(): boolean;
  getAttachedBlock(): org$bukkit$block$Block;
  getPickupStatus(): org$bukkit$entity$AbstractArrow$PickupStatus;
  setPickupStatus(arg0: org$bukkit$entity$AbstractArrow$PickupStatus): void;
  isShotFromCrossbow(): boolean;
  setShotFromCrossbow(arg0: boolean): void;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getPickupRule(): org$bukkit$entity$AbstractArrow$PickupRule;
  setPickupRule(arg0: org$bukkit$entity$AbstractArrow$PickupRule): void;
}

declare class org$bukkit$entity$AbstractArrow
  implements $org$bukkit$entity$AbstractArrow {
  getKnockbackStrength(): number;
  setKnockbackStrength(arg0: number): void;
  getDamage(): number;
  setDamage(arg0: number): void;
  getPierceLevel(): number;
  setPierceLevel(arg0: number): void;
  isCritical(): boolean;
  setCritical(arg0: boolean): void;
  isInBlock(): boolean;
  getAttachedBlock(): org$bukkit$block$Block;
  getPickupStatus(): org$bukkit$entity$AbstractArrow$PickupStatus;
  setPickupStatus(arg0: org$bukkit$entity$AbstractArrow$PickupStatus): void;
  isShotFromCrossbow(): boolean;
  setShotFromCrossbow(arg0: boolean): void;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getPickupRule(): org$bukkit$entity$AbstractArrow$PickupRule;
  setPickupRule(arg0: org$bukkit$entity$AbstractArrow$PickupRule): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Projectile
  extends $org$bukkit$entity$Entity {
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
}

declare class org$bukkit$entity$Projectile
  implements $org$bukkit$entity$Projectile {
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$projectiles$ProjectileSource {
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}

declare class org$bukkit$projectiles$ProjectileSource
  implements $org$bukkit$projectiles$ProjectileSource {
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$AbstractArrow$PickupStatus {}

declare class org$bukkit$entity$AbstractArrow$PickupStatus
  implements $org$bukkit$entity$AbstractArrow$PickupStatus {
  static DISALLOWED: org$bukkit$entity$AbstractArrow$PickupStatus;
  static ALLOWED: org$bukkit$entity$AbstractArrow$PickupStatus;
  static CREATIVE_ONLY: org$bukkit$entity$AbstractArrow$PickupStatus;
  static values(): JavaArray<org$bukkit$entity$AbstractArrow$PickupStatus>;
  static valueOf(arg0: string): org$bukkit$entity$AbstractArrow$PickupStatus;
}


declare interface $org$bukkit$entity$AbstractArrow$PickupRule {}

declare class org$bukkit$entity$AbstractArrow$PickupRule
  implements $org$bukkit$entity$AbstractArrow$PickupRule {
  static DISALLOWED: org$bukkit$entity$AbstractArrow$PickupRule;
  static ALLOWED: org$bukkit$entity$AbstractArrow$PickupRule;
  static CREATIVE_ONLY: org$bukkit$entity$AbstractArrow$PickupRule;
  static values(): JavaArray<org$bukkit$entity$AbstractArrow$PickupRule>;
  static valueOf(arg0: string): org$bukkit$entity$AbstractArrow$PickupRule;
}


declare interface $org$bukkit$potion$PotionData {
  getType(): org$bukkit$potion$PotionType;
  isUpgraded(): boolean;
  isExtended(): boolean;
  hashCode(): number;
  equals(arg0: any): boolean;
}

declare class org$bukkit$potion$PotionData
  implements $org$bukkit$potion$PotionData {
  constructor(arg0: org$bukkit$potion$PotionType, arg1: boolean, arg2: boolean);
  constructor(arg0: org$bukkit$potion$PotionType);
  getType(): org$bukkit$potion$PotionType;
  isUpgraded(): boolean;
  isExtended(): boolean;
  hashCode(): number;
  equals(arg0: any): boolean;
}


declare interface $org$bukkit$potion$PotionType {
  getEffectType(): org$bukkit$potion$PotionEffectType;
  isInstant(): boolean;
  isUpgradeable(): boolean;
  isExtendable(): boolean;
  getMaxLevel(): number;
}

declare class org$bukkit$potion$PotionType
  implements $org$bukkit$potion$PotionType {
  static UNCRAFTABLE: org$bukkit$potion$PotionType;
  static WATER: org$bukkit$potion$PotionType;
  static MUNDANE: org$bukkit$potion$PotionType;
  static THICK: org$bukkit$potion$PotionType;
  static AWKWARD: org$bukkit$potion$PotionType;
  static NIGHT_VISION: org$bukkit$potion$PotionType;
  static INVISIBILITY: org$bukkit$potion$PotionType;
  static JUMP: org$bukkit$potion$PotionType;
  static FIRE_RESISTANCE: org$bukkit$potion$PotionType;
  static SPEED: org$bukkit$potion$PotionType;
  static SLOWNESS: org$bukkit$potion$PotionType;
  static WATER_BREATHING: org$bukkit$potion$PotionType;
  static INSTANT_HEAL: org$bukkit$potion$PotionType;
  static INSTANT_DAMAGE: org$bukkit$potion$PotionType;
  static POISON: org$bukkit$potion$PotionType;
  static REGEN: org$bukkit$potion$PotionType;
  static STRENGTH: org$bukkit$potion$PotionType;
  static WEAKNESS: org$bukkit$potion$PotionType;
  static LUCK: org$bukkit$potion$PotionType;
  static TURTLE_MASTER: org$bukkit$potion$PotionType;
  static SLOW_FALLING: org$bukkit$potion$PotionType;
  static values(): JavaArray<org$bukkit$potion$PotionType>;
  static valueOf(arg0: string): org$bukkit$potion$PotionType;
  getEffectType(): org$bukkit$potion$PotionEffectType;
  isInstant(): boolean;
  isUpgradeable(): boolean;
  isExtendable(): boolean;
  getMaxLevel(): number;
  static getByEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionType;
}


declare interface $org$bukkit$potion$PotionEffectType {
  createEffect(arg0: number, arg1: number): org$bukkit$potion$PotionEffect;
  getDurationModifier(): number;
  getId(): number;
  getName(): string;
  isInstant(): boolean;
  getColor(): org$bukkit$Color;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}

declare class org$bukkit$potion$PotionEffectType
  implements $org$bukkit$potion$PotionEffectType {
  static SPEED: org$bukkit$potion$PotionEffectType;
  static SLOW: org$bukkit$potion$PotionEffectType;
  static FAST_DIGGING: org$bukkit$potion$PotionEffectType;
  static SLOW_DIGGING: org$bukkit$potion$PotionEffectType;
  static INCREASE_DAMAGE: org$bukkit$potion$PotionEffectType;
  static HEAL: org$bukkit$potion$PotionEffectType;
  static HARM: org$bukkit$potion$PotionEffectType;
  static JUMP: org$bukkit$potion$PotionEffectType;
  static CONFUSION: org$bukkit$potion$PotionEffectType;
  static REGENERATION: org$bukkit$potion$PotionEffectType;
  static DAMAGE_RESISTANCE: org$bukkit$potion$PotionEffectType;
  static FIRE_RESISTANCE: org$bukkit$potion$PotionEffectType;
  static WATER_BREATHING: org$bukkit$potion$PotionEffectType;
  static INVISIBILITY: org$bukkit$potion$PotionEffectType;
  static BLINDNESS: org$bukkit$potion$PotionEffectType;
  static NIGHT_VISION: org$bukkit$potion$PotionEffectType;
  static HUNGER: org$bukkit$potion$PotionEffectType;
  static WEAKNESS: org$bukkit$potion$PotionEffectType;
  static POISON: org$bukkit$potion$PotionEffectType;
  static WITHER: org$bukkit$potion$PotionEffectType;
  static HEALTH_BOOST: org$bukkit$potion$PotionEffectType;
  static ABSORPTION: org$bukkit$potion$PotionEffectType;
  static SATURATION: org$bukkit$potion$PotionEffectType;
  static GLOWING: org$bukkit$potion$PotionEffectType;
  static LEVITATION: org$bukkit$potion$PotionEffectType;
  static LUCK: org$bukkit$potion$PotionEffectType;
  static UNLUCK: org$bukkit$potion$PotionEffectType;
  static SLOW_FALLING: org$bukkit$potion$PotionEffectType;
  static CONDUIT_POWER: org$bukkit$potion$PotionEffectType;
  static DOLPHINS_GRACE: org$bukkit$potion$PotionEffectType;
  static BAD_OMEN: org$bukkit$potion$PotionEffectType;
  static HERO_OF_THE_VILLAGE: org$bukkit$potion$PotionEffectType;
  constructor(arg0: number);
  createEffect(arg0: number, arg1: number): org$bukkit$potion$PotionEffect;
  getDurationModifier(): number;
  getId(): number;
  getName(): string;
  isInstant(): boolean;
  getColor(): org$bukkit$Color;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  static getById(arg0: number): org$bukkit$potion$PotionEffectType;
  static getByName(arg0: string): org$bukkit$potion$PotionEffectType;
  static registerPotionEffectType(
    arg0: org$bukkit$potion$PotionEffectType
  ): void;
  static stopAcceptingRegistrations(): void;
  static values(): JavaArray<org$bukkit$potion$PotionEffectType>;
}


declare interface $org$bukkit$potion$PotionEffect
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  withType(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  withDuration(arg0: number): org$bukkit$potion$PotionEffect;
  withAmplifier(arg0: number): org$bukkit$potion$PotionEffect;
  withAmbient(arg0: boolean): org$bukkit$potion$PotionEffect;
  withParticles(arg0: boolean): org$bukkit$potion$PotionEffect;
  withIcon(arg0: boolean): org$bukkit$potion$PotionEffect;
  serialize(): any /* java.util.Map */;
  apply(arg0: org$bukkit$entity$LivingEntity): boolean;
  equals(arg0: any): boolean;
  getAmplifier(): number;
  getDuration(): number;
  getType(): org$bukkit$potion$PotionEffectType;
  isAmbient(): boolean;
  hasParticles(): boolean;
  getColor(): org$bukkit$Color;
  hasIcon(): boolean;
  hashCode(): number;
  toString(): string;
}

declare class org$bukkit$potion$PotionEffect
  implements $org$bukkit$potion$PotionEffect {
  constructor(
    arg0: org$bukkit$potion$PotionEffectType,
    arg1: number,
    arg2: number,
    arg3: boolean,
    arg4: boolean,
    arg5: boolean
  );
  constructor(
    arg0: org$bukkit$potion$PotionEffectType,
    arg1: number,
    arg2: number,
    arg3: boolean,
    arg4: boolean
  );
  constructor(
    arg0: org$bukkit$potion$PotionEffectType,
    arg1: number,
    arg2: number,
    arg3: boolean
  );
  constructor(
    arg0: org$bukkit$potion$PotionEffectType,
    arg1: number,
    arg2: number
  );
  constructor(arg0: any /* java.util.Map */);
  withType(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  withDuration(arg0: number): org$bukkit$potion$PotionEffect;
  withAmplifier(arg0: number): org$bukkit$potion$PotionEffect;
  withAmbient(arg0: boolean): org$bukkit$potion$PotionEffect;
  withParticles(arg0: boolean): org$bukkit$potion$PotionEffect;
  withIcon(arg0: boolean): org$bukkit$potion$PotionEffect;
  serialize(): any /* java.util.Map */;
  apply(arg0: org$bukkit$entity$LivingEntity): boolean;
  equals(arg0: any): boolean;
  getAmplifier(): number;
  getDuration(): number;
  getType(): org$bukkit$potion$PotionEffectType;
  isAmbient(): boolean;
  hasParticles(): boolean;
  getColor(): org$bukkit$Color;
  hasIcon(): boolean;
  hashCode(): number;
  toString(): string;
}


declare interface $org$bukkit$entity$LivingEntity
  extends $org$bukkit$attribute$Attributable,
    $org$bukkit$entity$Damageable,
    $org$bukkit$projectiles$ProjectileSource {
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
}

declare class org$bukkit$entity$LivingEntity
  implements $org$bukkit$entity$LivingEntity {
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$attribute$Attributable {
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
}

declare class org$bukkit$attribute$Attributable
  implements $org$bukkit$attribute$Attributable {
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
}


declare interface $org$bukkit$attribute$AttributeInstance {
  getAttribute(): org$bukkit$attribute$Attribute;
  getBaseValue(): number;
  setBaseValue(arg0: number): void;
  getModifiers(): java$util$Collection;
  addModifier(arg0: org$bukkit$attribute$AttributeModifier): void;
  removeModifier(arg0: org$bukkit$attribute$AttributeModifier): void;
  getValue(): number;
  getDefaultValue(): number;
}

declare class org$bukkit$attribute$AttributeInstance
  implements $org$bukkit$attribute$AttributeInstance {
  getAttribute(): org$bukkit$attribute$Attribute;
  getBaseValue(): number;
  setBaseValue(arg0: number): void;
  getModifiers(): java$util$Collection;
  addModifier(arg0: org$bukkit$attribute$AttributeModifier): void;
  removeModifier(arg0: org$bukkit$attribute$AttributeModifier): void;
  getValue(): number;
  getDefaultValue(): number;
}


declare interface $org$bukkit$entity$Damageable
  extends $org$bukkit$entity$Entity {
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
}

declare class org$bukkit$entity$Damageable
  implements $org$bukkit$entity$Damageable {
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $com$destroystokyo$paper$block$TargetBlockInfo$FluidMode {}

declare class com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  implements $com$destroystokyo$paper$block$TargetBlockInfo$FluidMode {
  static NEVER: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode;
  static SOURCE_ONLY: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode;
  static ALWAYS: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode;
  static values(): JavaArray<
    com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$block$TargetBlockInfo$FluidMode;
}


declare interface $com$destroystokyo$paper$block$TargetBlockInfo {
  getBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  getRelativeBlock(): org$bukkit$block$Block;
}

declare class com$destroystokyo$paper$block$TargetBlockInfo
  implements $com$destroystokyo$paper$block$TargetBlockInfo {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockFace);
  getBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  getRelativeBlock(): org$bukkit$block$Block;
}


declare interface $com$destroystokyo$paper$entity$TargetEntityInfo {
  getEntity(): org$bukkit$entity$Entity;
  getHitVector(): org$bukkit$util$Vector;
}

declare class com$destroystokyo$paper$entity$TargetEntityInfo
  implements $com$destroystokyo$paper$entity$TargetEntityInfo {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$util$Vector);
  getEntity(): org$bukkit$entity$Entity;
  getHitVector(): org$bukkit$util$Vector;
}


declare interface $org$bukkit$inventory$EntityEquipment {
  setItem(
    arg0: org$bukkit$inventory$EquipmentSlot,
    arg1: org$bukkit$inventory$ItemStack
  ): void;
  getItem(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): org$bukkit$inventory$ItemStack;
  getItemInMainHand(): org$bukkit$inventory$ItemStack;
  setItemInMainHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInOffHand(): org$bukkit$inventory$ItemStack;
  setItemInOffHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getHelmet(): org$bukkit$inventory$ItemStack;
  setHelmet(arg0: org$bukkit$inventory$ItemStack): void;
  getChestplate(): org$bukkit$inventory$ItemStack;
  setChestplate(arg0: org$bukkit$inventory$ItemStack): void;
  getLeggings(): org$bukkit$inventory$ItemStack;
  setLeggings(arg0: org$bukkit$inventory$ItemStack): void;
  getBoots(): org$bukkit$inventory$ItemStack;
  setBoots(arg0: org$bukkit$inventory$ItemStack): void;
  getArmorContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setArmorContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  clear(): void;
  getItemInHandDropChance(): number;
  setItemInHandDropChance(arg0: number): void;
  getItemInMainHandDropChance(): number;
  setItemInMainHandDropChance(arg0: number): void;
  getItemInOffHandDropChance(): number;
  setItemInOffHandDropChance(arg0: number): void;
  getHelmetDropChance(): number;
  setHelmetDropChance(arg0: number): void;
  getChestplateDropChance(): number;
  setChestplateDropChance(arg0: number): void;
  getLeggingsDropChance(): number;
  setLeggingsDropChance(arg0: number): void;
  getBootsDropChance(): number;
  setBootsDropChance(arg0: number): void;
  getHolder(): org$bukkit$entity$Entity;
}

declare class org$bukkit$inventory$EntityEquipment
  implements $org$bukkit$inventory$EntityEquipment {
  setItem(
    arg0: org$bukkit$inventory$EquipmentSlot,
    arg1: org$bukkit$inventory$ItemStack
  ): void;
  getItem(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): org$bukkit$inventory$ItemStack;
  getItemInMainHand(): org$bukkit$inventory$ItemStack;
  setItemInMainHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInOffHand(): org$bukkit$inventory$ItemStack;
  setItemInOffHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getHelmet(): org$bukkit$inventory$ItemStack;
  setHelmet(arg0: org$bukkit$inventory$ItemStack): void;
  getChestplate(): org$bukkit$inventory$ItemStack;
  setChestplate(arg0: org$bukkit$inventory$ItemStack): void;
  getLeggings(): org$bukkit$inventory$ItemStack;
  setLeggings(arg0: org$bukkit$inventory$ItemStack): void;
  getBoots(): org$bukkit$inventory$ItemStack;
  setBoots(arg0: org$bukkit$inventory$ItemStack): void;
  getArmorContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setArmorContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  clear(): void;
  getItemInHandDropChance(): number;
  setItemInHandDropChance(arg0: number): void;
  getItemInMainHandDropChance(): number;
  setItemInMainHandDropChance(arg0: number): void;
  getItemInOffHandDropChance(): number;
  setItemInOffHandDropChance(arg0: number): void;
  getHelmetDropChance(): number;
  setHelmetDropChance(arg0: number): void;
  getChestplateDropChance(): number;
  setChestplateDropChance(arg0: number): void;
  getLeggingsDropChance(): number;
  setLeggingsDropChance(arg0: number): void;
  getBootsDropChance(): number;
  setBootsDropChance(arg0: number): void;
  getHolder(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$memory$MemoryKey
  extends $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
  getMemoryClass(): any /* java.lang.Class */;
}

declare class org$bukkit$entity$memory$MemoryKey
  implements $org$bukkit$entity$memory$MemoryKey {
  static HOME: org$bukkit$entity$memory$MemoryKey;
  static MEETING_POINT: org$bukkit$entity$memory$MemoryKey;
  static JOB_SITE: org$bukkit$entity$memory$MemoryKey;
  static LAST_SLEPT: org$bukkit$entity$memory$MemoryKey;
  static LAST_WOKEN: org$bukkit$entity$memory$MemoryKey;
  static LAST_WORKED_AT_POI: org$bukkit$entity$memory$MemoryKey;
  getKey(): org$bukkit$NamespacedKey;
  getMemoryClass(): any /* java.lang.Class */;
  static getByKey(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$entity$memory$MemoryKey;
  static values(): any /* java.util.Set */;
}


declare interface $org$bukkit$Color
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  getRed(): number;
  setRed(arg0: number): org$bukkit$Color;
  getGreen(): number;
  setGreen(arg0: number): org$bukkit$Color;
  getBlue(): number;
  setBlue(arg0: number): org$bukkit$Color;
  asRGB(): number;
  asBGR(): number;
  mixDyes(arg0: JavaArray<org$bukkit$DyeColor>): org$bukkit$Color;
  mixColors(arg0: JavaArray<org$bukkit$Color>): org$bukkit$Color;
  equals(arg0: any): boolean;
  hashCode(): number;
  serialize(): any /* java.util.Map */;
  toString(): string;
}

declare class org$bukkit$Color implements $org$bukkit$Color {
  static WHITE: org$bukkit$Color;
  static SILVER: org$bukkit$Color;
  static GRAY: org$bukkit$Color;
  static BLACK: org$bukkit$Color;
  static RED: org$bukkit$Color;
  static MAROON: org$bukkit$Color;
  static YELLOW: org$bukkit$Color;
  static OLIVE: org$bukkit$Color;
  static LIME: org$bukkit$Color;
  static GREEN: org$bukkit$Color;
  static AQUA: org$bukkit$Color;
  static TEAL: org$bukkit$Color;
  static BLUE: org$bukkit$Color;
  static NAVY: org$bukkit$Color;
  static FUCHSIA: org$bukkit$Color;
  static PURPLE: org$bukkit$Color;
  static ORANGE: org$bukkit$Color;
  static fromRGB(arg0: number, arg1: number, arg2: number): org$bukkit$Color;
  static fromBGR(arg0: number, arg1: number, arg2: number): org$bukkit$Color;
  static fromRGB(arg0: number): org$bukkit$Color;
  static fromBGR(arg0: number): org$bukkit$Color;
  getRed(): number;
  setRed(arg0: number): org$bukkit$Color;
  getGreen(): number;
  setGreen(arg0: number): org$bukkit$Color;
  getBlue(): number;
  setBlue(arg0: number): org$bukkit$Color;
  asRGB(): number;
  asBGR(): number;
  mixDyes(arg0: JavaArray<org$bukkit$DyeColor>): org$bukkit$Color;
  mixColors(arg0: JavaArray<org$bukkit$Color>): org$bukkit$Color;
  equals(arg0: any): boolean;
  hashCode(): number;
  serialize(): any /* java.util.Map */;
  static deserialize(arg0: any /* java.util.Map */): org$bukkit$Color;
  toString(): string;
}


declare interface $org$bukkit$DyeColor {
  getWoolData(): Buffer;
  getDyeData(): Buffer;
  getColor(): org$bukkit$Color;
  getFireworkColor(): org$bukkit$Color;
}

declare class org$bukkit$DyeColor implements $org$bukkit$DyeColor {
  static WHITE: org$bukkit$DyeColor;
  static ORANGE: org$bukkit$DyeColor;
  static MAGENTA: org$bukkit$DyeColor;
  static LIGHT_BLUE: org$bukkit$DyeColor;
  static YELLOW: org$bukkit$DyeColor;
  static LIME: org$bukkit$DyeColor;
  static PINK: org$bukkit$DyeColor;
  static GRAY: org$bukkit$DyeColor;
  static LIGHT_GRAY: org$bukkit$DyeColor;
  static CYAN: org$bukkit$DyeColor;
  static PURPLE: org$bukkit$DyeColor;
  static BLUE: org$bukkit$DyeColor;
  static BROWN: org$bukkit$DyeColor;
  static GREEN: org$bukkit$DyeColor;
  static RED: org$bukkit$DyeColor;
  static BLACK: org$bukkit$DyeColor;
  static values(): JavaArray<org$bukkit$DyeColor>;
  static valueOf(arg0: string): org$bukkit$DyeColor;
  getWoolData(): Buffer;
  getDyeData(): Buffer;
  getColor(): org$bukkit$Color;
  getFireworkColor(): org$bukkit$Color;
  static getByWoolData(arg0: Buffer): org$bukkit$DyeColor;
  static getByDyeData(arg0: Buffer): org$bukkit$DyeColor;
  static getByColor(arg0: org$bukkit$Color): org$bukkit$DyeColor;
  static getByFireworkColor(arg0: org$bukkit$Color): org$bukkit$DyeColor;
  static legacyValueOf(arg0: string): org$bukkit$DyeColor;
}


declare interface $org$bukkit$TreeType {}

declare class org$bukkit$TreeType implements $org$bukkit$TreeType {
  static TREE: org$bukkit$TreeType;
  static BIG_TREE: org$bukkit$TreeType;
  static REDWOOD: org$bukkit$TreeType;
  static TALL_REDWOOD: org$bukkit$TreeType;
  static BIRCH: org$bukkit$TreeType;
  static JUNGLE: org$bukkit$TreeType;
  static SMALL_JUNGLE: org$bukkit$TreeType;
  static COCOA_TREE: org$bukkit$TreeType;
  static JUNGLE_BUSH: org$bukkit$TreeType;
  static RED_MUSHROOM: org$bukkit$TreeType;
  static BROWN_MUSHROOM: org$bukkit$TreeType;
  static SWAMP: org$bukkit$TreeType;
  static ACACIA: org$bukkit$TreeType;
  static DARK_OAK: org$bukkit$TreeType;
  static MEGA_REDWOOD: org$bukkit$TreeType;
  static TALL_BIRCH: org$bukkit$TreeType;
  static CHORUS_PLANT: org$bukkit$TreeType;
  static values(): JavaArray<org$bukkit$TreeType>;
  static valueOf(arg0: string): org$bukkit$TreeType;
}


declare interface $org$bukkit$BlockChangeDelegate {
  setBlockData(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$data$BlockData
  ): boolean;
  getBlockData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$block$data$BlockData;
  getHeight(): number;
  isEmpty(arg0: number, arg1: number, arg2: number): boolean;
}

declare class org$bukkit$BlockChangeDelegate
  implements $org$bukkit$BlockChangeDelegate {
  setBlockData(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$data$BlockData
  ): boolean;
  getBlockData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$block$data$BlockData;
  getHeight(): number;
  isEmpty(arg0: number, arg1: number, arg2: number): boolean;
}


declare interface $org$bukkit$entity$LightningStrike
  extends $org$bukkit$entity$Entity {
  isEffect(): boolean;
  spigot(): org$bukkit$entity$LightningStrike$Spigot;
  spigot(): org$bukkit$entity$Entity$Spigot;
  spigot(): org$bukkit$command$CommandSender$Spigot;
}

declare class org$bukkit$entity$LightningStrike
  implements $org$bukkit$entity$LightningStrike {
  isEffect(): boolean;
  spigot(): org$bukkit$entity$LightningStrike$Spigot;
  spigot(): org$bukkit$entity$Entity$Spigot;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$LightningStrike$Spigot {
  isSilent(): boolean;
}

declare class org$bukkit$entity$LightningStrike$Spigot
  implements $org$bukkit$entity$LightningStrike$Spigot {
  constructor();
  isSilent(): boolean;
}


declare interface $org$bukkit$World$Environment {
  getId(): number;
}

declare class org$bukkit$World$Environment
  implements $org$bukkit$World$Environment {
  static NORMAL: org$bukkit$World$Environment;
  static NETHER: org$bukkit$World$Environment;
  static THE_END: org$bukkit$World$Environment;
  static values(): JavaArray<org$bukkit$World$Environment>;
  static valueOf(arg0: string): org$bukkit$World$Environment;
  getId(): number;
  static getEnvironment(arg0: number): org$bukkit$World$Environment;
}


declare interface $org$bukkit$generator$ChunkGenerator {
  generateChunkData(
    arg0: org$bukkit$World,
    arg1: any /* java.util.Random */,
    arg2: number,
    arg3: number,
    arg4: org$bukkit$generator$ChunkGenerator$BiomeGrid
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  createChunkData(
    arg0: org$bukkit$World
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  canSpawn(arg0: org$bukkit$World, arg1: number, arg2: number): boolean;
  getDefaultPopulators(arg0: org$bukkit$World): any /* java.util.List */;
  getFixedSpawnLocation(
    arg0: org$bukkit$World,
    arg1: any /* java.util.Random */
  ): org$bukkit$Location;
  isParallelCapable(): boolean;
  shouldGenerateCaves(): boolean;
  shouldGenerateDecorations(): boolean;
  shouldGenerateMobs(): boolean;
  shouldGenerateStructures(): boolean;
}

declare class org$bukkit$generator$ChunkGenerator
  implements $org$bukkit$generator$ChunkGenerator {
  constructor();
  generateChunkData(
    arg0: org$bukkit$World,
    arg1: any /* java.util.Random */,
    arg2: number,
    arg3: number,
    arg4: org$bukkit$generator$ChunkGenerator$BiomeGrid
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  createChunkData(
    arg0: org$bukkit$World
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  canSpawn(arg0: org$bukkit$World, arg1: number, arg2: number): boolean;
  getDefaultPopulators(arg0: org$bukkit$World): any /* java.util.List */;
  getFixedSpawnLocation(
    arg0: org$bukkit$World,
    arg1: any /* java.util.Random */
  ): org$bukkit$Location;
  isParallelCapable(): boolean;
  shouldGenerateCaves(): boolean;
  shouldGenerateDecorations(): boolean;
  shouldGenerateMobs(): boolean;
  shouldGenerateStructures(): boolean;
}


declare interface $org$bukkit$generator$ChunkGenerator$ChunkData {
  getMaxHeight(): number;
  setBlock(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$Material
  ): void;
  setBlock(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$material$MaterialData
  ): void;
  setBlock(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$data$BlockData
  ): void;
  setRegion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: org$bukkit$Material
  ): void;
  setRegion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: org$bukkit$material$MaterialData
  ): void;
  setRegion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: org$bukkit$block$data$BlockData
  ): void;
  getType(arg0: number, arg1: number, arg2: number): org$bukkit$Material;
  getTypeAndData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$material$MaterialData;
  getBlockData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$block$data$BlockData;
  getData(arg0: number, arg1: number, arg2: number): Buffer;
}

declare class org$bukkit$generator$ChunkGenerator$ChunkData
  implements $org$bukkit$generator$ChunkGenerator$ChunkData {
  getMaxHeight(): number;
  setBlock(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$Material
  ): void;
  setBlock(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$material$MaterialData
  ): void;
  setBlock(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$data$BlockData
  ): void;
  setRegion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: org$bukkit$Material
  ): void;
  setRegion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: org$bukkit$material$MaterialData
  ): void;
  setRegion(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: org$bukkit$block$data$BlockData
  ): void;
  getType(arg0: number, arg1: number, arg2: number): org$bukkit$Material;
  getTypeAndData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$material$MaterialData;
  getBlockData(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$block$data$BlockData;
  getData(arg0: number, arg1: number, arg2: number): Buffer;
}


declare interface $org$bukkit$generator$ChunkGenerator$BiomeGrid {
  getBiome(arg0: number, arg1: number): org$bukkit$block$Biome;
  getBiome(arg0: number, arg1: number, arg2: number): org$bukkit$block$Biome;
  setBiome(arg0: number, arg1: number, arg2: org$bukkit$block$Biome): void;
  setBiome(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$Biome
  ): void;
}

declare class org$bukkit$generator$ChunkGenerator$BiomeGrid
  implements $org$bukkit$generator$ChunkGenerator$BiomeGrid {
  getBiome(arg0: number, arg1: number): org$bukkit$block$Biome;
  getBiome(arg0: number, arg1: number, arg2: number): org$bukkit$block$Biome;
  setBiome(arg0: number, arg1: number, arg2: org$bukkit$block$Biome): void;
  setBiome(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$block$Biome
  ): void;
}


declare interface $org$bukkit$util$Consumer {
  accept(arg0: any): void;
}

declare class org$bukkit$util$Consumer implements $org$bukkit$util$Consumer {
  accept(arg0: any): void;
}


declare interface $org$bukkit$entity$FallingBlock
  extends $org$bukkit$entity$Entity {
  getMaterial(): org$bukkit$Material;
  getBlockData(): org$bukkit$block$data$BlockData;
  getDropItem(): boolean;
  setDropItem(arg0: boolean): void;
  canHurtEntities(): boolean;
  setHurtEntities(arg0: boolean): void;
  getSourceLoc(): org$bukkit$Location;
}

declare class org$bukkit$entity$FallingBlock
  implements $org$bukkit$entity$FallingBlock {
  getMaterial(): org$bukkit$Material;
  getBlockData(): org$bukkit$block$data$BlockData;
  getDropItem(): boolean;
  setDropItem(arg0: boolean): void;
  canHurtEntities(): boolean;
  setHurtEntities(arg0: boolean): void;
  getSourceLoc(): org$bukkit$Location;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$Effect {
  getId(): number;
  getType(): org$bukkit$Effect$Type;
  getData(): any /* java.lang.Class */;
}

declare class org$bukkit$Effect implements $org$bukkit$Effect {
  static CLICK2: org$bukkit$Effect;
  static CLICK1: org$bukkit$Effect;
  static BOW_FIRE: org$bukkit$Effect;
  static DOOR_TOGGLE: org$bukkit$Effect;
  static IRON_DOOR_TOGGLE: org$bukkit$Effect;
  static TRAPDOOR_TOGGLE: org$bukkit$Effect;
  static IRON_TRAPDOOR_TOGGLE: org$bukkit$Effect;
  static FENCE_GATE_TOGGLE: org$bukkit$Effect;
  static DOOR_CLOSE: org$bukkit$Effect;
  static IRON_DOOR_CLOSE: org$bukkit$Effect;
  static TRAPDOOR_CLOSE: org$bukkit$Effect;
  static IRON_TRAPDOOR_CLOSE: org$bukkit$Effect;
  static FENCE_GATE_CLOSE: org$bukkit$Effect;
  static EXTINGUISH: org$bukkit$Effect;
  static RECORD_PLAY: org$bukkit$Effect;
  static GHAST_SHRIEK: org$bukkit$Effect;
  static GHAST_SHOOT: org$bukkit$Effect;
  static BLAZE_SHOOT: org$bukkit$Effect;
  static ZOMBIE_CHEW_WOODEN_DOOR: org$bukkit$Effect;
  static ZOMBIE_CHEW_IRON_DOOR: org$bukkit$Effect;
  static ZOMBIE_DESTROY_DOOR: org$bukkit$Effect;
  static SMOKE: org$bukkit$Effect;
  static STEP_SOUND: org$bukkit$Effect;
  static POTION_BREAK: org$bukkit$Effect;
  static INSTANT_POTION_BREAK: org$bukkit$Effect;
  static ENDER_SIGNAL: org$bukkit$Effect;
  static MOBSPAWNER_FLAMES: org$bukkit$Effect;
  static BREWING_STAND_BREW: org$bukkit$Effect;
  static CHORUS_FLOWER_GROW: org$bukkit$Effect;
  static CHORUS_FLOWER_DEATH: org$bukkit$Effect;
  static PORTAL_TRAVEL: org$bukkit$Effect;
  static ENDEREYE_LAUNCH: org$bukkit$Effect;
  static FIREWORK_SHOOT: org$bukkit$Effect;
  static VILLAGER_PLANT_GROW: org$bukkit$Effect;
  static DRAGON_BREATH: org$bukkit$Effect;
  static ANVIL_BREAK: org$bukkit$Effect;
  static ANVIL_USE: org$bukkit$Effect;
  static ANVIL_LAND: org$bukkit$Effect;
  static ENDERDRAGON_SHOOT: org$bukkit$Effect;
  static WITHER_BREAK_BLOCK: org$bukkit$Effect;
  static WITHER_SHOOT: org$bukkit$Effect;
  static ZOMBIE_INFECT: org$bukkit$Effect;
  static ZOMBIE_CONVERTED_VILLAGER: org$bukkit$Effect;
  static BAT_TAKEOFF: org$bukkit$Effect;
  static END_GATEWAY_SPAWN: org$bukkit$Effect;
  static ENDERDRAGON_GROWL: org$bukkit$Effect;
  static values(): JavaArray<org$bukkit$Effect>;
  static valueOf(arg0: string): org$bukkit$Effect;
  getId(): number;
  getType(): org$bukkit$Effect$Type;
  getData(): any /* java.lang.Class */;
  static getById(arg0: number): org$bukkit$Effect;
}


declare interface $org$bukkit$Effect$Type {}

declare class org$bukkit$Effect$Type implements $org$bukkit$Effect$Type {
  static SOUND: org$bukkit$Effect$Type;
  static VISUAL: org$bukkit$Effect$Type;
  static values(): JavaArray<org$bukkit$Effect$Type>;
  static valueOf(arg0: string): org$bukkit$Effect$Type;
}


declare interface $org$bukkit$Difficulty {
  getValue(): number;
}

declare class org$bukkit$Difficulty implements $org$bukkit$Difficulty {
  static PEACEFUL: org$bukkit$Difficulty;
  static EASY: org$bukkit$Difficulty;
  static NORMAL: org$bukkit$Difficulty;
  static HARD: org$bukkit$Difficulty;
  static values(): JavaArray<org$bukkit$Difficulty>;
  static valueOf(arg0: string): org$bukkit$Difficulty;
  getValue(): number;
  static getByValue(arg0: number): org$bukkit$Difficulty;
}


declare interface $org$bukkit$WorldType {
  getName(): string;
}

declare class org$bukkit$WorldType implements $org$bukkit$WorldType {
  static NORMAL: org$bukkit$WorldType;
  static FLAT: org$bukkit$WorldType;
  static VERSION_1_1: org$bukkit$WorldType;
  static LARGE_BIOMES: org$bukkit$WorldType;
  static AMPLIFIED: org$bukkit$WorldType;
  static CUSTOMIZED: org$bukkit$WorldType;
  static BUFFET: org$bukkit$WorldType;
  static values(): JavaArray<org$bukkit$WorldType>;
  static valueOf(arg0: string): org$bukkit$WorldType;
  getName(): string;
  static getByName(arg0: string): org$bukkit$WorldType;
}


declare interface $org$bukkit$SoundCategory {}

declare class org$bukkit$SoundCategory implements $org$bukkit$SoundCategory {
  static MASTER: org$bukkit$SoundCategory;
  static MUSIC: org$bukkit$SoundCategory;
  static RECORDS: org$bukkit$SoundCategory;
  static WEATHER: org$bukkit$SoundCategory;
  static BLOCKS: org$bukkit$SoundCategory;
  static HOSTILE: org$bukkit$SoundCategory;
  static NEUTRAL: org$bukkit$SoundCategory;
  static PLAYERS: org$bukkit$SoundCategory;
  static AMBIENT: org$bukkit$SoundCategory;
  static VOICE: org$bukkit$SoundCategory;
  static values(): JavaArray<org$bukkit$SoundCategory>;
  static valueOf(arg0: string): org$bukkit$SoundCategory;
}


declare interface $org$bukkit$GameRule {
  getName(): string;
  getType(): any /* java.lang.Class */;
  equals(arg0: any): boolean;
  toString(): string;
}

declare class org$bukkit$GameRule implements $org$bukkit$GameRule {
  static ANNOUNCE_ADVANCEMENTS: org$bukkit$GameRule;
  static COMMAND_BLOCK_OUTPUT: org$bukkit$GameRule;
  static DISABLE_ELYTRA_MOVEMENT_CHECK: org$bukkit$GameRule;
  static DO_DAYLIGHT_CYCLE: org$bukkit$GameRule;
  static DO_ENTITY_DROPS: org$bukkit$GameRule;
  static DO_FIRE_TICK: org$bukkit$GameRule;
  static DO_LIMITED_CRAFTING: org$bukkit$GameRule;
  static DO_MOB_LOOT: org$bukkit$GameRule;
  static DO_MOB_SPAWNING: org$bukkit$GameRule;
  static DO_TILE_DROPS: org$bukkit$GameRule;
  static DO_WEATHER_CYCLE: org$bukkit$GameRule;
  static KEEP_INVENTORY: org$bukkit$GameRule;
  static LOG_ADMIN_COMMANDS: org$bukkit$GameRule;
  static MOB_GRIEFING: org$bukkit$GameRule;
  static NATURAL_REGENERATION: org$bukkit$GameRule;
  static REDUCED_DEBUG_INFO: org$bukkit$GameRule;
  static SEND_COMMAND_FEEDBACK: org$bukkit$GameRule;
  static SHOW_DEATH_MESSAGES: org$bukkit$GameRule;
  static SPECTATORS_GENERATE_CHUNKS: org$bukkit$GameRule;
  static DISABLE_RAIDS: org$bukkit$GameRule;
  static DO_INSOMNIA: org$bukkit$GameRule;
  static DO_IMMEDIATE_RESPAWN: org$bukkit$GameRule;
  static DROWNING_DAMAGE: org$bukkit$GameRule;
  static FALL_DAMAGE: org$bukkit$GameRule;
  static FIRE_DAMAGE: org$bukkit$GameRule;
  static DO_PATROL_SPAWNING: org$bukkit$GameRule;
  static DO_TRADER_SPAWNING: org$bukkit$GameRule;
  static RANDOM_TICK_SPEED: org$bukkit$GameRule;
  static SPAWN_RADIUS: org$bukkit$GameRule;
  static MAX_ENTITY_CRAMMING: org$bukkit$GameRule;
  static MAX_COMMAND_CHAIN_LENGTH: org$bukkit$GameRule;
  getName(): string;
  getType(): any /* java.lang.Class */;
  equals(arg0: any): boolean;
  toString(): string;
  static getByName(arg0: string): org$bukkit$GameRule;
  static values(): JavaArray<org$bukkit$GameRule>;
}


declare interface $org$bukkit$WorldBorder {
  reset(): void;
  getSize(): number;
  setSize(arg0: number): void;
  setSize(arg0: number, arg1: number): void;
  getCenter(): org$bukkit$Location;
  setCenter(arg0: number, arg1: number): void;
  setCenter(arg0: org$bukkit$Location): void;
  getDamageBuffer(): number;
  setDamageBuffer(arg0: number): void;
  getDamageAmount(): number;
  setDamageAmount(arg0: number): void;
  getWarningTime(): number;
  setWarningTime(arg0: number): void;
  getWarningDistance(): number;
  setWarningDistance(arg0: number): void;
  isInside(arg0: org$bukkit$Location): boolean;
  isInBounds(arg0: org$bukkit$Location): boolean;
}

declare class org$bukkit$WorldBorder implements $org$bukkit$WorldBorder {
  reset(): void;
  getSize(): number;
  setSize(arg0: number): void;
  setSize(arg0: number, arg1: number): void;
  getCenter(): org$bukkit$Location;
  setCenter(arg0: number, arg1: number): void;
  setCenter(arg0: org$bukkit$Location): void;
  getDamageBuffer(): number;
  setDamageBuffer(arg0: number): void;
  getDamageAmount(): number;
  setDamageAmount(arg0: number): void;
  getWarningTime(): number;
  setWarningTime(arg0: number): void;
  getWarningDistance(): number;
  setWarningDistance(arg0: number): void;
  isInside(arg0: org$bukkit$Location): boolean;
  isInBounds(arg0: org$bukkit$Location): boolean;
}


declare interface $org$bukkit$Particle {
  getDataType(): any /* java.lang.Class */;
  builder(): com$destroystokyo$paper$ParticleBuilder;
}

declare class org$bukkit$Particle implements $org$bukkit$Particle {
  static EXPLOSION_NORMAL: org$bukkit$Particle;
  static EXPLOSION_LARGE: org$bukkit$Particle;
  static EXPLOSION_HUGE: org$bukkit$Particle;
  static FIREWORKS_SPARK: org$bukkit$Particle;
  static WATER_BUBBLE: org$bukkit$Particle;
  static WATER_SPLASH: org$bukkit$Particle;
  static WATER_WAKE: org$bukkit$Particle;
  static SUSPENDED: org$bukkit$Particle;
  static SUSPENDED_DEPTH: org$bukkit$Particle;
  static CRIT: org$bukkit$Particle;
  static CRIT_MAGIC: org$bukkit$Particle;
  static SMOKE_NORMAL: org$bukkit$Particle;
  static SMOKE_LARGE: org$bukkit$Particle;
  static SPELL: org$bukkit$Particle;
  static SPELL_INSTANT: org$bukkit$Particle;
  static SPELL_MOB: org$bukkit$Particle;
  static SPELL_MOB_AMBIENT: org$bukkit$Particle;
  static SPELL_WITCH: org$bukkit$Particle;
  static DRIP_WATER: org$bukkit$Particle;
  static DRIP_LAVA: org$bukkit$Particle;
  static VILLAGER_ANGRY: org$bukkit$Particle;
  static VILLAGER_HAPPY: org$bukkit$Particle;
  static TOWN_AURA: org$bukkit$Particle;
  static NOTE: org$bukkit$Particle;
  static PORTAL: org$bukkit$Particle;
  static ENCHANTMENT_TABLE: org$bukkit$Particle;
  static FLAME: org$bukkit$Particle;
  static LAVA: org$bukkit$Particle;
  static CLOUD: org$bukkit$Particle;
  static REDSTONE: org$bukkit$Particle;
  static SNOWBALL: org$bukkit$Particle;
  static SNOW_SHOVEL: org$bukkit$Particle;
  static SLIME: org$bukkit$Particle;
  static HEART: org$bukkit$Particle;
  static BARRIER: org$bukkit$Particle;
  static ITEM_CRACK: org$bukkit$Particle;
  static BLOCK_CRACK: org$bukkit$Particle;
  static BLOCK_DUST: org$bukkit$Particle;
  static WATER_DROP: org$bukkit$Particle;
  static MOB_APPEARANCE: org$bukkit$Particle;
  static DRAGON_BREATH: org$bukkit$Particle;
  static END_ROD: org$bukkit$Particle;
  static DAMAGE_INDICATOR: org$bukkit$Particle;
  static SWEEP_ATTACK: org$bukkit$Particle;
  static FALLING_DUST: org$bukkit$Particle;
  static TOTEM: org$bukkit$Particle;
  static SPIT: org$bukkit$Particle;
  static SQUID_INK: org$bukkit$Particle;
  static BUBBLE_POP: org$bukkit$Particle;
  static CURRENT_DOWN: org$bukkit$Particle;
  static BUBBLE_COLUMN_UP: org$bukkit$Particle;
  static NAUTILUS: org$bukkit$Particle;
  static DOLPHIN: org$bukkit$Particle;
  static SNEEZE: org$bukkit$Particle;
  static CAMPFIRE_COSY_SMOKE: org$bukkit$Particle;
  static CAMPFIRE_SIGNAL_SMOKE: org$bukkit$Particle;
  static COMPOSTER: org$bukkit$Particle;
  static FLASH: org$bukkit$Particle;
  static FALLING_LAVA: org$bukkit$Particle;
  static LANDING_LAVA: org$bukkit$Particle;
  static FALLING_WATER: org$bukkit$Particle;
  static DRIPPING_HONEY: org$bukkit$Particle;
  static FALLING_HONEY: org$bukkit$Particle;
  static LANDING_HONEY: org$bukkit$Particle;
  static FALLING_NECTAR: org$bukkit$Particle;
  static LEGACY_BLOCK_CRACK: org$bukkit$Particle;
  static LEGACY_BLOCK_DUST: org$bukkit$Particle;
  static LEGACY_FALLING_DUST: org$bukkit$Particle;
  static values(): JavaArray<org$bukkit$Particle>;
  static valueOf(arg0: string): org$bukkit$Particle;
  getDataType(): any /* java.lang.Class */;
  builder(): com$destroystokyo$paper$ParticleBuilder;
}


declare interface $com$destroystokyo$paper$ParticleBuilder {
  spawn(): com$destroystokyo$paper$ParticleBuilder;
  particle(): org$bukkit$Particle;
  particle(arg0: org$bukkit$Particle): com$destroystokyo$paper$ParticleBuilder;
  receivers(): any /* java.util.List */;
  hasReceivers(): boolean;
  allPlayers(): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: any /* java.util.List */
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: java$util$Collection
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: JavaArray<org$bukkit$entity$Player>
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(arg0: number): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: number
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: number,
    arg2: boolean
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: number,
    arg2: number
  ): com$destroystokyo$paper$ParticleBuilder;
  source(): org$bukkit$entity$Player;
  source(
    arg0: org$bukkit$entity$Player
  ): com$destroystokyo$paper$ParticleBuilder;
  location(): org$bukkit$Location;
  location(arg0: org$bukkit$Location): com$destroystokyo$paper$ParticleBuilder;
  location(
    arg0: org$bukkit$World,
    arg1: number,
    arg2: number,
    arg3: number
  ): com$destroystokyo$paper$ParticleBuilder;
  count(): number;
  count(arg0: number): com$destroystokyo$paper$ParticleBuilder;
  offsetX(): number;
  offsetY(): number;
  offsetZ(): number;
  offset(
    arg0: number,
    arg1: number,
    arg2: number
  ): com$destroystokyo$paper$ParticleBuilder;
  extra(): number;
  extra(arg0: number): com$destroystokyo$paper$ParticleBuilder;
  data(): any;
  data(arg0: any): com$destroystokyo$paper$ParticleBuilder;
  force(arg0: boolean): com$destroystokyo$paper$ParticleBuilder;
  color(arg0: org$bukkit$Color): com$destroystokyo$paper$ParticleBuilder;
  color(
    arg0: org$bukkit$Color,
    arg1: number
  ): com$destroystokyo$paper$ParticleBuilder;
  color(
    arg0: number,
    arg1: number,
    arg2: number
  ): com$destroystokyo$paper$ParticleBuilder;
}

declare class com$destroystokyo$paper$ParticleBuilder
  implements $com$destroystokyo$paper$ParticleBuilder {
  constructor(arg0: org$bukkit$Particle);
  spawn(): com$destroystokyo$paper$ParticleBuilder;
  particle(): org$bukkit$Particle;
  particle(arg0: org$bukkit$Particle): com$destroystokyo$paper$ParticleBuilder;
  receivers(): any /* java.util.List */;
  hasReceivers(): boolean;
  allPlayers(): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: any /* java.util.List */
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: java$util$Collection
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: JavaArray<org$bukkit$entity$Player>
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(arg0: number): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: number
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: number,
    arg2: boolean
  ): com$destroystokyo$paper$ParticleBuilder;
  receivers(
    arg0: number,
    arg1: number,
    arg2: number
  ): com$destroystokyo$paper$ParticleBuilder;
  source(): org$bukkit$entity$Player;
  source(
    arg0: org$bukkit$entity$Player
  ): com$destroystokyo$paper$ParticleBuilder;
  location(): org$bukkit$Location;
  location(arg0: org$bukkit$Location): com$destroystokyo$paper$ParticleBuilder;
  location(
    arg0: org$bukkit$World,
    arg1: number,
    arg2: number,
    arg3: number
  ): com$destroystokyo$paper$ParticleBuilder;
  count(): number;
  count(arg0: number): com$destroystokyo$paper$ParticleBuilder;
  offsetX(): number;
  offsetY(): number;
  offsetZ(): number;
  offset(
    arg0: number,
    arg1: number,
    arg2: number
  ): com$destroystokyo$paper$ParticleBuilder;
  extra(): number;
  extra(arg0: number): com$destroystokyo$paper$ParticleBuilder;
  data(): any;
  data(arg0: any): com$destroystokyo$paper$ParticleBuilder;
  force(arg0: boolean): com$destroystokyo$paper$ParticleBuilder;
  color(arg0: org$bukkit$Color): com$destroystokyo$paper$ParticleBuilder;
  color(
    arg0: org$bukkit$Color,
    arg1: number
  ): com$destroystokyo$paper$ParticleBuilder;
  color(
    arg0: number,
    arg1: number,
    arg2: number
  ): com$destroystokyo$paper$ParticleBuilder;
}


declare interface $org$bukkit$StructureType {
  getName(): string;
  getMapIcon(): org$bukkit$map$MapCursor$Type;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}

declare class org$bukkit$StructureType implements $org$bukkit$StructureType {
  static MINESHAFT: org$bukkit$StructureType;
  static VILLAGE: org$bukkit$StructureType;
  static NETHER_FORTRESS: org$bukkit$StructureType;
  static STRONGHOLD: org$bukkit$StructureType;
  static JUNGLE_PYRAMID: org$bukkit$StructureType;
  static OCEAN_RUIN: org$bukkit$StructureType;
  static DESERT_PYRAMID: org$bukkit$StructureType;
  static IGLOO: org$bukkit$StructureType;
  static SWAMP_HUT: org$bukkit$StructureType;
  static OCEAN_MONUMENT: org$bukkit$StructureType;
  static END_CITY: org$bukkit$StructureType;
  static WOODLAND_MANSION: org$bukkit$StructureType;
  static BURIED_TREASURE: org$bukkit$StructureType;
  static SHIPWRECK: org$bukkit$StructureType;
  static PILLAGER_OUTPOST: org$bukkit$StructureType;
  getName(): string;
  getMapIcon(): org$bukkit$map$MapCursor$Type;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  static getStructureTypes(): any /* java.util.Map */;
}


declare interface $org$bukkit$map$MapCursor$Type {
  getValue(): Buffer;
}

declare class org$bukkit$map$MapCursor$Type
  implements $org$bukkit$map$MapCursor$Type {
  static WHITE_POINTER: org$bukkit$map$MapCursor$Type;
  static GREEN_POINTER: org$bukkit$map$MapCursor$Type;
  static RED_POINTER: org$bukkit$map$MapCursor$Type;
  static BLUE_POINTER: org$bukkit$map$MapCursor$Type;
  static WHITE_CROSS: org$bukkit$map$MapCursor$Type;
  static RED_MARKER: org$bukkit$map$MapCursor$Type;
  static WHITE_CIRCLE: org$bukkit$map$MapCursor$Type;
  static SMALL_WHITE_CIRCLE: org$bukkit$map$MapCursor$Type;
  static MANSION: org$bukkit$map$MapCursor$Type;
  static TEMPLE: org$bukkit$map$MapCursor$Type;
  static BANNER_WHITE: org$bukkit$map$MapCursor$Type;
  static BANNER_ORANGE: org$bukkit$map$MapCursor$Type;
  static BANNER_MAGENTA: org$bukkit$map$MapCursor$Type;
  static BANNER_LIGHT_BLUE: org$bukkit$map$MapCursor$Type;
  static BANNER_YELLOW: org$bukkit$map$MapCursor$Type;
  static BANNER_LIME: org$bukkit$map$MapCursor$Type;
  static BANNER_PINK: org$bukkit$map$MapCursor$Type;
  static BANNER_GRAY: org$bukkit$map$MapCursor$Type;
  static BANNER_LIGHT_GRAY: org$bukkit$map$MapCursor$Type;
  static BANNER_CYAN: org$bukkit$map$MapCursor$Type;
  static BANNER_PURPLE: org$bukkit$map$MapCursor$Type;
  static BANNER_BLUE: org$bukkit$map$MapCursor$Type;
  static BANNER_BROWN: org$bukkit$map$MapCursor$Type;
  static BANNER_GREEN: org$bukkit$map$MapCursor$Type;
  static BANNER_RED: org$bukkit$map$MapCursor$Type;
  static BANNER_BLACK: org$bukkit$map$MapCursor$Type;
  static RED_X: org$bukkit$map$MapCursor$Type;
  static values(): JavaArray<org$bukkit$map$MapCursor$Type>;
  static valueOf(arg0: string): org$bukkit$map$MapCursor$Type;
  getValue(): Buffer;
  static byValue(arg0: Buffer): org$bukkit$map$MapCursor$Type;
  static access$000(arg0: org$bukkit$map$MapCursor$Type): Buffer;
}


declare interface $org$bukkit$World$Spigot {
  strikeLightning(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$entity$LightningStrike;
  strikeLightningEffect(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$entity$LightningStrike;
}

declare class org$bukkit$World$Spigot implements $org$bukkit$World$Spigot {
  constructor();
  strikeLightning(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$entity$LightningStrike;
  strikeLightningEffect(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$entity$LightningStrike;
}


declare interface $org$bukkit$Raid {
  isStarted(): boolean;
  getActiveTicks(): number;
  getBadOmenLevel(): number;
  setBadOmenLevel(arg0: number): void;
  getLocation(): org$bukkit$Location;
  getStatus(): org$bukkit$Raid$RaidStatus;
  getSpawnedGroups(): number;
  getTotalGroups(): number;
  getTotalWaves(): number;
  getTotalHealth(): number;
  getHeroes(): any /* java.util.Set */;
  getRaiders(): any /* java.util.List */;
}

declare class org$bukkit$Raid implements $org$bukkit$Raid {
  isStarted(): boolean;
  getActiveTicks(): number;
  getBadOmenLevel(): number;
  setBadOmenLevel(arg0: number): void;
  getLocation(): org$bukkit$Location;
  getStatus(): org$bukkit$Raid$RaidStatus;
  getSpawnedGroups(): number;
  getTotalGroups(): number;
  getTotalWaves(): number;
  getTotalHealth(): number;
  getHeroes(): any /* java.util.Set */;
  getRaiders(): any /* java.util.List */;
}


declare interface $org$bukkit$Raid$RaidStatus {}

declare class org$bukkit$Raid$RaidStatus
  implements $org$bukkit$Raid$RaidStatus {
  static ONGOING: org$bukkit$Raid$RaidStatus;
  static VICTORY: org$bukkit$Raid$RaidStatus;
  static LOSS: org$bukkit$Raid$RaidStatus;
  static STOPPED: org$bukkit$Raid$RaidStatus;
  static values(): JavaArray<org$bukkit$Raid$RaidStatus>;
  static valueOf(arg0: string): org$bukkit$Raid$RaidStatus;
}


declare interface $org$bukkit$boss$DragonBattle {
  getEnderDragon(): org$bukkit$entity$EnderDragon;
  getBossBar(): org$bukkit$boss$BossBar;
  getEndPortalLocation(): org$bukkit$Location;
  hasBeenPreviouslyKilled(): boolean;
  initiateRespawn(): void;
  getRespawnPhase(): org$bukkit$boss$DragonBattle$RespawnPhase;
  setRespawnPhase(arg0: org$bukkit$boss$DragonBattle$RespawnPhase): boolean;
  resetCrystals(): void;
}

declare class org$bukkit$boss$DragonBattle
  implements $org$bukkit$boss$DragonBattle {
  getEnderDragon(): org$bukkit$entity$EnderDragon;
  getBossBar(): org$bukkit$boss$BossBar;
  getEndPortalLocation(): org$bukkit$Location;
  hasBeenPreviouslyKilled(): boolean;
  initiateRespawn(): void;
  getRespawnPhase(): org$bukkit$boss$DragonBattle$RespawnPhase;
  setRespawnPhase(arg0: org$bukkit$boss$DragonBattle$RespawnPhase): boolean;
  resetCrystals(): void;
}


declare interface $org$bukkit$entity$EnderDragon
  extends $org$bukkit$entity$ComplexLivingEntity,
    $org$bukkit$entity$Boss,
    $org$bukkit$entity$Mob {
  getPhase(): org$bukkit$entity$EnderDragon$Phase;
  setPhase(arg0: org$bukkit$entity$EnderDragon$Phase): void;
  getDragonBattle(): org$bukkit$boss$DragonBattle;
  getDeathAnimationTicks(): number;
}

declare class org$bukkit$entity$EnderDragon
  implements $org$bukkit$entity$EnderDragon {
  getPhase(): org$bukkit$entity$EnderDragon$Phase;
  setPhase(arg0: org$bukkit$entity$EnderDragon$Phase): void;
  getDragonBattle(): org$bukkit$boss$DragonBattle;
  getDeathAnimationTicks(): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getBossBar(): org$bukkit$boss$BossBar;
  getParts(): any /* java.util.Set */;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Boss extends $org$bukkit$entity$Entity {
  getBossBar(): org$bukkit$boss$BossBar;
}

declare class org$bukkit$entity$Boss implements $org$bukkit$entity$Boss {
  getBossBar(): org$bukkit$boss$BossBar;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$boss$BossBar {
  getTitle(): string;
  setTitle(arg0: string): void;
  getColor(): org$bukkit$boss$BarColor;
  setColor(arg0: org$bukkit$boss$BarColor): void;
  getStyle(): org$bukkit$boss$BarStyle;
  setStyle(arg0: org$bukkit$boss$BarStyle): void;
  removeFlag(arg0: org$bukkit$boss$BarFlag): void;
  addFlag(arg0: org$bukkit$boss$BarFlag): void;
  hasFlag(arg0: org$bukkit$boss$BarFlag): boolean;
  setProgress(arg0: number): void;
  getProgress(): number;
  addPlayer(arg0: org$bukkit$entity$Player): void;
  removePlayer(arg0: org$bukkit$entity$Player): void;
  removeAll(): void;
  getPlayers(): any /* java.util.List */;
  setVisible(arg0: boolean): void;
  isVisible(): boolean;
  show(): void;
  hide(): void;
}

declare class org$bukkit$boss$BossBar implements $org$bukkit$boss$BossBar {
  getTitle(): string;
  setTitle(arg0: string): void;
  getColor(): org$bukkit$boss$BarColor;
  setColor(arg0: org$bukkit$boss$BarColor): void;
  getStyle(): org$bukkit$boss$BarStyle;
  setStyle(arg0: org$bukkit$boss$BarStyle): void;
  removeFlag(arg0: org$bukkit$boss$BarFlag): void;
  addFlag(arg0: org$bukkit$boss$BarFlag): void;
  hasFlag(arg0: org$bukkit$boss$BarFlag): boolean;
  setProgress(arg0: number): void;
  getProgress(): number;
  addPlayer(arg0: org$bukkit$entity$Player): void;
  removePlayer(arg0: org$bukkit$entity$Player): void;
  removeAll(): void;
  getPlayers(): any /* java.util.List */;
  setVisible(arg0: boolean): void;
  isVisible(): boolean;
  show(): void;
  hide(): void;
}


declare interface $org$bukkit$boss$BarColor {}

declare class org$bukkit$boss$BarColor implements $org$bukkit$boss$BarColor {
  static PINK: org$bukkit$boss$BarColor;
  static BLUE: org$bukkit$boss$BarColor;
  static RED: org$bukkit$boss$BarColor;
  static GREEN: org$bukkit$boss$BarColor;
  static YELLOW: org$bukkit$boss$BarColor;
  static PURPLE: org$bukkit$boss$BarColor;
  static WHITE: org$bukkit$boss$BarColor;
  static values(): JavaArray<org$bukkit$boss$BarColor>;
  static valueOf(arg0: string): org$bukkit$boss$BarColor;
}


declare interface $org$bukkit$boss$BarStyle {}

declare class org$bukkit$boss$BarStyle implements $org$bukkit$boss$BarStyle {
  static SOLID: org$bukkit$boss$BarStyle;
  static SEGMENTED_6: org$bukkit$boss$BarStyle;
  static SEGMENTED_10: org$bukkit$boss$BarStyle;
  static SEGMENTED_12: org$bukkit$boss$BarStyle;
  static SEGMENTED_20: org$bukkit$boss$BarStyle;
  static values(): JavaArray<org$bukkit$boss$BarStyle>;
  static valueOf(arg0: string): org$bukkit$boss$BarStyle;
}


declare interface $org$bukkit$boss$BarFlag {}

declare class org$bukkit$boss$BarFlag implements $org$bukkit$boss$BarFlag {
  static DARKEN_SKY: org$bukkit$boss$BarFlag;
  static PLAY_BOSS_MUSIC: org$bukkit$boss$BarFlag;
  static CREATE_FOG: org$bukkit$boss$BarFlag;
  static values(): JavaArray<org$bukkit$boss$BarFlag>;
  static valueOf(arg0: string): org$bukkit$boss$BarFlag;
}


declare interface $org$bukkit$entity$ComplexLivingEntity
  extends $org$bukkit$entity$LivingEntity {
  getParts(): any /* java.util.Set */;
}

declare class org$bukkit$entity$ComplexLivingEntity
  implements $org$bukkit$entity$ComplexLivingEntity {
  getParts(): any /* java.util.Set */;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Mob
  extends $org$bukkit$entity$LivingEntity,
    $org$bukkit$loot$Lootable {
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
}

declare class org$bukkit$entity$Mob implements $org$bukkit$entity$Mob {
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$loot$Lootable {
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
}

declare class org$bukkit$loot$Lootable implements $org$bukkit$loot$Lootable {
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
}


declare interface $org$bukkit$loot$LootTable extends $org$bukkit$Keyed {
  populateLoot(
    arg0: any /* java.util.Random */,
    arg1: org$bukkit$loot$LootContext
  ): java$util$Collection;
  fillInventory(
    arg0: org$bukkit$inventory$Inventory,
    arg1: any /* java.util.Random */,
    arg2: org$bukkit$loot$LootContext
  ): void;
}

declare class org$bukkit$loot$LootTable implements $org$bukkit$loot$LootTable {
  populateLoot(
    arg0: any /* java.util.Random */,
    arg1: org$bukkit$loot$LootContext
  ): java$util$Collection;
  fillInventory(
    arg0: org$bukkit$inventory$Inventory,
    arg1: any /* java.util.Random */,
    arg2: org$bukkit$loot$LootContext
  ): void;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$loot$LootContext {
  getLocation(): org$bukkit$Location;
  getLuck(): number;
  getLootingModifier(): number;
  getLootedEntity(): org$bukkit$entity$Entity;
  getKiller(): org$bukkit$entity$HumanEntity;
}

declare class org$bukkit$loot$LootContext
  implements $org$bukkit$loot$LootContext {
  static DEFAULT_LOOT_MODIFIER: number;
  getLocation(): org$bukkit$Location;
  getLuck(): number;
  getLootingModifier(): number;
  getLootedEntity(): org$bukkit$entity$Entity;
  getKiller(): org$bukkit$entity$HumanEntity;
  constructor(
    arg0: org$bukkit$Location,
    arg1: number,
    arg2: number,
    arg3: org$bukkit$entity$Entity,
    arg4: org$bukkit$entity$HumanEntity,
    arg5: org$bukkit$loot$LootContext$1
  );
}


declare interface $org$bukkit$entity$HumanEntity
  extends $org$bukkit$entity$LivingEntity,
    $org$bukkit$entity$AnimalTamer,
    $org$bukkit$inventory$InventoryHolder {
  getName(): string;
  getInventory(): org$bukkit$inventory$PlayerInventory;
  getEnderChest(): org$bukkit$inventory$Inventory;
  getMainHand(): org$bukkit$inventory$MainHand;
  setWindowProperty(
    arg0: org$bukkit$inventory$InventoryView$Property,
    arg1: number
  ): boolean;
  getOpenInventory(): org$bukkit$inventory$InventoryView;
  openInventory(
    arg0: org$bukkit$inventory$Inventory
  ): org$bukkit$inventory$InventoryView;
  openWorkbench(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openEnchanting(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openInventory(arg0: org$bukkit$inventory$InventoryView): void;
  openMerchant(
    arg0: org$bukkit$entity$Villager,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openMerchant(
    arg0: org$bukkit$inventory$Merchant,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  closeInventory(): void;
  closeInventory(
    arg0: org$bukkit$event$inventory$InventoryCloseEvent$Reason
  ): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemOnCursor(): org$bukkit$inventory$ItemStack;
  setItemOnCursor(arg0: org$bukkit$inventory$ItemStack): void;
  hasCooldown(arg0: org$bukkit$Material): boolean;
  getCooldown(arg0: org$bukkit$Material): number;
  setCooldown(arg0: org$bukkit$Material, arg1: number): void;
  getSleepTicks(): number;
  getBedSpawnLocation(): org$bukkit$Location;
  getPotentialBedLocation(): org$bukkit$Location;
  setBedSpawnLocation(arg0: org$bukkit$Location): void;
  setBedSpawnLocation(arg0: org$bukkit$Location, arg1: boolean): void;
  sleep(arg0: org$bukkit$Location, arg1: boolean): boolean;
  wakeup(arg0: boolean): void;
  getBedLocation(): org$bukkit$Location;
  getGameMode(): org$bukkit$GameMode;
  setGameMode(arg0: org$bukkit$GameMode): void;
  isBlocking(): boolean;
  isHandRaised(): boolean;
  getExpToLevel(): number;
  releaseLeftShoulderEntity(): org$bukkit$entity$Entity;
  releaseRightShoulderEntity(): org$bukkit$entity$Entity;
  getAttackCooldown(): number;
  discoverRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  discoverRecipes(arg0: java$util$Collection): number;
  undiscoverRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  undiscoverRecipes(arg0: java$util$Collection): number;
  getShoulderEntityLeft(): org$bukkit$entity$Entity;
  setShoulderEntityLeft(arg0: org$bukkit$entity$Entity): void;
  getShoulderEntityRight(): org$bukkit$entity$Entity;
  setShoulderEntityRight(arg0: org$bukkit$entity$Entity): void;
  openSign(arg0: org$bukkit$block$Sign): void;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$entity$HumanEntity
  implements $org$bukkit$entity$HumanEntity {
  getName(): string;
  getInventory(): org$bukkit$inventory$PlayerInventory;
  getEnderChest(): org$bukkit$inventory$Inventory;
  getMainHand(): org$bukkit$inventory$MainHand;
  setWindowProperty(
    arg0: org$bukkit$inventory$InventoryView$Property,
    arg1: number
  ): boolean;
  getOpenInventory(): org$bukkit$inventory$InventoryView;
  openInventory(
    arg0: org$bukkit$inventory$Inventory
  ): org$bukkit$inventory$InventoryView;
  openWorkbench(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openEnchanting(
    arg0: org$bukkit$Location,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openInventory(arg0: org$bukkit$inventory$InventoryView): void;
  openMerchant(
    arg0: org$bukkit$entity$Villager,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  openMerchant(
    arg0: org$bukkit$inventory$Merchant,
    arg1: boolean
  ): org$bukkit$inventory$InventoryView;
  closeInventory(): void;
  closeInventory(
    arg0: org$bukkit$event$inventory$InventoryCloseEvent$Reason
  ): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemOnCursor(): org$bukkit$inventory$ItemStack;
  setItemOnCursor(arg0: org$bukkit$inventory$ItemStack): void;
  hasCooldown(arg0: org$bukkit$Material): boolean;
  getCooldown(arg0: org$bukkit$Material): number;
  setCooldown(arg0: org$bukkit$Material, arg1: number): void;
  getSleepTicks(): number;
  getBedSpawnLocation(): org$bukkit$Location;
  getPotentialBedLocation(): org$bukkit$Location;
  setBedSpawnLocation(arg0: org$bukkit$Location): void;
  setBedSpawnLocation(arg0: org$bukkit$Location, arg1: boolean): void;
  sleep(arg0: org$bukkit$Location, arg1: boolean): boolean;
  wakeup(arg0: boolean): void;
  getBedLocation(): org$bukkit$Location;
  getGameMode(): org$bukkit$GameMode;
  setGameMode(arg0: org$bukkit$GameMode): void;
  isBlocking(): boolean;
  isHandRaised(): boolean;
  getExpToLevel(): number;
  releaseLeftShoulderEntity(): org$bukkit$entity$Entity;
  releaseRightShoulderEntity(): org$bukkit$entity$Entity;
  getAttackCooldown(): number;
  discoverRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  discoverRecipes(arg0: java$util$Collection): number;
  undiscoverRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  undiscoverRecipes(arg0: java$util$Collection): number;
  getShoulderEntityLeft(): org$bukkit$entity$Entity;
  setShoulderEntityLeft(arg0: org$bukkit$entity$Entity): void;
  getShoulderEntityRight(): org$bukkit$entity$Entity;
  setShoulderEntityRight(arg0: org$bukkit$entity$Entity): void;
  openSign(arg0: org$bukkit$block$Sign): void;
  getInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getUniqueId(): any /* java.util.UUID */;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$inventory$InventoryHolder {
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$inventory$InventoryHolder
  implements $org$bukkit$inventory$InventoryHolder {
  getInventory(): org$bukkit$inventory$Inventory;
}


declare interface $org$bukkit$inventory$Inventory {
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}

declare class org$bukkit$inventory$Inventory
  implements $org$bukkit$inventory$Inventory {
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$event$inventory$InventoryType {
  getDefaultSize(): number;
  getDefaultTitle(): string;
  isCreatable(): boolean;
}

declare class org$bukkit$event$inventory$InventoryType
  implements $org$bukkit$event$inventory$InventoryType {
  static CHEST: org$bukkit$event$inventory$InventoryType;
  static DISPENSER: org$bukkit$event$inventory$InventoryType;
  static DROPPER: org$bukkit$event$inventory$InventoryType;
  static FURNACE: org$bukkit$event$inventory$InventoryType;
  static WORKBENCH: org$bukkit$event$inventory$InventoryType;
  static CRAFTING: org$bukkit$event$inventory$InventoryType;
  static ENCHANTING: org$bukkit$event$inventory$InventoryType;
  static BREWING: org$bukkit$event$inventory$InventoryType;
  static PLAYER: org$bukkit$event$inventory$InventoryType;
  static CREATIVE: org$bukkit$event$inventory$InventoryType;
  static MERCHANT: org$bukkit$event$inventory$InventoryType;
  static ENDER_CHEST: org$bukkit$event$inventory$InventoryType;
  static ANVIL: org$bukkit$event$inventory$InventoryType;
  static BEACON: org$bukkit$event$inventory$InventoryType;
  static HOPPER: org$bukkit$event$inventory$InventoryType;
  static SHULKER_BOX: org$bukkit$event$inventory$InventoryType;
  static BARREL: org$bukkit$event$inventory$InventoryType;
  static BLAST_FURNACE: org$bukkit$event$inventory$InventoryType;
  static LECTERN: org$bukkit$event$inventory$InventoryType;
  static SMOKER: org$bukkit$event$inventory$InventoryType;
  static LOOM: org$bukkit$event$inventory$InventoryType;
  static CARTOGRAPHY: org$bukkit$event$inventory$InventoryType;
  static GRINDSTONE: org$bukkit$event$inventory$InventoryType;
  static STONECUTTER: org$bukkit$event$inventory$InventoryType;
  static values(): JavaArray<org$bukkit$event$inventory$InventoryType>;
  static valueOf(arg0: string): org$bukkit$event$inventory$InventoryType;
  getDefaultSize(): number;
  getDefaultTitle(): string;
  isCreatable(): boolean;
}


declare interface $org$bukkit$inventory$PlayerInventory
  extends $org$bukkit$inventory$Inventory {
  getArmorContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  getExtraContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  getHelmet(): org$bukkit$inventory$ItemStack;
  getChestplate(): org$bukkit$inventory$ItemStack;
  getLeggings(): org$bukkit$inventory$ItemStack;
  getBoots(): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  setItem(
    arg0: org$bukkit$inventory$EquipmentSlot,
    arg1: org$bukkit$inventory$ItemStack
  ): void;
  getItem(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): org$bukkit$inventory$ItemStack;
  setArmorContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  setExtraContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  setHelmet(arg0: org$bukkit$inventory$ItemStack): void;
  setChestplate(arg0: org$bukkit$inventory$ItemStack): void;
  setLeggings(arg0: org$bukkit$inventory$ItemStack): void;
  setBoots(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInMainHand(): org$bukkit$inventory$ItemStack;
  setItemInMainHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInOffHand(): org$bukkit$inventory$ItemStack;
  setItemInOffHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getHeldItemSlot(): number;
  setHeldItemSlot(arg0: number): void;
  getHolder(): org$bukkit$entity$HumanEntity;
  getHolder(): org$bukkit$inventory$InventoryHolder;
}

declare class org$bukkit$inventory$PlayerInventory
  implements $org$bukkit$inventory$PlayerInventory {
  getArmorContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  getExtraContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  getHelmet(): org$bukkit$inventory$ItemStack;
  getChestplate(): org$bukkit$inventory$ItemStack;
  getLeggings(): org$bukkit$inventory$ItemStack;
  getBoots(): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  setItem(
    arg0: org$bukkit$inventory$EquipmentSlot,
    arg1: org$bukkit$inventory$ItemStack
  ): void;
  getItem(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): org$bukkit$inventory$ItemStack;
  setArmorContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  setExtraContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  setHelmet(arg0: org$bukkit$inventory$ItemStack): void;
  setChestplate(arg0: org$bukkit$inventory$ItemStack): void;
  setLeggings(arg0: org$bukkit$inventory$ItemStack): void;
  setBoots(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInMainHand(): org$bukkit$inventory$ItemStack;
  setItemInMainHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInOffHand(): org$bukkit$inventory$ItemStack;
  setItemInOffHand(arg0: org$bukkit$inventory$ItemStack): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getHeldItemSlot(): number;
  setHeldItemSlot(arg0: number): void;
  getHolder(): org$bukkit$entity$HumanEntity;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$MainHand {}

declare class org$bukkit$inventory$MainHand
  implements $org$bukkit$inventory$MainHand {
  static LEFT: org$bukkit$inventory$MainHand;
  static RIGHT: org$bukkit$inventory$MainHand;
  static values(): JavaArray<org$bukkit$inventory$MainHand>;
  static valueOf(arg0: string): org$bukkit$inventory$MainHand;
}


declare interface $org$bukkit$inventory$InventoryView$Property {
  getType(): org$bukkit$event$inventory$InventoryType;
  getId(): number;
}

declare class org$bukkit$inventory$InventoryView$Property
  implements $org$bukkit$inventory$InventoryView$Property {
  static BREW_TIME: org$bukkit$inventory$InventoryView$Property;
  static FUEL_TIME: org$bukkit$inventory$InventoryView$Property;
  static BURN_TIME: org$bukkit$inventory$InventoryView$Property;
  static TICKS_FOR_CURRENT_FUEL: org$bukkit$inventory$InventoryView$Property;
  static COOK_TIME: org$bukkit$inventory$InventoryView$Property;
  static TICKS_FOR_CURRENT_SMELTING: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_BUTTON1: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_BUTTON2: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_BUTTON3: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_XP_SEED: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_ID1: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_ID2: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_ID3: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_LEVEL1: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_LEVEL2: org$bukkit$inventory$InventoryView$Property;
  static ENCHANT_LEVEL3: org$bukkit$inventory$InventoryView$Property;
  static LEVELS: org$bukkit$inventory$InventoryView$Property;
  static PRIMARY_EFFECT: org$bukkit$inventory$InventoryView$Property;
  static SECONDARY_EFFECT: org$bukkit$inventory$InventoryView$Property;
  static REPAIR_COST: org$bukkit$inventory$InventoryView$Property;
  static BOOK_PAGE: org$bukkit$inventory$InventoryView$Property;
  static values(): JavaArray<org$bukkit$inventory$InventoryView$Property>;
  static valueOf(arg0: string): org$bukkit$inventory$InventoryView$Property;
  getType(): org$bukkit$event$inventory$InventoryType;
  getId(): number;
}


declare interface $org$bukkit$inventory$InventoryView {
  getTopInventory(): org$bukkit$inventory$Inventory;
  getBottomInventory(): org$bukkit$inventory$Inventory;
  getPlayer(): org$bukkit$entity$HumanEntity;
  getType(): org$bukkit$event$inventory$InventoryType;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  getCursor(): org$bukkit$inventory$ItemStack;
  getInventory(arg0: number): org$bukkit$inventory$Inventory;
  convertSlot(arg0: number): number;
  getSlotType(arg0: number): org$bukkit$event$inventory$InventoryType$SlotType;
  close(): void;
  countSlots(): number;
  setProperty(
    arg0: org$bukkit$inventory$InventoryView$Property,
    arg1: number
  ): boolean;
  getTitle(): string;
}

declare class org$bukkit$inventory$InventoryView
  implements $org$bukkit$inventory$InventoryView {
  static OUTSIDE: number;
  constructor();
  getTopInventory(): org$bukkit$inventory$Inventory;
  getBottomInventory(): org$bukkit$inventory$Inventory;
  getPlayer(): org$bukkit$entity$HumanEntity;
  getType(): org$bukkit$event$inventory$InventoryType;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  getCursor(): org$bukkit$inventory$ItemStack;
  getInventory(arg0: number): org$bukkit$inventory$Inventory;
  convertSlot(arg0: number): number;
  getSlotType(arg0: number): org$bukkit$event$inventory$InventoryType$SlotType;
  close(): void;
  countSlots(): number;
  setProperty(
    arg0: org$bukkit$inventory$InventoryView$Property,
    arg1: number
  ): boolean;
  getTitle(): string;
}


declare interface $org$bukkit$event$inventory$InventoryType$SlotType {}

declare class org$bukkit$event$inventory$InventoryType$SlotType
  implements $org$bukkit$event$inventory$InventoryType$SlotType {
  static RESULT: org$bukkit$event$inventory$InventoryType$SlotType;
  static CRAFTING: org$bukkit$event$inventory$InventoryType$SlotType;
  static ARMOR: org$bukkit$event$inventory$InventoryType$SlotType;
  static CONTAINER: org$bukkit$event$inventory$InventoryType$SlotType;
  static QUICKBAR: org$bukkit$event$inventory$InventoryType$SlotType;
  static OUTSIDE: org$bukkit$event$inventory$InventoryType$SlotType;
  static FUEL: org$bukkit$event$inventory$InventoryType$SlotType;
  static values(): JavaArray<org$bukkit$event$inventory$InventoryType$SlotType>;
  static valueOf(
    arg0: string
  ): org$bukkit$event$inventory$InventoryType$SlotType;
}


declare interface $org$bukkit$entity$Villager
  extends $org$bukkit$entity$AbstractVillager {
  getProfession(): org$bukkit$entity$Villager$Profession;
  setProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerType(): org$bukkit$entity$Villager$Type;
  setVillagerType(arg0: org$bukkit$entity$Villager$Type): void;
  getVillagerLevel(): number;
  setVillagerLevel(arg0: number): void;
  getVillagerExperience(): number;
  setVillagerExperience(arg0: number): void;
  getRestocksToday(): number;
  setRestocksToday(arg0: number): void;
  sleep(arg0: org$bukkit$Location): boolean;
  wakeup(): void;
  getReputation(
    arg0: any /* java.util.UUID */
  ): com$destroystokyo$paper$entity$villager$Reputation;
  getReputations(): any /* java.util.Map */;
  setReputation(
    arg0: any /* java.util.UUID */,
    arg1: com$destroystokyo$paper$entity$villager$Reputation
  ): void;
  setReputations(arg0: any /* java.util.Map */): void;
  clearReputations(): void;
}

declare class org$bukkit$entity$Villager
  implements $org$bukkit$entity$Villager {
  getProfession(): org$bukkit$entity$Villager$Profession;
  setProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerType(): org$bukkit$entity$Villager$Type;
  setVillagerType(arg0: org$bukkit$entity$Villager$Type): void;
  getVillagerLevel(): number;
  setVillagerLevel(arg0: number): void;
  getVillagerExperience(): number;
  setVillagerExperience(arg0: number): void;
  getRestocksToday(): number;
  setRestocksToday(arg0: number): void;
  sleep(arg0: org$bukkit$Location): boolean;
  wakeup(): void;
  getReputation(
    arg0: any /* java.util.UUID */
  ): com$destroystokyo$paper$entity$villager$Reputation;
  getReputations(): any /* java.util.Map */;
  setReputation(
    arg0: any /* java.util.UUID */,
    arg1: com$destroystokyo$paper$entity$villager$Reputation
  ): void;
  setReputations(arg0: any /* java.util.Map */): void;
  clearReputations(): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  getRecipe(arg0: number): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: number, arg1: org$bukkit$inventory$MerchantRecipe): void;
  getRecipeCount(): number;
  isTrading(): boolean;
  getTrader(): org$bukkit$entity$HumanEntity;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$AbstractVillager
  extends $org$bukkit$entity$Ageable,
    $org$bukkit$entity$NPC,
    $org$bukkit$inventory$InventoryHolder,
    $org$bukkit$inventory$Merchant {
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$entity$AbstractVillager
  implements $org$bukkit$entity$AbstractVillager {
  getInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  getRecipe(arg0: number): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: number, arg1: org$bukkit$inventory$MerchantRecipe): void;
  getRecipeCount(): number;
  isTrading(): boolean;
  getTrader(): org$bukkit$entity$HumanEntity;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Ageable
  extends $org$bukkit$entity$Creature {
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
}

declare class org$bukkit$entity$Ageable implements $org$bukkit$entity$Ageable {
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Creature extends $org$bukkit$entity$Mob {}

declare class org$bukkit$entity$Creature
  implements $org$bukkit$entity$Creature {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$NPC extends $org$bukkit$entity$Creature {}

declare class org$bukkit$entity$NPC implements $org$bukkit$entity$NPC {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$inventory$Merchant {
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  getRecipe(arg0: number): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: number, arg1: org$bukkit$inventory$MerchantRecipe): void;
  getRecipeCount(): number;
  isTrading(): boolean;
  getTrader(): org$bukkit$entity$HumanEntity;
}

declare class org$bukkit$inventory$Merchant
  implements $org$bukkit$inventory$Merchant {
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  getRecipe(arg0: number): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: number, arg1: org$bukkit$inventory$MerchantRecipe): void;
  getRecipeCount(): number;
  isTrading(): boolean;
  getTrader(): org$bukkit$entity$HumanEntity;
}


declare interface $org$bukkit$inventory$MerchantRecipe
  extends $org$bukkit$inventory$Recipe {
  getResult(): org$bukkit$inventory$ItemStack;
  addIngredient(arg0: org$bukkit$inventory$ItemStack): void;
  removeIngredient(arg0: number): void;
  setIngredients(arg0: any /* java.util.List */): void;
  getIngredients(): any /* java.util.List */;
  getUses(): number;
  setUses(arg0: number): void;
  getMaxUses(): number;
  setMaxUses(arg0: number): void;
  hasExperienceReward(): boolean;
  setExperienceReward(arg0: boolean): void;
  getVillagerExperience(): number;
  setVillagerExperience(arg0: number): void;
  getPriceMultiplier(): number;
  setPriceMultiplier(arg0: number): void;
}

declare class org$bukkit$inventory$MerchantRecipe
  implements $org$bukkit$inventory$MerchantRecipe {
  constructor(arg0: org$bukkit$inventory$ItemStack, arg1: number);
  constructor(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: number,
    arg2: number,
    arg3: boolean
  );
  constructor(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: number,
    arg2: number,
    arg3: boolean,
    arg4: number,
    arg5: number
  );
  getResult(): org$bukkit$inventory$ItemStack;
  addIngredient(arg0: org$bukkit$inventory$ItemStack): void;
  removeIngredient(arg0: number): void;
  setIngredients(arg0: any /* java.util.List */): void;
  getIngredients(): any /* java.util.List */;
  getUses(): number;
  setUses(arg0: number): void;
  getMaxUses(): number;
  setMaxUses(arg0: number): void;
  hasExperienceReward(): boolean;
  setExperienceReward(arg0: boolean): void;
  getVillagerExperience(): number;
  setVillagerExperience(arg0: number): void;
  getPriceMultiplier(): number;
  setPriceMultiplier(arg0: number): void;
}


declare interface $org$bukkit$inventory$Recipe {
  getResult(): org$bukkit$inventory$ItemStack;
}

declare class org$bukkit$inventory$Recipe
  implements $org$bukkit$inventory$Recipe {
  getResult(): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$entity$Villager$Profession
  extends $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
}

declare class org$bukkit$entity$Villager$Profession
  implements $org$bukkit$entity$Villager$Profession {
  static NONE: org$bukkit$entity$Villager$Profession;
  static ARMORER: org$bukkit$entity$Villager$Profession;
  static BUTCHER: org$bukkit$entity$Villager$Profession;
  static CARTOGRAPHER: org$bukkit$entity$Villager$Profession;
  static CLERIC: org$bukkit$entity$Villager$Profession;
  static FARMER: org$bukkit$entity$Villager$Profession;
  static FISHERMAN: org$bukkit$entity$Villager$Profession;
  static FLETCHER: org$bukkit$entity$Villager$Profession;
  static LEATHERWORKER: org$bukkit$entity$Villager$Profession;
  static LIBRARIAN: org$bukkit$entity$Villager$Profession;
  static MASON: org$bukkit$entity$Villager$Profession;
  static NITWIT: org$bukkit$entity$Villager$Profession;
  static SHEPHERD: org$bukkit$entity$Villager$Profession;
  static TOOLSMITH: org$bukkit$entity$Villager$Profession;
  static WEAPONSMITH: org$bukkit$entity$Villager$Profession;
  static values(): JavaArray<org$bukkit$entity$Villager$Profession>;
  static valueOf(arg0: string): org$bukkit$entity$Villager$Profession;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$entity$Villager$Type extends $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
}

declare class org$bukkit$entity$Villager$Type
  implements $org$bukkit$entity$Villager$Type {
  static DESERT: org$bukkit$entity$Villager$Type;
  static JUNGLE: org$bukkit$entity$Villager$Type;
  static PLAINS: org$bukkit$entity$Villager$Type;
  static SAVANNA: org$bukkit$entity$Villager$Type;
  static SNOW: org$bukkit$entity$Villager$Type;
  static SWAMP: org$bukkit$entity$Villager$Type;
  static TAIGA: org$bukkit$entity$Villager$Type;
  static values(): JavaArray<org$bukkit$entity$Villager$Type>;
  static valueOf(arg0: string): org$bukkit$entity$Villager$Type;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $com$destroystokyo$paper$entity$villager$Reputation {
  getReputation(
    arg0: com$destroystokyo$paper$entity$villager$ReputationType
  ): number;
  setReputation(
    arg0: com$destroystokyo$paper$entity$villager$ReputationType,
    arg1: number
  ): void;
}

declare class com$destroystokyo$paper$entity$villager$Reputation
  implements $com$destroystokyo$paper$entity$villager$Reputation {
  constructor();
  constructor(arg0: JavaArray<number>);
  constructor(arg0: any /* java.util.Map */);
  getReputation(
    arg0: com$destroystokyo$paper$entity$villager$ReputationType
  ): number;
  setReputation(
    arg0: com$destroystokyo$paper$entity$villager$ReputationType,
    arg1: number
  ): void;
}


declare interface $com$destroystokyo$paper$entity$villager$ReputationType {}

declare class com$destroystokyo$paper$entity$villager$ReputationType
  implements $com$destroystokyo$paper$entity$villager$ReputationType {
  static MAJOR_NEGATIVE: com$destroystokyo$paper$entity$villager$ReputationType;
  static MINOR_NEGATIVE: com$destroystokyo$paper$entity$villager$ReputationType;
  static MINOR_POSITIVE: com$destroystokyo$paper$entity$villager$ReputationType;
  static MAJOR_POSITIVE: com$destroystokyo$paper$entity$villager$ReputationType;
  static TRADING: com$destroystokyo$paper$entity$villager$ReputationType;
  static values(): JavaArray<
    com$destroystokyo$paper$entity$villager$ReputationType
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$entity$villager$ReputationType;
}


declare interface $org$bukkit$event$inventory$InventoryCloseEvent$Reason {}

declare class org$bukkit$event$inventory$InventoryCloseEvent$Reason
  implements $org$bukkit$event$inventory$InventoryCloseEvent$Reason {
  static UNKNOWN: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static TELEPORT: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static CANT_USE: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static UNLOADED: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static OPEN_NEW: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static PLAYER: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static DISCONNECT: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static DEATH: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static PLUGIN: org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  static values(): JavaArray<
    org$bukkit$event$inventory$InventoryCloseEvent$Reason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$inventory$InventoryCloseEvent$Reason;
}


declare interface $org$bukkit$GameMode {
  getValue(): number;
}

declare class org$bukkit$GameMode implements $org$bukkit$GameMode {
  static CREATIVE: org$bukkit$GameMode;
  static SURVIVAL: org$bukkit$GameMode;
  static ADVENTURE: org$bukkit$GameMode;
  static SPECTATOR: org$bukkit$GameMode;
  static values(): JavaArray<org$bukkit$GameMode>;
  static valueOf(arg0: string): org$bukkit$GameMode;
  getValue(): number;
  static getByValue(arg0: number): org$bukkit$GameMode;
}


declare interface $org$bukkit$block$Sign
  extends $org$bukkit$block$TileState,
    $org$bukkit$material$Colorable {
  getLines(): JavaArray<string>;
  getLine(arg0: number): string;
  setLine(arg0: number, arg1: string): void;
  isEditable(): boolean;
  setEditable(arg0: boolean): void;
}

declare class org$bukkit$block$Sign implements $org$bukkit$block$Sign {
  getLines(): JavaArray<string>;
  getLine(arg0: number): string;
  setLine(arg0: number, arg1: string): void;
  isEditable(): boolean;
  setEditable(arg0: boolean): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$TileState
  extends $org$bukkit$block$BlockState,
    $org$bukkit$persistence$PersistentDataHolder {
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}

declare class org$bukkit$block$TileState
  implements $org$bukkit$block$TileState {
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$material$Colorable {
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
}

declare class org$bukkit$material$Colorable
  implements $org$bukkit$material$Colorable {
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
}


declare interface $org$bukkit$loot$LootContext$1 {}

declare class org$bukkit$loot$LootContext$1
  implements $org$bukkit$loot$LootContext$1 {}


declare interface $com$destroystokyo$paper$entity$Pathfinder {
  getEntity(): org$bukkit$entity$Mob;
  stopPathfinding(): void;
  hasPath(): boolean;
  getCurrentPath(): com$destroystokyo$paper$entity$Pathfinder$PathResult;
  findPath(
    arg0: org$bukkit$Location
  ): com$destroystokyo$paper$entity$Pathfinder$PathResult;
  findPath(
    arg0: org$bukkit$entity$LivingEntity
  ): com$destroystokyo$paper$entity$Pathfinder$PathResult;
  moveTo(arg0: org$bukkit$Location): boolean;
  moveTo(arg0: org$bukkit$Location, arg1: number): boolean;
  moveTo(arg0: org$bukkit$entity$LivingEntity): boolean;
  moveTo(arg0: org$bukkit$entity$LivingEntity, arg1: number): boolean;
  moveTo(arg0: com$destroystokyo$paper$entity$Pathfinder$PathResult): boolean;
  moveTo(
    arg0: com$destroystokyo$paper$entity$Pathfinder$PathResult,
    arg1: number
  ): boolean;
  canOpenDoors(): boolean;
  setCanOpenDoors(arg0: boolean): void;
  canPassDoors(): boolean;
  setCanPassDoors(arg0: boolean): void;
  canFloat(): boolean;
  setCanFloat(arg0: boolean): void;
}

declare class com$destroystokyo$paper$entity$Pathfinder
  implements $com$destroystokyo$paper$entity$Pathfinder {
  getEntity(): org$bukkit$entity$Mob;
  stopPathfinding(): void;
  hasPath(): boolean;
  getCurrentPath(): com$destroystokyo$paper$entity$Pathfinder$PathResult;
  findPath(
    arg0: org$bukkit$Location
  ): com$destroystokyo$paper$entity$Pathfinder$PathResult;
  findPath(
    arg0: org$bukkit$entity$LivingEntity
  ): com$destroystokyo$paper$entity$Pathfinder$PathResult;
  moveTo(arg0: org$bukkit$Location): boolean;
  moveTo(arg0: org$bukkit$Location, arg1: number): boolean;
  moveTo(arg0: org$bukkit$entity$LivingEntity): boolean;
  moveTo(arg0: org$bukkit$entity$LivingEntity, arg1: number): boolean;
  moveTo(arg0: com$destroystokyo$paper$entity$Pathfinder$PathResult): boolean;
  moveTo(
    arg0: com$destroystokyo$paper$entity$Pathfinder$PathResult,
    arg1: number
  ): boolean;
  canOpenDoors(): boolean;
  setCanOpenDoors(arg0: boolean): void;
  canPassDoors(): boolean;
  setCanPassDoors(arg0: boolean): void;
  canFloat(): boolean;
  setCanFloat(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$entity$Pathfinder$PathResult {
  getPoints(): any /* java.util.List */;
  getNextPointIndex(): number;
  getNextPoint(): org$bukkit$Location;
  getFinalPoint(): org$bukkit$Location;
}

declare class com$destroystokyo$paper$entity$Pathfinder$PathResult
  implements $com$destroystokyo$paper$entity$Pathfinder$PathResult {
  getPoints(): any /* java.util.List */;
  getNextPointIndex(): number;
  getNextPoint(): org$bukkit$Location;
  getFinalPoint(): org$bukkit$Location;
}


declare interface $org$bukkit$entity$EnderDragon$Phase {}

declare class org$bukkit$entity$EnderDragon$Phase
  implements $org$bukkit$entity$EnderDragon$Phase {
  static CIRCLING: org$bukkit$entity$EnderDragon$Phase;
  static STRAFING: org$bukkit$entity$EnderDragon$Phase;
  static FLY_TO_PORTAL: org$bukkit$entity$EnderDragon$Phase;
  static LAND_ON_PORTAL: org$bukkit$entity$EnderDragon$Phase;
  static LEAVE_PORTAL: org$bukkit$entity$EnderDragon$Phase;
  static BREATH_ATTACK: org$bukkit$entity$EnderDragon$Phase;
  static SEARCH_FOR_BREATH_ATTACK_TARGET: org$bukkit$entity$EnderDragon$Phase;
  static ROAR_BEFORE_ATTACK: org$bukkit$entity$EnderDragon$Phase;
  static CHARGE_PLAYER: org$bukkit$entity$EnderDragon$Phase;
  static DYING: org$bukkit$entity$EnderDragon$Phase;
  static HOVER: org$bukkit$entity$EnderDragon$Phase;
  static values(): JavaArray<org$bukkit$entity$EnderDragon$Phase>;
  static valueOf(arg0: string): org$bukkit$entity$EnderDragon$Phase;
}


declare interface $org$bukkit$boss$DragonBattle$RespawnPhase {}

declare class org$bukkit$boss$DragonBattle$RespawnPhase
  implements $org$bukkit$boss$DragonBattle$RespawnPhase {
  static START: org$bukkit$boss$DragonBattle$RespawnPhase;
  static PREPARING_TO_SUMMON_PILLARS: org$bukkit$boss$DragonBattle$RespawnPhase;
  static SUMMONING_PILLARS: org$bukkit$boss$DragonBattle$RespawnPhase;
  static SUMMONING_DRAGON: org$bukkit$boss$DragonBattle$RespawnPhase;
  static END: org$bukkit$boss$DragonBattle$RespawnPhase;
  static NONE: org$bukkit$boss$DragonBattle$RespawnPhase;
  static values(): JavaArray<org$bukkit$boss$DragonBattle$RespawnPhase>;
  static valueOf(arg0: string): org$bukkit$boss$DragonBattle$RespawnPhase;
}


declare interface $org$bukkit$Statistic extends $org$bukkit$Keyed {
  getType(): org$bukkit$Statistic$Type;
  isSubstatistic(): boolean;
  isBlock(): boolean;
  getKey(): org$bukkit$NamespacedKey;
}

declare class org$bukkit$Statistic implements $org$bukkit$Statistic {
  static DAMAGE_DEALT: org$bukkit$Statistic;
  static DAMAGE_TAKEN: org$bukkit$Statistic;
  static DEATHS: org$bukkit$Statistic;
  static MOB_KILLS: org$bukkit$Statistic;
  static PLAYER_KILLS: org$bukkit$Statistic;
  static FISH_CAUGHT: org$bukkit$Statistic;
  static ANIMALS_BRED: org$bukkit$Statistic;
  static LEAVE_GAME: org$bukkit$Statistic;
  static JUMP: org$bukkit$Statistic;
  static DROP_COUNT: org$bukkit$Statistic;
  static DROP: org$bukkit$Statistic;
  static PICKUP: org$bukkit$Statistic;
  static PLAY_ONE_MINUTE: org$bukkit$Statistic;
  static WALK_ONE_CM: org$bukkit$Statistic;
  static WALK_ON_WATER_ONE_CM: org$bukkit$Statistic;
  static FALL_ONE_CM: org$bukkit$Statistic;
  static SNEAK_TIME: org$bukkit$Statistic;
  static CLIMB_ONE_CM: org$bukkit$Statistic;
  static FLY_ONE_CM: org$bukkit$Statistic;
  static WALK_UNDER_WATER_ONE_CM: org$bukkit$Statistic;
  static MINECART_ONE_CM: org$bukkit$Statistic;
  static BOAT_ONE_CM: org$bukkit$Statistic;
  static PIG_ONE_CM: org$bukkit$Statistic;
  static HORSE_ONE_CM: org$bukkit$Statistic;
  static SPRINT_ONE_CM: org$bukkit$Statistic;
  static CROUCH_ONE_CM: org$bukkit$Statistic;
  static AVIATE_ONE_CM: org$bukkit$Statistic;
  static MINE_BLOCK: org$bukkit$Statistic;
  static USE_ITEM: org$bukkit$Statistic;
  static BREAK_ITEM: org$bukkit$Statistic;
  static CRAFT_ITEM: org$bukkit$Statistic;
  static KILL_ENTITY: org$bukkit$Statistic;
  static ENTITY_KILLED_BY: org$bukkit$Statistic;
  static TIME_SINCE_DEATH: org$bukkit$Statistic;
  static TALKED_TO_VILLAGER: org$bukkit$Statistic;
  static TRADED_WITH_VILLAGER: org$bukkit$Statistic;
  static CAKE_SLICES_EATEN: org$bukkit$Statistic;
  static CAULDRON_FILLED: org$bukkit$Statistic;
  static CAULDRON_USED: org$bukkit$Statistic;
  static ARMOR_CLEANED: org$bukkit$Statistic;
  static BANNER_CLEANED: org$bukkit$Statistic;
  static BREWINGSTAND_INTERACTION: org$bukkit$Statistic;
  static BEACON_INTERACTION: org$bukkit$Statistic;
  static DROPPER_INSPECTED: org$bukkit$Statistic;
  static HOPPER_INSPECTED: org$bukkit$Statistic;
  static DISPENSER_INSPECTED: org$bukkit$Statistic;
  static NOTEBLOCK_PLAYED: org$bukkit$Statistic;
  static NOTEBLOCK_TUNED: org$bukkit$Statistic;
  static FLOWER_POTTED: org$bukkit$Statistic;
  static TRAPPED_CHEST_TRIGGERED: org$bukkit$Statistic;
  static ENDERCHEST_OPENED: org$bukkit$Statistic;
  static ITEM_ENCHANTED: org$bukkit$Statistic;
  static RECORD_PLAYED: org$bukkit$Statistic;
  static FURNACE_INTERACTION: org$bukkit$Statistic;
  static CRAFTING_TABLE_INTERACTION: org$bukkit$Statistic;
  static CHEST_OPENED: org$bukkit$Statistic;
  static SLEEP_IN_BED: org$bukkit$Statistic;
  static SHULKER_BOX_OPENED: org$bukkit$Statistic;
  static TIME_SINCE_REST: org$bukkit$Statistic;
  static SWIM_ONE_CM: org$bukkit$Statistic;
  static DAMAGE_DEALT_ABSORBED: org$bukkit$Statistic;
  static DAMAGE_DEALT_RESISTED: org$bukkit$Statistic;
  static DAMAGE_BLOCKED_BY_SHIELD: org$bukkit$Statistic;
  static DAMAGE_ABSORBED: org$bukkit$Statistic;
  static DAMAGE_RESISTED: org$bukkit$Statistic;
  static CLEAN_SHULKER_BOX: org$bukkit$Statistic;
  static OPEN_BARREL: org$bukkit$Statistic;
  static INTERACT_WITH_BLAST_FURNACE: org$bukkit$Statistic;
  static INTERACT_WITH_SMOKER: org$bukkit$Statistic;
  static INTERACT_WITH_LECTERN: org$bukkit$Statistic;
  static INTERACT_WITH_CAMPFIRE: org$bukkit$Statistic;
  static INTERACT_WITH_CARTOGRAPHY_TABLE: org$bukkit$Statistic;
  static INTERACT_WITH_LOOM: org$bukkit$Statistic;
  static INTERACT_WITH_STONECUTTER: org$bukkit$Statistic;
  static BELL_RING: org$bukkit$Statistic;
  static RAID_TRIGGER: org$bukkit$Statistic;
  static RAID_WIN: org$bukkit$Statistic;
  static INTERACT_WITH_ANVIL: org$bukkit$Statistic;
  static INTERACT_WITH_GRINDSTONE: org$bukkit$Statistic;
  static values(): JavaArray<org$bukkit$Statistic>;
  static valueOf(arg0: string): org$bukkit$Statistic;
  getType(): org$bukkit$Statistic$Type;
  isSubstatistic(): boolean;
  isBlock(): boolean;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$Statistic$Type {}

declare class org$bukkit$Statistic$Type implements $org$bukkit$Statistic$Type {
  static UNTYPED: org$bukkit$Statistic$Type;
  static ITEM: org$bukkit$Statistic$Type;
  static BLOCK: org$bukkit$Statistic$Type;
  static ENTITY: org$bukkit$Statistic$Type;
  static values(): JavaArray<org$bukkit$Statistic$Type>;
  static valueOf(arg0: string): org$bukkit$Statistic$Type;
}


declare interface $org$bukkit$conversations$Conversable {
  isConversing(): boolean;
  acceptConversationInput(arg0: string): void;
  beginConversation(arg0: org$bukkit$conversations$Conversation): boolean;
  abandonConversation(arg0: org$bukkit$conversations$Conversation): void;
  abandonConversation(
    arg0: org$bukkit$conversations$Conversation,
    arg1: org$bukkit$conversations$ConversationAbandonedEvent
  ): void;
  sendRawMessage(arg0: string): void;
}

declare class org$bukkit$conversations$Conversable
  implements $org$bukkit$conversations$Conversable {
  isConversing(): boolean;
  acceptConversationInput(arg0: string): void;
  beginConversation(arg0: org$bukkit$conversations$Conversation): boolean;
  abandonConversation(arg0: org$bukkit$conversations$Conversation): void;
  abandonConversation(
    arg0: org$bukkit$conversations$Conversation,
    arg1: org$bukkit$conversations$ConversationAbandonedEvent
  ): void;
  sendRawMessage(arg0: string): void;
}


declare interface $org$bukkit$conversations$Conversation {
  getForWhom(): org$bukkit$conversations$Conversable;
  isModal(): boolean;
  setModal(arg0: boolean): void;
  isLocalEchoEnabled(): boolean;
  setLocalEchoEnabled(arg0: boolean): void;
  getPrefix(): org$bukkit$conversations$ConversationPrefix;
  setPrefix(arg0: org$bukkit$conversations$ConversationPrefix): void;
  addConversationCanceller(
    arg0: org$bukkit$conversations$ConversationCanceller
  ): void;
  getCancellers(): any /* java.util.List */;
  getContext(): org$bukkit$conversations$ConversationContext;
  begin(): void;
  getState(): org$bukkit$conversations$Conversation$ConversationState;
  acceptInput(arg0: string): void;
  addConversationAbandonedListener(
    arg0: org$bukkit$conversations$ConversationAbandonedListener
  ): void;
  removeConversationAbandonedListener(
    arg0: org$bukkit$conversations$ConversationAbandonedListener
  ): void;
  abandon(): void;
  abandon(arg0: org$bukkit$conversations$ConversationAbandonedEvent): void;
  outputNextPrompt(): void;
}

declare class org$bukkit$conversations$Conversation
  implements $org$bukkit$conversations$Conversation {
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$conversations$Conversable,
    arg2: org$bukkit$conversations$Prompt
  );
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$conversations$Conversable,
    arg2: org$bukkit$conversations$Prompt,
    arg3: any /* java.util.Map */
  );
  getForWhom(): org$bukkit$conversations$Conversable;
  isModal(): boolean;
  setModal(arg0: boolean): void;
  isLocalEchoEnabled(): boolean;
  setLocalEchoEnabled(arg0: boolean): void;
  getPrefix(): org$bukkit$conversations$ConversationPrefix;
  setPrefix(arg0: org$bukkit$conversations$ConversationPrefix): void;
  addConversationCanceller(
    arg0: org$bukkit$conversations$ConversationCanceller
  ): void;
  getCancellers(): any /* java.util.List */;
  getContext(): org$bukkit$conversations$ConversationContext;
  begin(): void;
  getState(): org$bukkit$conversations$Conversation$ConversationState;
  acceptInput(arg0: string): void;
  addConversationAbandonedListener(
    arg0: org$bukkit$conversations$ConversationAbandonedListener
  ): void;
  removeConversationAbandonedListener(
    arg0: org$bukkit$conversations$ConversationAbandonedListener
  ): void;
  abandon(): void;
  abandon(arg0: org$bukkit$conversations$ConversationAbandonedEvent): void;
  outputNextPrompt(): void;
}


declare interface $org$bukkit$conversations$Prompt {
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}

declare class org$bukkit$conversations$Prompt
  implements $org$bukkit$conversations$Prompt {
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$ConversationContext {
  getPlugin(): org$bukkit$plugin$Plugin;
  getForWhom(): org$bukkit$conversations$Conversable;
  getAllSessionData(): any /* java.util.Map */;
  getSessionData(arg0: any): any;
  setSessionData(arg0: any, arg1: any): void;
}

declare class org$bukkit$conversations$ConversationContext
  implements $org$bukkit$conversations$ConversationContext {
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$conversations$Conversable,
    arg2: any /* java.util.Map */
  );
  getPlugin(): org$bukkit$plugin$Plugin;
  getForWhom(): org$bukkit$conversations$Conversable;
  getAllSessionData(): any /* java.util.Map */;
  getSessionData(arg0: any): any;
  setSessionData(arg0: any, arg1: any): void;
}


declare interface $org$bukkit$conversations$ConversationPrefix {
  getPrefix(arg0: org$bukkit$conversations$ConversationContext): string;
}

declare class org$bukkit$conversations$ConversationPrefix
  implements $org$bukkit$conversations$ConversationPrefix {
  getPrefix(arg0: org$bukkit$conversations$ConversationContext): string;
}


declare interface $org$bukkit$conversations$ConversationCanceller {
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
}

declare class org$bukkit$conversations$ConversationCanceller
  implements $org$bukkit$conversations$ConversationCanceller {
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
}


declare interface $org$bukkit$conversations$Conversation$ConversationState {}

declare class org$bukkit$conversations$Conversation$ConversationState
  implements $org$bukkit$conversations$Conversation$ConversationState {
  static UNSTARTED: org$bukkit$conversations$Conversation$ConversationState;
  static STARTED: org$bukkit$conversations$Conversation$ConversationState;
  static ABANDONED: org$bukkit$conversations$Conversation$ConversationState;
  static values(): JavaArray<
    org$bukkit$conversations$Conversation$ConversationState
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$conversations$Conversation$ConversationState;
}


declare interface $org$bukkit$conversations$ConversationAbandonedListener {
  conversationAbandoned(
    arg0: org$bukkit$conversations$ConversationAbandonedEvent
  ): void;
}

declare class org$bukkit$conversations$ConversationAbandonedListener
  implements $org$bukkit$conversations$ConversationAbandonedListener {
  conversationAbandoned(
    arg0: org$bukkit$conversations$ConversationAbandonedEvent
  ): void;
}


declare interface $org$bukkit$conversations$ConversationAbandonedEvent {
  getCanceller(): org$bukkit$conversations$ConversationCanceller;
  getContext(): org$bukkit$conversations$ConversationContext;
  gracefulExit(): boolean;
}

declare class org$bukkit$conversations$ConversationAbandonedEvent
  implements $org$bukkit$conversations$ConversationAbandonedEvent {
  constructor(arg0: org$bukkit$conversations$Conversation);
  constructor(
    arg0: org$bukkit$conversations$Conversation,
    arg1: org$bukkit$conversations$ConversationCanceller
  );
  getCanceller(): org$bukkit$conversations$ConversationCanceller;
  getContext(): org$bukkit$conversations$ConversationContext;
  gracefulExit(): boolean;
}


declare interface $org$bukkit$Instrument {
  getType(): Buffer;
}

declare class org$bukkit$Instrument implements $org$bukkit$Instrument {
  static PIANO: org$bukkit$Instrument;
  static BASS_DRUM: org$bukkit$Instrument;
  static SNARE_DRUM: org$bukkit$Instrument;
  static STICKS: org$bukkit$Instrument;
  static BASS_GUITAR: org$bukkit$Instrument;
  static FLUTE: org$bukkit$Instrument;
  static BELL: org$bukkit$Instrument;
  static GUITAR: org$bukkit$Instrument;
  static CHIME: org$bukkit$Instrument;
  static XYLOPHONE: org$bukkit$Instrument;
  static IRON_XYLOPHONE: org$bukkit$Instrument;
  static COW_BELL: org$bukkit$Instrument;
  static DIDGERIDOO: org$bukkit$Instrument;
  static BIT: org$bukkit$Instrument;
  static BANJO: org$bukkit$Instrument;
  static PLING: org$bukkit$Instrument;
  static values(): JavaArray<org$bukkit$Instrument>;
  static valueOf(arg0: string): org$bukkit$Instrument;
  getType(): Buffer;
  static getByType(arg0: Buffer): org$bukkit$Instrument;
}


declare interface $org$bukkit$Note {
  sharped(): org$bukkit$Note;
  flattened(): org$bukkit$Note;
  getId(): Buffer;
  getOctave(): number;
  getTone(): org$bukkit$Note$Tone;
  isSharped(): boolean;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
}

declare class org$bukkit$Note implements $org$bukkit$Note {
  constructor(arg0: number);
  constructor(arg0: number, arg1: org$bukkit$Note$Tone, arg2: boolean);
  static flat(arg0: number, arg1: org$bukkit$Note$Tone): org$bukkit$Note;
  static sharp(arg0: number, arg1: org$bukkit$Note$Tone): org$bukkit$Note;
  static natural(arg0: number, arg1: org$bukkit$Note$Tone): org$bukkit$Note;
  sharped(): org$bukkit$Note;
  flattened(): org$bukkit$Note;
  getId(): Buffer;
  getOctave(): number;
  getTone(): org$bukkit$Note$Tone;
  isSharped(): boolean;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
}


declare interface $org$bukkit$Note$Tone {
  getId(): Buffer;
  getId(arg0: boolean): Buffer;
  isSharpable(): boolean;
  isSharped(arg0: Buffer): boolean;
}

declare class org$bukkit$Note$Tone implements $org$bukkit$Note$Tone {
  static G: org$bukkit$Note$Tone;
  static A: org$bukkit$Note$Tone;
  static B: org$bukkit$Note$Tone;
  static C: org$bukkit$Note$Tone;
  static D: org$bukkit$Note$Tone;
  static E: org$bukkit$Note$Tone;
  static F: org$bukkit$Note$Tone;
  static TONES_COUNT: Buffer;
  static values(): JavaArray<org$bukkit$Note$Tone>;
  static valueOf(arg0: string): org$bukkit$Note$Tone;
  getId(): Buffer;
  getId(arg0: boolean): Buffer;
  isSharpable(): boolean;
  isSharped(arg0: Buffer): boolean;
  static getById(arg0: Buffer): org$bukkit$Note$Tone;
}


declare interface $org$bukkit$map$MapView {
  getId(): number;
  isVirtual(): boolean;
  getScale(): org$bukkit$map$MapView$Scale;
  setScale(arg0: org$bukkit$map$MapView$Scale): void;
  getCenterX(): number;
  getCenterZ(): number;
  setCenterX(arg0: number): void;
  setCenterZ(arg0: number): void;
  getWorld(): org$bukkit$World;
  setWorld(arg0: org$bukkit$World): void;
  getRenderers(): any /* java.util.List */;
  addRenderer(arg0: org$bukkit$map$MapRenderer): void;
  removeRenderer(arg0: org$bukkit$map$MapRenderer): boolean;
  isTrackingPosition(): boolean;
  setTrackingPosition(arg0: boolean): void;
  isUnlimitedTracking(): boolean;
  setUnlimitedTracking(arg0: boolean): void;
  isLocked(): boolean;
  setLocked(arg0: boolean): void;
}

declare class org$bukkit$map$MapView implements $org$bukkit$map$MapView {
  getId(): number;
  isVirtual(): boolean;
  getScale(): org$bukkit$map$MapView$Scale;
  setScale(arg0: org$bukkit$map$MapView$Scale): void;
  getCenterX(): number;
  getCenterZ(): number;
  setCenterX(arg0: number): void;
  setCenterZ(arg0: number): void;
  getWorld(): org$bukkit$World;
  setWorld(arg0: org$bukkit$World): void;
  getRenderers(): any /* java.util.List */;
  addRenderer(arg0: org$bukkit$map$MapRenderer): void;
  removeRenderer(arg0: org$bukkit$map$MapRenderer): boolean;
  isTrackingPosition(): boolean;
  setTrackingPosition(arg0: boolean): void;
  isUnlimitedTracking(): boolean;
  setUnlimitedTracking(arg0: boolean): void;
  isLocked(): boolean;
  setLocked(arg0: boolean): void;
}


declare interface $org$bukkit$map$MapView$Scale {
  getValue(): Buffer;
}

declare class org$bukkit$map$MapView$Scale
  implements $org$bukkit$map$MapView$Scale {
  static CLOSEST: org$bukkit$map$MapView$Scale;
  static CLOSE: org$bukkit$map$MapView$Scale;
  static NORMAL: org$bukkit$map$MapView$Scale;
  static FAR: org$bukkit$map$MapView$Scale;
  static FARTHEST: org$bukkit$map$MapView$Scale;
  static values(): JavaArray<org$bukkit$map$MapView$Scale>;
  static valueOf(arg0: string): org$bukkit$map$MapView$Scale;
  static valueOf(arg0: Buffer): org$bukkit$map$MapView$Scale;
  getValue(): Buffer;
}


declare interface $org$bukkit$map$MapRenderer {
  isContextual(): boolean;
  initialize(arg0: org$bukkit$map$MapView): void;
  render(
    arg0: org$bukkit$map$MapView,
    arg1: org$bukkit$map$MapCanvas,
    arg2: org$bukkit$entity$Player
  ): void;
}

declare class org$bukkit$map$MapRenderer
  implements $org$bukkit$map$MapRenderer {
  constructor();
  constructor(arg0: boolean);
  isContextual(): boolean;
  initialize(arg0: org$bukkit$map$MapView): void;
  render(
    arg0: org$bukkit$map$MapView,
    arg1: org$bukkit$map$MapCanvas,
    arg2: org$bukkit$entity$Player
  ): void;
}


declare interface $org$bukkit$map$MapCanvas {
  getMapView(): org$bukkit$map$MapView;
  getCursors(): org$bukkit$map$MapCursorCollection;
  setCursors(arg0: org$bukkit$map$MapCursorCollection): void;
  setPixel(arg0: number, arg1: number, arg2: Buffer): void;
  getPixel(arg0: number, arg1: number): Buffer;
  getBasePixel(arg0: number, arg1: number): Buffer;
  drawImage(arg0: number, arg1: number, arg2: any /* java.awt.Image */): void;
  drawText(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$map$MapFont,
    arg3: string
  ): void;
}

declare class org$bukkit$map$MapCanvas implements $org$bukkit$map$MapCanvas {
  getMapView(): org$bukkit$map$MapView;
  getCursors(): org$bukkit$map$MapCursorCollection;
  setCursors(arg0: org$bukkit$map$MapCursorCollection): void;
  setPixel(arg0: number, arg1: number, arg2: Buffer): void;
  getPixel(arg0: number, arg1: number): Buffer;
  getBasePixel(arg0: number, arg1: number): Buffer;
  drawImage(arg0: number, arg1: number, arg2: any /* java.awt.Image */): void;
  drawText(
    arg0: number,
    arg1: number,
    arg2: org$bukkit$map$MapFont,
    arg3: string
  ): void;
}


declare interface $org$bukkit$map$MapCursorCollection {
  size(): number;
  getCursor(arg0: number): org$bukkit$map$MapCursor;
  removeCursor(arg0: org$bukkit$map$MapCursor): boolean;
  addCursor(arg0: org$bukkit$map$MapCursor): org$bukkit$map$MapCursor;
  addCursor(arg0: number, arg1: number, arg2: Buffer): org$bukkit$map$MapCursor;
  addCursor(
    arg0: number,
    arg1: number,
    arg2: Buffer,
    arg3: Buffer
  ): org$bukkit$map$MapCursor;
  addCursor(
    arg0: number,
    arg1: number,
    arg2: Buffer,
    arg3: Buffer,
    arg4: boolean
  ): org$bukkit$map$MapCursor;
  addCursor(
    arg0: number,
    arg1: number,
    arg2: Buffer,
    arg3: Buffer,
    arg4: boolean,
    arg5: string
  ): org$bukkit$map$MapCursor;
}

declare class org$bukkit$map$MapCursorCollection
  implements $org$bukkit$map$MapCursorCollection {
  constructor();
  size(): number;
  getCursor(arg0: number): org$bukkit$map$MapCursor;
  removeCursor(arg0: org$bukkit$map$MapCursor): boolean;
  addCursor(arg0: org$bukkit$map$MapCursor): org$bukkit$map$MapCursor;
  addCursor(arg0: number, arg1: number, arg2: Buffer): org$bukkit$map$MapCursor;
  addCursor(
    arg0: number,
    arg1: number,
    arg2: Buffer,
    arg3: Buffer
  ): org$bukkit$map$MapCursor;
  addCursor(
    arg0: number,
    arg1: number,
    arg2: Buffer,
    arg3: Buffer,
    arg4: boolean
  ): org$bukkit$map$MapCursor;
  addCursor(
    arg0: number,
    arg1: number,
    arg2: Buffer,
    arg3: Buffer,
    arg4: boolean,
    arg5: string
  ): org$bukkit$map$MapCursor;
}


declare interface $org$bukkit$map$MapCursor {
  getX(): Buffer;
  getY(): Buffer;
  getDirection(): Buffer;
  getType(): org$bukkit$map$MapCursor$Type;
  getRawType(): Buffer;
  isVisible(): boolean;
  setX(arg0: Buffer): void;
  setY(arg0: Buffer): void;
  setDirection(arg0: Buffer): void;
  setType(arg0: org$bukkit$map$MapCursor$Type): void;
  setRawType(arg0: Buffer): void;
  setVisible(arg0: boolean): void;
  getCaption(): string;
  setCaption(arg0: string): void;
}

declare class org$bukkit$map$MapCursor implements $org$bukkit$map$MapCursor {
  constructor(
    arg0: Buffer,
    arg1: Buffer,
    arg2: Buffer,
    arg3: Buffer,
    arg4: boolean
  );
  constructor(
    arg0: Buffer,
    arg1: Buffer,
    arg2: Buffer,
    arg3: org$bukkit$map$MapCursor$Type,
    arg4: boolean
  );
  constructor(
    arg0: Buffer,
    arg1: Buffer,
    arg2: Buffer,
    arg3: Buffer,
    arg4: boolean,
    arg5: string
  );
  constructor(
    arg0: Buffer,
    arg1: Buffer,
    arg2: Buffer,
    arg3: org$bukkit$map$MapCursor$Type,
    arg4: boolean,
    arg5: string
  );
  getX(): Buffer;
  getY(): Buffer;
  getDirection(): Buffer;
  getType(): org$bukkit$map$MapCursor$Type;
  getRawType(): Buffer;
  isVisible(): boolean;
  setX(arg0: Buffer): void;
  setY(arg0: Buffer): void;
  setDirection(arg0: Buffer): void;
  setType(arg0: org$bukkit$map$MapCursor$Type): void;
  setRawType(arg0: Buffer): void;
  setVisible(arg0: boolean): void;
  getCaption(): string;
  setCaption(arg0: string): void;
}


declare interface $org$bukkit$map$MapFont {
  setChar(arg0: string, arg1: org$bukkit$map$MapFont$CharacterSprite): void;
  getChar(arg0: string): org$bukkit$map$MapFont$CharacterSprite;
  getWidth(arg0: string): number;
  getHeight(): number;
  isValid(arg0: string): boolean;
}

declare class org$bukkit$map$MapFont implements $org$bukkit$map$MapFont {
  constructor();
  setChar(arg0: string, arg1: org$bukkit$map$MapFont$CharacterSprite): void;
  getChar(arg0: string): org$bukkit$map$MapFont$CharacterSprite;
  getWidth(arg0: string): number;
  getHeight(): number;
  isValid(arg0: string): boolean;
}


declare interface $org$bukkit$map$MapFont$CharacterSprite {
  get(arg0: number, arg1: number): boolean;
  getWidth(): number;
  getHeight(): number;
}

declare class org$bukkit$map$MapFont$CharacterSprite
  implements $org$bukkit$map$MapFont$CharacterSprite {
  constructor(arg0: number, arg1: number, arg2: JavaArray<boolean>);
  get(arg0: number, arg1: number): boolean;
  getWidth(): number;
  getHeight(): number;
}


declare interface $com$destroystokyo$paper$Title {
  getTitle(): JavaArray<unknown>;
  getSubtitle(): JavaArray<unknown>;
  getFadeIn(): number;
  getStay(): number;
  getFadeOut(): number;
}

declare class com$destroystokyo$paper$Title
  implements $com$destroystokyo$paper$Title {
  static DEFAULT_FADE_IN: number;
  static DEFAULT_STAY: number;
  static DEFAULT_FADE_OUT: number;
  constructor(arg0: unknown);
  constructor(arg0: JavaArray<unknown>);
  constructor(arg0: string);
  constructor(arg0: unknown, arg1: unknown);
  constructor(arg0: JavaArray<unknown>, arg1: JavaArray<unknown>);
  constructor(arg0: string, arg1: string);
  constructor(
    arg0: unknown,
    arg1: unknown,
    arg2: number,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: JavaArray<unknown>,
    arg1: JavaArray<unknown>,
    arg2: number,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: string,
    arg1: string,
    arg2: number,
    arg3: number,
    arg4: number
  );
  getTitle(): JavaArray<unknown>;
  getSubtitle(): JavaArray<unknown>;
  getFadeIn(): number;
  getStay(): number;
  getFadeOut(): number;
  static builder(): com$destroystokyo$paper$Title$Builder;
}


declare interface $com$destroystokyo$paper$Title$Builder {
  title(arg0: unknown): com$destroystokyo$paper$Title$Builder;
  title(arg0: JavaArray<unknown>): com$destroystokyo$paper$Title$Builder;
  title(arg0: string): com$destroystokyo$paper$Title$Builder;
  subtitle(arg0: unknown): com$destroystokyo$paper$Title$Builder;
  subtitle(arg0: JavaArray<unknown>): com$destroystokyo$paper$Title$Builder;
  subtitle(arg0: string): com$destroystokyo$paper$Title$Builder;
  fadeIn(arg0: number): com$destroystokyo$paper$Title$Builder;
  stay(arg0: number): com$destroystokyo$paper$Title$Builder;
  fadeOut(arg0: number): com$destroystokyo$paper$Title$Builder;
  build(): com$destroystokyo$paper$Title;
}

declare class com$destroystokyo$paper$Title$Builder
  implements $com$destroystokyo$paper$Title$Builder {
  constructor();
  title(arg0: unknown): com$destroystokyo$paper$Title$Builder;
  title(arg0: JavaArray<unknown>): com$destroystokyo$paper$Title$Builder;
  title(arg0: string): com$destroystokyo$paper$Title$Builder;
  subtitle(arg0: unknown): com$destroystokyo$paper$Title$Builder;
  subtitle(arg0: JavaArray<unknown>): com$destroystokyo$paper$Title$Builder;
  subtitle(arg0: string): com$destroystokyo$paper$Title$Builder;
  fadeIn(arg0: number): com$destroystokyo$paper$Title$Builder;
  stay(arg0: number): com$destroystokyo$paper$Title$Builder;
  fadeOut(arg0: number): com$destroystokyo$paper$Title$Builder;
  build(): com$destroystokyo$paper$Title;
}


declare interface $org$bukkit$WeatherType {}

declare class org$bukkit$WeatherType implements $org$bukkit$WeatherType {
  static DOWNFALL: org$bukkit$WeatherType;
  static CLEAR: org$bukkit$WeatherType;
  static values(): JavaArray<org$bukkit$WeatherType>;
  static valueOf(arg0: string): org$bukkit$WeatherType;
}


declare interface $org$bukkit$scoreboard$Scoreboard {
  registerNewObjective(
    arg0: string,
    arg1: string
  ): org$bukkit$scoreboard$Objective;
  registerNewObjective(
    arg0: string,
    arg1: string,
    arg2: string
  ): org$bukkit$scoreboard$Objective;
  registerNewObjective(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: org$bukkit$scoreboard$RenderType
  ): org$bukkit$scoreboard$Objective;
  getObjective(arg0: string): org$bukkit$scoreboard$Objective;
  getObjectivesByCriteria(arg0: string): any /* java.util.Set */;
  getObjectives(): any /* java.util.Set */;
  getObjective(
    arg0: org$bukkit$scoreboard$DisplaySlot
  ): org$bukkit$scoreboard$Objective;
  getScores(arg0: org$bukkit$OfflinePlayer): any /* java.util.Set */;
  getScores(arg0: string): any /* java.util.Set */;
  resetScores(arg0: org$bukkit$OfflinePlayer): void;
  resetScores(arg0: string): void;
  getPlayerTeam(arg0: org$bukkit$OfflinePlayer): org$bukkit$scoreboard$Team;
  getEntryTeam(arg0: string): org$bukkit$scoreboard$Team;
  getTeam(arg0: string): org$bukkit$scoreboard$Team;
  getTeams(): any /* java.util.Set */;
  registerNewTeam(arg0: string): org$bukkit$scoreboard$Team;
  getPlayers(): any /* java.util.Set */;
  getEntries(): any /* java.util.Set */;
  clearSlot(arg0: org$bukkit$scoreboard$DisplaySlot): void;
}

declare class org$bukkit$scoreboard$Scoreboard
  implements $org$bukkit$scoreboard$Scoreboard {
  registerNewObjective(
    arg0: string,
    arg1: string
  ): org$bukkit$scoreboard$Objective;
  registerNewObjective(
    arg0: string,
    arg1: string,
    arg2: string
  ): org$bukkit$scoreboard$Objective;
  registerNewObjective(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: org$bukkit$scoreboard$RenderType
  ): org$bukkit$scoreboard$Objective;
  getObjective(arg0: string): org$bukkit$scoreboard$Objective;
  getObjectivesByCriteria(arg0: string): any /* java.util.Set */;
  getObjectives(): any /* java.util.Set */;
  getObjective(
    arg0: org$bukkit$scoreboard$DisplaySlot
  ): org$bukkit$scoreboard$Objective;
  getScores(arg0: org$bukkit$OfflinePlayer): any /* java.util.Set */;
  getScores(arg0: string): any /* java.util.Set */;
  resetScores(arg0: org$bukkit$OfflinePlayer): void;
  resetScores(arg0: string): void;
  getPlayerTeam(arg0: org$bukkit$OfflinePlayer): org$bukkit$scoreboard$Team;
  getEntryTeam(arg0: string): org$bukkit$scoreboard$Team;
  getTeam(arg0: string): org$bukkit$scoreboard$Team;
  getTeams(): any /* java.util.Set */;
  registerNewTeam(arg0: string): org$bukkit$scoreboard$Team;
  getPlayers(): any /* java.util.Set */;
  getEntries(): any /* java.util.Set */;
  clearSlot(arg0: org$bukkit$scoreboard$DisplaySlot): void;
}


declare interface $org$bukkit$scoreboard$Objective {
  getName(): string;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  getCriteria(): string;
  isModifiable(): boolean;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
  unregister(): void;
  setDisplaySlot(arg0: org$bukkit$scoreboard$DisplaySlot): void;
  getDisplaySlot(): org$bukkit$scoreboard$DisplaySlot;
  setRenderType(arg0: org$bukkit$scoreboard$RenderType): void;
  getRenderType(): org$bukkit$scoreboard$RenderType;
  getScore(arg0: org$bukkit$OfflinePlayer): org$bukkit$scoreboard$Score;
  getScore(arg0: string): org$bukkit$scoreboard$Score;
}

declare class org$bukkit$scoreboard$Objective
  implements $org$bukkit$scoreboard$Objective {
  getName(): string;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  getCriteria(): string;
  isModifiable(): boolean;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
  unregister(): void;
  setDisplaySlot(arg0: org$bukkit$scoreboard$DisplaySlot): void;
  getDisplaySlot(): org$bukkit$scoreboard$DisplaySlot;
  setRenderType(arg0: org$bukkit$scoreboard$RenderType): void;
  getRenderType(): org$bukkit$scoreboard$RenderType;
  getScore(arg0: org$bukkit$OfflinePlayer): org$bukkit$scoreboard$Score;
  getScore(arg0: string): org$bukkit$scoreboard$Score;
}


declare interface $org$bukkit$scoreboard$DisplaySlot {}

declare class org$bukkit$scoreboard$DisplaySlot
  implements $org$bukkit$scoreboard$DisplaySlot {
  static BELOW_NAME: org$bukkit$scoreboard$DisplaySlot;
  static PLAYER_LIST: org$bukkit$scoreboard$DisplaySlot;
  static SIDEBAR: org$bukkit$scoreboard$DisplaySlot;
  static values(): JavaArray<org$bukkit$scoreboard$DisplaySlot>;
  static valueOf(arg0: string): org$bukkit$scoreboard$DisplaySlot;
}


declare interface $org$bukkit$scoreboard$RenderType {}

declare class org$bukkit$scoreboard$RenderType
  implements $org$bukkit$scoreboard$RenderType {
  static INTEGER: org$bukkit$scoreboard$RenderType;
  static HEARTS: org$bukkit$scoreboard$RenderType;
  static values(): JavaArray<org$bukkit$scoreboard$RenderType>;
  static valueOf(arg0: string): org$bukkit$scoreboard$RenderType;
}


declare interface $org$bukkit$scoreboard$Score {
  getPlayer(): org$bukkit$OfflinePlayer;
  getEntry(): string;
  getObjective(): org$bukkit$scoreboard$Objective;
  getScore(): number;
  setScore(arg0: number): void;
  isScoreSet(): boolean;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
}

declare class org$bukkit$scoreboard$Score
  implements $org$bukkit$scoreboard$Score {
  getPlayer(): org$bukkit$OfflinePlayer;
  getEntry(): string;
  getObjective(): org$bukkit$scoreboard$Objective;
  getScore(): number;
  setScore(arg0: number): void;
  isScoreSet(): boolean;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
}


declare interface $org$bukkit$scoreboard$Team {
  getName(): string;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  getPrefix(): string;
  setPrefix(arg0: string): void;
  getSuffix(): string;
  setSuffix(arg0: string): void;
  getColor(): org$bukkit$ChatColor;
  setColor(arg0: org$bukkit$ChatColor): void;
  allowFriendlyFire(): boolean;
  setAllowFriendlyFire(arg0: boolean): void;
  canSeeFriendlyInvisibles(): boolean;
  setCanSeeFriendlyInvisibles(arg0: boolean): void;
  getNameTagVisibility(): org$bukkit$scoreboard$NameTagVisibility;
  setNameTagVisibility(arg0: org$bukkit$scoreboard$NameTagVisibility): void;
  getPlayers(): any /* java.util.Set */;
  getEntries(): any /* java.util.Set */;
  getSize(): number;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
  addPlayer(arg0: org$bukkit$OfflinePlayer): void;
  addEntry(arg0: string): void;
  removePlayer(arg0: org$bukkit$OfflinePlayer): boolean;
  removeEntry(arg0: string): boolean;
  unregister(): void;
  hasPlayer(arg0: org$bukkit$OfflinePlayer): boolean;
  hasEntry(arg0: string): boolean;
  getOption(
    arg0: org$bukkit$scoreboard$Team$Option
  ): org$bukkit$scoreboard$Team$OptionStatus;
  setOption(
    arg0: org$bukkit$scoreboard$Team$Option,
    arg1: org$bukkit$scoreboard$Team$OptionStatus
  ): void;
}

declare class org$bukkit$scoreboard$Team
  implements $org$bukkit$scoreboard$Team {
  getName(): string;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  getPrefix(): string;
  setPrefix(arg0: string): void;
  getSuffix(): string;
  setSuffix(arg0: string): void;
  getColor(): org$bukkit$ChatColor;
  setColor(arg0: org$bukkit$ChatColor): void;
  allowFriendlyFire(): boolean;
  setAllowFriendlyFire(arg0: boolean): void;
  canSeeFriendlyInvisibles(): boolean;
  setCanSeeFriendlyInvisibles(arg0: boolean): void;
  getNameTagVisibility(): org$bukkit$scoreboard$NameTagVisibility;
  setNameTagVisibility(arg0: org$bukkit$scoreboard$NameTagVisibility): void;
  getPlayers(): any /* java.util.Set */;
  getEntries(): any /* java.util.Set */;
  getSize(): number;
  getScoreboard(): org$bukkit$scoreboard$Scoreboard;
  addPlayer(arg0: org$bukkit$OfflinePlayer): void;
  addEntry(arg0: string): void;
  removePlayer(arg0: org$bukkit$OfflinePlayer): boolean;
  removeEntry(arg0: string): boolean;
  unregister(): void;
  hasPlayer(arg0: org$bukkit$OfflinePlayer): boolean;
  hasEntry(arg0: string): boolean;
  getOption(
    arg0: org$bukkit$scoreboard$Team$Option
  ): org$bukkit$scoreboard$Team$OptionStatus;
  setOption(
    arg0: org$bukkit$scoreboard$Team$Option,
    arg1: org$bukkit$scoreboard$Team$OptionStatus
  ): void;
}


declare interface $org$bukkit$ChatColor {
  asBungee(): unknown;
  getChar(): string;
  toString(): string;
  isFormat(): boolean;
  isColor(): boolean;
}

declare class org$bukkit$ChatColor implements $org$bukkit$ChatColor {
  static BLACK: org$bukkit$ChatColor;
  static DARK_BLUE: org$bukkit$ChatColor;
  static DARK_GREEN: org$bukkit$ChatColor;
  static DARK_AQUA: org$bukkit$ChatColor;
  static DARK_RED: org$bukkit$ChatColor;
  static DARK_PURPLE: org$bukkit$ChatColor;
  static GOLD: org$bukkit$ChatColor;
  static GRAY: org$bukkit$ChatColor;
  static DARK_GRAY: org$bukkit$ChatColor;
  static BLUE: org$bukkit$ChatColor;
  static GREEN: org$bukkit$ChatColor;
  static AQUA: org$bukkit$ChatColor;
  static RED: org$bukkit$ChatColor;
  static LIGHT_PURPLE: org$bukkit$ChatColor;
  static YELLOW: org$bukkit$ChatColor;
  static WHITE: org$bukkit$ChatColor;
  static MAGIC: org$bukkit$ChatColor;
  static BOLD: org$bukkit$ChatColor;
  static STRIKETHROUGH: org$bukkit$ChatColor;
  static UNDERLINE: org$bukkit$ChatColor;
  static ITALIC: org$bukkit$ChatColor;
  static RESET: org$bukkit$ChatColor;
  static COLOR_CHAR: string;
  static values(): JavaArray<org$bukkit$ChatColor>;
  static valueOf(arg0: string): org$bukkit$ChatColor;
  asBungee(): unknown;
  getChar(): string;
  toString(): string;
  isFormat(): boolean;
  isColor(): boolean;
  static getByChar(arg0: string): org$bukkit$ChatColor;
  static stripColor(arg0: string): string;
  static translateAlternateColorCodes(arg0: string, arg1: string): string;
  static getLastColors(arg0: string): string;
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: org$bukkit$ChatColor$1
  );
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: boolean,
    arg5: org$bukkit$ChatColor$1
  );
}


declare interface $org$bukkit$ChatColor$1 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$1 implements $org$bukkit$ChatColor$1 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$scoreboard$NameTagVisibility {}

declare class org$bukkit$scoreboard$NameTagVisibility
  implements $org$bukkit$scoreboard$NameTagVisibility {
  static ALWAYS: org$bukkit$scoreboard$NameTagVisibility;
  static NEVER: org$bukkit$scoreboard$NameTagVisibility;
  static HIDE_FOR_OTHER_TEAMS: org$bukkit$scoreboard$NameTagVisibility;
  static HIDE_FOR_OWN_TEAM: org$bukkit$scoreboard$NameTagVisibility;
  static values(): JavaArray<org$bukkit$scoreboard$NameTagVisibility>;
  static valueOf(arg0: string): org$bukkit$scoreboard$NameTagVisibility;
}


declare interface $org$bukkit$scoreboard$Team$OptionStatus {}

declare class org$bukkit$scoreboard$Team$OptionStatus
  implements $org$bukkit$scoreboard$Team$OptionStatus {
  static ALWAYS: org$bukkit$scoreboard$Team$OptionStatus;
  static NEVER: org$bukkit$scoreboard$Team$OptionStatus;
  static FOR_OTHER_TEAMS: org$bukkit$scoreboard$Team$OptionStatus;
  static FOR_OWN_TEAM: org$bukkit$scoreboard$Team$OptionStatus;
  static values(): JavaArray<org$bukkit$scoreboard$Team$OptionStatus>;
  static valueOf(arg0: string): org$bukkit$scoreboard$Team$OptionStatus;
}


declare interface $org$bukkit$scoreboard$Team$Option {}

declare class org$bukkit$scoreboard$Team$Option
  implements $org$bukkit$scoreboard$Team$Option {
  static NAME_TAG_VISIBILITY: org$bukkit$scoreboard$Team$Option;
  static DEATH_MESSAGE_VISIBILITY: org$bukkit$scoreboard$Team$Option;
  static COLLISION_RULE: org$bukkit$scoreboard$Team$Option;
  static values(): JavaArray<org$bukkit$scoreboard$Team$Option>;
  static valueOf(arg0: string): org$bukkit$scoreboard$Team$Option;
}


declare interface $org$bukkit$advancement$AdvancementProgress {
  getAdvancement(): org$bukkit$advancement$Advancement;
  isDone(): boolean;
  awardCriteria(arg0: string): boolean;
  revokeCriteria(arg0: string): boolean;
  getDateAwarded(arg0: string): any /* java.util.Date */;
  getRemainingCriteria(): java$util$Collection;
  getAwardedCriteria(): java$util$Collection;
}

declare class org$bukkit$advancement$AdvancementProgress
  implements $org$bukkit$advancement$AdvancementProgress {
  getAdvancement(): org$bukkit$advancement$Advancement;
  isDone(): boolean;
  awardCriteria(arg0: string): boolean;
  revokeCriteria(arg0: string): boolean;
  getDateAwarded(arg0: string): any /* java.util.Date */;
  getRemainingCriteria(): java$util$Collection;
  getAwardedCriteria(): java$util$Collection;
}


declare interface $org$bukkit$advancement$Advancement
  extends $org$bukkit$Keyed {
  getCriteria(): java$util$Collection;
}

declare class org$bukkit$advancement$Advancement
  implements $org$bukkit$advancement$Advancement {
  getCriteria(): java$util$Collection;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$event$player$PlayerResourcePackStatusEvent$Status {}

declare class org$bukkit$event$player$PlayerResourcePackStatusEvent$Status
  implements $org$bukkit$event$player$PlayerResourcePackStatusEvent$Status {
  static SUCCESSFULLY_LOADED: org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  static DECLINED: org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  static FAILED_DOWNLOAD: org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  static ACCEPTED: org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  static values(): JavaArray<
    org$bukkit$event$player$PlayerResourcePackStatusEvent$Status
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
}


declare interface $com$destroystokyo$paper$profile$PlayerProfile {
  getName(): string;
  setName(arg0: string): string;
  getId(): any /* java.util.UUID */;
  setId(arg0: any /* java.util.UUID */): any /* java.util.UUID */;
  getProperties(): any /* java.util.Set */;
  hasProperty(arg0: string): boolean;
  setProperty(arg0: com$destroystokyo$paper$profile$ProfileProperty): void;
  setProperties(arg0: java$util$Collection): void;
  removeProperty(arg0: string): boolean;
  removeProperty(
    arg0: com$destroystokyo$paper$profile$ProfileProperty
  ): boolean;
  removeProperties(arg0: java$util$Collection): boolean;
  clearProperties(): void;
  isComplete(): boolean;
  completeFromCache(): boolean;
  completeFromCache(arg0: boolean): boolean;
  completeFromCache(arg0: boolean, arg1: boolean): boolean;
  complete(): boolean;
  complete(arg0: boolean): boolean;
  complete(arg0: boolean, arg1: boolean): boolean;
  hasTextures(): boolean;
}

declare class com$destroystokyo$paper$profile$PlayerProfile
  implements $com$destroystokyo$paper$profile$PlayerProfile {
  getName(): string;
  setName(arg0: string): string;
  getId(): any /* java.util.UUID */;
  setId(arg0: any /* java.util.UUID */): any /* java.util.UUID */;
  getProperties(): any /* java.util.Set */;
  hasProperty(arg0: string): boolean;
  setProperty(arg0: com$destroystokyo$paper$profile$ProfileProperty): void;
  setProperties(arg0: java$util$Collection): void;
  removeProperty(arg0: string): boolean;
  removeProperty(
    arg0: com$destroystokyo$paper$profile$ProfileProperty
  ): boolean;
  removeProperties(arg0: java$util$Collection): boolean;
  clearProperties(): void;
  isComplete(): boolean;
  completeFromCache(): boolean;
  completeFromCache(arg0: boolean): boolean;
  completeFromCache(arg0: boolean, arg1: boolean): boolean;
  complete(): boolean;
  complete(arg0: boolean): boolean;
  complete(arg0: boolean, arg1: boolean): boolean;
  hasTextures(): boolean;
}


declare interface $com$destroystokyo$paper$profile$ProfileProperty {
  getName(): string;
  getValue(): string;
  getSignature(): string;
  isSigned(): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class com$destroystokyo$paper$profile$ProfileProperty
  implements $com$destroystokyo$paper$profile$ProfileProperty {
  constructor(arg0: string, arg1: string);
  constructor(arg0: string, arg1: string, arg2: string);
  getName(): string;
  getValue(): string;
  getSignature(): string;
  isSigned(): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $com$destroystokyo$paper$ClientOption {
  getType(): any /* java.lang.Class */;
}

declare class com$destroystokyo$paper$ClientOption
  implements $com$destroystokyo$paper$ClientOption {
  static SKIN_PARTS: com$destroystokyo$paper$ClientOption;
  static CHAT_COLORS_ENABLED: com$destroystokyo$paper$ClientOption;
  static CHAT_VISIBILITY: com$destroystokyo$paper$ClientOption;
  static LOCALE: com$destroystokyo$paper$ClientOption;
  static MAIN_HAND: com$destroystokyo$paper$ClientOption;
  static VIEW_DISTANCE: com$destroystokyo$paper$ClientOption;
  getType(): any /* java.lang.Class */;
}


declare interface $org$bukkit$entity$Player$Spigot {
  getRawAddress(): any /* java.net.InetSocketAddress */;
  getCollidesWithEntities(): boolean;
  setCollidesWithEntities(arg0: boolean): void;
  respawn(): void;
  getHiddenPlayers(): any /* java.util.Set */;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  sendMessage(arg0: unknown, arg1: unknown): void;
  sendMessage(arg0: unknown, arg1: JavaArray<unknown>): void;
  getPing(): number;
}

declare class org$bukkit$entity$Player$Spigot
  implements $org$bukkit$entity$Player$Spigot {
  constructor();
  getRawAddress(): any /* java.net.InetSocketAddress */;
  getCollidesWithEntities(): boolean;
  setCollidesWithEntities(arg0: boolean): void;
  respawn(): void;
  getHiddenPlayers(): any /* java.util.Set */;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  sendMessage(arg0: unknown, arg1: unknown): void;
  sendMessage(arg0: unknown, arg1: JavaArray<unknown>): void;
  getPing(): number;
}


declare interface $org$bukkit$plugin$PluginManager {
  registerInterface(arg0: any /* java.lang.Class */): void;
  getPlugin(arg0: string): org$bukkit$plugin$Plugin;
  getPlugins(): JavaArray<org$bukkit$plugin$Plugin>;
  isPluginEnabled(arg0: string): boolean;
  isPluginEnabled(arg0: org$bukkit$plugin$Plugin): boolean;
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  loadPlugins(
    arg0: any /* java.io.File */
  ): JavaArray<org$bukkit$plugin$Plugin>;
  disablePlugins(): void;
  clearPlugins(): void;
  callEvent(arg0: org$bukkit$event$Event): void;
  registerEvents(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin,
    arg5: boolean
  ): void;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
  getPermission(arg0: string): org$bukkit$permissions$Permission;
  addPermission(arg0: org$bukkit$permissions$Permission): void;
  removePermission(arg0: org$bukkit$permissions$Permission): void;
  removePermission(arg0: string): void;
  getDefaultPermissions(arg0: boolean): any /* java.util.Set */;
  recalculatePermissionDefaults(arg0: org$bukkit$permissions$Permission): void;
  subscribeToPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getPermissionSubscriptions(arg0: string): any /* java.util.Set */;
  subscribeToDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getDefaultPermSubscriptions(arg0: boolean): any /* java.util.Set */;
  getPermissions(): any /* java.util.Set */;
  useTimings(): boolean;
}

declare class org$bukkit$plugin$PluginManager
  implements $org$bukkit$plugin$PluginManager {
  registerInterface(arg0: any /* java.lang.Class */): void;
  getPlugin(arg0: string): org$bukkit$plugin$Plugin;
  getPlugins(): JavaArray<org$bukkit$plugin$Plugin>;
  isPluginEnabled(arg0: string): boolean;
  isPluginEnabled(arg0: org$bukkit$plugin$Plugin): boolean;
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  loadPlugins(
    arg0: any /* java.io.File */
  ): JavaArray<org$bukkit$plugin$Plugin>;
  disablePlugins(): void;
  clearPlugins(): void;
  callEvent(arg0: org$bukkit$event$Event): void;
  registerEvents(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin,
    arg5: boolean
  ): void;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
  getPermission(arg0: string): org$bukkit$permissions$Permission;
  addPermission(arg0: org$bukkit$permissions$Permission): void;
  removePermission(arg0: org$bukkit$permissions$Permission): void;
  removePermission(arg0: string): void;
  getDefaultPermissions(arg0: boolean): any /* java.util.Set */;
  recalculatePermissionDefaults(arg0: org$bukkit$permissions$Permission): void;
  subscribeToPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getPermissionSubscriptions(arg0: string): any /* java.util.Set */;
  subscribeToDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getDefaultPermSubscriptions(arg0: boolean): any /* java.util.Set */;
  getPermissions(): any /* java.util.Set */;
  useTimings(): boolean;
}


declare interface $org$bukkit$event$EventPriority {
  getSlot(): number;
}

declare class org$bukkit$event$EventPriority
  implements $org$bukkit$event$EventPriority {
  static LOWEST: org$bukkit$event$EventPriority;
  static LOW: org$bukkit$event$EventPriority;
  static NORMAL: org$bukkit$event$EventPriority;
  static HIGH: org$bukkit$event$EventPriority;
  static HIGHEST: org$bukkit$event$EventPriority;
  static MONITOR: org$bukkit$event$EventPriority;
  static values(): JavaArray<org$bukkit$event$EventPriority>;
  static valueOf(arg0: string): org$bukkit$event$EventPriority;
  getSlot(): number;
}


declare interface $org$bukkit$scheduler$BukkitScheduler {
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): number;
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number
  ): number;
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): number;
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable
  ): number;
  scheduleSyncRepeatingTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): number;
  scheduleSyncRepeatingTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number,
    arg3: number
  ): number;
  scheduleAsyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): number;
  scheduleAsyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): number;
  scheduleAsyncRepeatingTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): number;
  callSyncMethod(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.concurrent.Callable */
  ): any /* java.util.concurrent.Future */;
  cancelTask(arg0: number): void;
  cancelTasks(arg0: org$bukkit$plugin$Plugin): void;
  isCurrentlyRunning(arg0: number): boolean;
  isQueued(arg0: number): boolean;
  getActiveWorkers(): any /* java.util.List */;
  getPendingTasks(): any /* java.util.List */;
  runTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): org$bukkit$scheduler$BukkitTask;
  runTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */
  ): void;
  runTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable
  ): org$bukkit$scheduler$BukkitTask;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): org$bukkit$scheduler$BukkitTask;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */
  ): void;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number
  ): void;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number
  ): void;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number,
    arg3: number
  ): void;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number,
    arg3: number
  ): void;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
}

declare class org$bukkit$scheduler$BukkitScheduler
  implements $org$bukkit$scheduler$BukkitScheduler {
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): number;
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number
  ): number;
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): number;
  scheduleSyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable
  ): number;
  scheduleSyncRepeatingTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): number;
  scheduleSyncRepeatingTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number,
    arg3: number
  ): number;
  scheduleAsyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): number;
  scheduleAsyncDelayedTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): number;
  scheduleAsyncRepeatingTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): number;
  callSyncMethod(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.concurrent.Callable */
  ): any /* java.util.concurrent.Future */;
  cancelTask(arg0: number): void;
  cancelTasks(arg0: org$bukkit$plugin$Plugin): void;
  isCurrentlyRunning(arg0: number): boolean;
  isQueued(arg0: number): boolean;
  getActiveWorkers(): any /* java.util.List */;
  getPendingTasks(): any /* java.util.List */;
  runTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): org$bukkit$scheduler$BukkitTask;
  runTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */
  ): void;
  runTask(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable
  ): org$bukkit$scheduler$BukkitTask;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */
  ): org$bukkit$scheduler$BukkitTask;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */
  ): void;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number
  ): void;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number
  ): void;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number,
    arg3: number
  ): void;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.lang.Runnable */,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.function.Consumer */,
    arg2: number,
    arg3: number
  ): void;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$scheduler$BukkitRunnable,
    arg2: number,
    arg3: number
  ): org$bukkit$scheduler$BukkitTask;
}


declare interface $org$bukkit$scheduler$BukkitRunnable {
  isCancelled(): boolean;
  cancel(): void;
  runTask(arg0: org$bukkit$plugin$Plugin): org$bukkit$scheduler$BukkitTask;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  getTaskId(): number;
}

declare class org$bukkit$scheduler$BukkitRunnable
  implements $org$bukkit$scheduler$BukkitRunnable {
  constructor();
  isCancelled(): boolean;
  cancel(): void;
  runTask(arg0: org$bukkit$plugin$Plugin): org$bukkit$scheduler$BukkitTask;
  runTaskAsynchronously(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLater(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskLaterAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimer(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  runTaskTimerAsynchronously(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number,
    arg2: number
  ): org$bukkit$scheduler$BukkitTask;
  getTaskId(): number;
}


declare interface $org$bukkit$scheduler$BukkitTask {
  getTaskId(): number;
  getOwner(): org$bukkit$plugin$Plugin;
  isSync(): boolean;
  isCancelled(): boolean;
  cancel(): void;
}

declare class org$bukkit$scheduler$BukkitTask
  implements $org$bukkit$scheduler$BukkitTask {
  getTaskId(): number;
  getOwner(): org$bukkit$plugin$Plugin;
  isSync(): boolean;
  isCancelled(): boolean;
  cancel(): void;
}


declare interface $org$bukkit$plugin$ServicesManager {
  register(
    arg0: any /* java.lang.Class */,
    arg1: any,
    arg2: org$bukkit$plugin$Plugin,
    arg3: org$bukkit$plugin$ServicePriority
  ): void;
  unregisterAll(arg0: org$bukkit$plugin$Plugin): void;
  unregister(arg0: any /* java.lang.Class */, arg1: any): void;
  unregister(arg0: any): void;
  load(arg0: any /* java.lang.Class */): any;
  getRegistration(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$RegisteredServiceProvider;
  getRegistrations(arg0: org$bukkit$plugin$Plugin): any /* java.util.List */;
  getRegistrations(arg0: any /* java.lang.Class */): java$util$Collection;
  getKnownServices(): java$util$Collection;
  isProvidedFor(arg0: any /* java.lang.Class */): boolean;
}

declare class org$bukkit$plugin$ServicesManager
  implements $org$bukkit$plugin$ServicesManager {
  register(
    arg0: any /* java.lang.Class */,
    arg1: any,
    arg2: org$bukkit$plugin$Plugin,
    arg3: org$bukkit$plugin$ServicePriority
  ): void;
  unregisterAll(arg0: org$bukkit$plugin$Plugin): void;
  unregister(arg0: any /* java.lang.Class */, arg1: any): void;
  unregister(arg0: any): void;
  load(arg0: any /* java.lang.Class */): any;
  getRegistration(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$RegisteredServiceProvider;
  getRegistrations(arg0: org$bukkit$plugin$Plugin): any /* java.util.List */;
  getRegistrations(arg0: any /* java.lang.Class */): java$util$Collection;
  getKnownServices(): java$util$Collection;
  isProvidedFor(arg0: any /* java.lang.Class */): boolean;
}


declare interface $org$bukkit$plugin$ServicePriority {}

declare class org$bukkit$plugin$ServicePriority
  implements $org$bukkit$plugin$ServicePriority {
  static Lowest: org$bukkit$plugin$ServicePriority;
  static Low: org$bukkit$plugin$ServicePriority;
  static Normal: org$bukkit$plugin$ServicePriority;
  static High: org$bukkit$plugin$ServicePriority;
  static Highest: org$bukkit$plugin$ServicePriority;
  static values(): JavaArray<org$bukkit$plugin$ServicePriority>;
  static valueOf(arg0: string): org$bukkit$plugin$ServicePriority;
}


declare interface $org$bukkit$plugin$RegisteredServiceProvider {
  getService(): any /* java.lang.Class */;
  getPlugin(): org$bukkit$plugin$Plugin;
  getProvider(): any;
  getPriority(): org$bukkit$plugin$ServicePriority;
  compareTo(arg0: org$bukkit$plugin$RegisteredServiceProvider): number;
  compareTo(arg0: any): number;
}

declare class org$bukkit$plugin$RegisteredServiceProvider
  implements $org$bukkit$plugin$RegisteredServiceProvider {
  constructor(
    arg0: any /* java.lang.Class */,
    arg1: any,
    arg2: org$bukkit$plugin$ServicePriority,
    arg3: org$bukkit$plugin$Plugin
  );
  getService(): any /* java.lang.Class */;
  getPlugin(): org$bukkit$plugin$Plugin;
  getProvider(): any;
  getPriority(): org$bukkit$plugin$ServicePriority;
  compareTo(arg0: org$bukkit$plugin$RegisteredServiceProvider): number;
  compareTo(arg0: any): number;
}


declare interface $org$bukkit$WorldCreator {
  copy(arg0: org$bukkit$World): org$bukkit$WorldCreator;
  copy(arg0: org$bukkit$WorldCreator): org$bukkit$WorldCreator;
  name(): string;
  seed(): number;
  seed(arg0: number): org$bukkit$WorldCreator;
  environment(): org$bukkit$World$Environment;
  environment(arg0: org$bukkit$World$Environment): org$bukkit$WorldCreator;
  type(): org$bukkit$WorldType;
  type(arg0: org$bukkit$WorldType): org$bukkit$WorldCreator;
  generator(): org$bukkit$generator$ChunkGenerator;
  generator(arg0: org$bukkit$generator$ChunkGenerator): org$bukkit$WorldCreator;
  generator(arg0: string): org$bukkit$WorldCreator;
  generator(
    arg0: string,
    arg1: org$bukkit$command$CommandSender
  ): org$bukkit$WorldCreator;
  generatorSettings(arg0: string): org$bukkit$WorldCreator;
  generatorSettings(): string;
  generateStructures(arg0: boolean): org$bukkit$WorldCreator;
  generateStructures(): boolean;
  hardcore(arg0: boolean): org$bukkit$WorldCreator;
  hardcore(): boolean;
  createWorld(): org$bukkit$World;
}

declare class org$bukkit$WorldCreator implements $org$bukkit$WorldCreator {
  constructor(arg0: string);
  copy(arg0: org$bukkit$World): org$bukkit$WorldCreator;
  copy(arg0: org$bukkit$WorldCreator): org$bukkit$WorldCreator;
  name(): string;
  seed(): number;
  seed(arg0: number): org$bukkit$WorldCreator;
  environment(): org$bukkit$World$Environment;
  environment(arg0: org$bukkit$World$Environment): org$bukkit$WorldCreator;
  type(): org$bukkit$WorldType;
  type(arg0: org$bukkit$WorldType): org$bukkit$WorldCreator;
  generator(): org$bukkit$generator$ChunkGenerator;
  generator(arg0: org$bukkit$generator$ChunkGenerator): org$bukkit$WorldCreator;
  generator(arg0: string): org$bukkit$WorldCreator;
  generator(
    arg0: string,
    arg1: org$bukkit$command$CommandSender
  ): org$bukkit$WorldCreator;
  generatorSettings(arg0: string): org$bukkit$WorldCreator;
  generatorSettings(): string;
  generateStructures(arg0: boolean): org$bukkit$WorldCreator;
  generateStructures(): boolean;
  hardcore(arg0: boolean): org$bukkit$WorldCreator;
  hardcore(): boolean;
  createWorld(): org$bukkit$World;
  static name(arg0: string): org$bukkit$WorldCreator;
  static getGeneratorForName(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$command$CommandSender
  ): org$bukkit$generator$ChunkGenerator;
}


declare interface $org$bukkit$command$PluginCommand
  extends $org$bukkit$command$PluginIdentifiableCommand {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  setExecutor(arg0: org$bukkit$command$CommandExecutor): void;
  getExecutor(): org$bukkit$command$CommandExecutor;
  setTabCompleter(arg0: org$bukkit$command$TabCompleter): void;
  getTabCompleter(): org$bukkit$command$TabCompleter;
  getPlugin(): org$bukkit$plugin$Plugin;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  toString(): string;
}

declare class org$bukkit$command$PluginCommand
  implements $org$bukkit$command$PluginCommand {
  constructor(arg0: string, arg1: org$bukkit$plugin$Plugin);
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  setExecutor(arg0: org$bukkit$command$CommandExecutor): void;
  getExecutor(): org$bukkit$command$CommandExecutor;
  setTabCompleter(arg0: org$bukkit$command$TabCompleter): void;
  getTabCompleter(): org$bukkit$command$TabCompleter;
  getPlugin(): org$bukkit$plugin$Plugin;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  toString(): string;
}


declare interface $org$bukkit$command$PluginIdentifiableCommand {
  getPlugin(): org$bukkit$plugin$Plugin;
}

declare class org$bukkit$command$PluginIdentifiableCommand
  implements $org$bukkit$command$PluginIdentifiableCommand {
  getPlugin(): org$bukkit$plugin$Plugin;
}


declare interface $org$bukkit$command$TabCompleter {
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
}

declare class org$bukkit$command$TabCompleter
  implements $org$bukkit$command$TabCompleter {
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
}


declare interface $org$bukkit$command$Command {
  timings: co$aikar$timings$Timing;
  getTimingName(): string;

  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>,
    arg3: org$bukkit$Location
  ): any /* java.util.List */;
  getName(): string;
  setName(arg0: string): boolean;
  getPermission(): string;
  setPermission(arg0: string): void;
  testPermission(arg0: org$bukkit$command$CommandSender): boolean;
  testPermissionSilent(arg0: org$bukkit$command$CommandSender): boolean;
  getLabel(): string;
  setLabel(arg0: string): boolean;
  register(arg0: org$bukkit$command$CommandMap): boolean;
  unregister(arg0: org$bukkit$command$CommandMap): boolean;
  isRegistered(): boolean;
  getAliases(): any /* java.util.List */;
  getPermissionMessage(): string;
  getDescription(): string;
  getUsage(): string;
  setAliases(arg0: any /* java.util.List */): org$bukkit$command$Command;
  setDescription(arg0: string): org$bukkit$command$Command;
  setPermissionMessage(arg0: string): org$bukkit$command$Command;
  setUsage(arg0: string): org$bukkit$command$Command;
  toString(): string;
}

declare class org$bukkit$command$Command
  implements $org$bukkit$command$Command {
  timings: co$aikar$timings$Timing;
  getTimingName(): string;
  constructor(arg0: string);
  constructor(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: any /* java.util.List */
  );
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>,
    arg3: org$bukkit$Location
  ): any /* java.util.List */;
  getName(): string;
  setName(arg0: string): boolean;
  getPermission(): string;
  setPermission(arg0: string): void;
  testPermission(arg0: org$bukkit$command$CommandSender): boolean;
  testPermissionSilent(arg0: org$bukkit$command$CommandSender): boolean;
  getLabel(): string;
  setLabel(arg0: string): boolean;
  register(arg0: org$bukkit$command$CommandMap): boolean;
  unregister(arg0: org$bukkit$command$CommandMap): boolean;
  isRegistered(): boolean;
  getAliases(): any /* java.util.List */;
  getPermissionMessage(): string;
  getDescription(): string;
  getUsage(): string;
  setAliases(arg0: any /* java.util.List */): org$bukkit$command$Command;
  setDescription(arg0: string): org$bukkit$command$Command;
  setPermissionMessage(arg0: string): org$bukkit$command$Command;
  setUsage(arg0: string): org$bukkit$command$Command;
  static broadcastCommandMessage(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): void;
  static broadcastCommandMessage(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: boolean
  ): void;
  toString(): string;
}


declare interface $org$bukkit$command$CommandMap {
  registerAll(arg0: string, arg1: any /* java.util.List */): void;
  register(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$command$Command
  ): boolean;
  register(arg0: string, arg1: org$bukkit$command$Command): boolean;
  dispatch(arg0: org$bukkit$command$CommandSender, arg1: string): boolean;
  clearCommands(): void;
  getCommand(arg0: string): org$bukkit$command$Command;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: org$bukkit$Location
  ): any /* java.util.List */;
  getKnownCommands(): any /* java.util.Map */;
}

declare class org$bukkit$command$CommandMap
  implements $org$bukkit$command$CommandMap {
  registerAll(arg0: string, arg1: any /* java.util.List */): void;
  register(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$command$Command
  ): boolean;
  register(arg0: string, arg1: org$bukkit$command$Command): boolean;
  dispatch(arg0: org$bukkit$command$CommandSender, arg1: string): boolean;
  clearCommands(): void;
  getCommand(arg0: string): org$bukkit$command$Command;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: org$bukkit$Location
  ): any /* java.util.List */;
  getKnownCommands(): any /* java.util.Map */;
}


declare interface $org$bukkit$BanList {
  getBanEntry(arg0: string): org$bukkit$BanEntry;
  addBan(
    arg0: string,
    arg1: string,
    arg2: any /* java.util.Date */,
    arg3: string
  ): org$bukkit$BanEntry;
  getBanEntries(): any /* java.util.Set */;
  isBanned(arg0: string): boolean;
  pardon(arg0: string): void;
}

declare class org$bukkit$BanList implements $org$bukkit$BanList {
  getBanEntry(arg0: string): org$bukkit$BanEntry;
  addBan(
    arg0: string,
    arg1: string,
    arg2: any /* java.util.Date */,
    arg3: string
  ): org$bukkit$BanEntry;
  getBanEntries(): any /* java.util.Set */;
  isBanned(arg0: string): boolean;
  pardon(arg0: string): void;
}


declare interface $org$bukkit$BanList$Type {}

declare class org$bukkit$BanList$Type implements $org$bukkit$BanList$Type {
  static NAME: org$bukkit$BanList$Type;
  static IP: org$bukkit$BanList$Type;
  static values(): JavaArray<org$bukkit$BanList$Type>;
  static valueOf(arg0: string): org$bukkit$BanList$Type;
}


declare interface $org$bukkit$command$ConsoleCommandSender
  extends $org$bukkit$command$CommandSender,
    $org$bukkit$conversations$Conversable {}

declare class org$bukkit$command$ConsoleCommandSender
  implements $org$bukkit$command$ConsoleCommandSender {
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isConversing(): boolean;
  acceptConversationInput(arg0: string): void;
  beginConversation(arg0: org$bukkit$conversations$Conversation): boolean;
  abandonConversation(arg0: org$bukkit$conversations$Conversation): void;
  abandonConversation(
    arg0: org$bukkit$conversations$Conversation,
    arg1: org$bukkit$conversations$ConversationAbandonedEvent
  ): void;
  sendRawMessage(arg0: string): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$plugin$messaging$Messenger {
  isReservedChannel(arg0: string): boolean;
  registerOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  registerIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): org$bukkit$plugin$messaging$PluginMessageListenerRegistration;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): void;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterIncomingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  getOutgoingChannels(): any /* java.util.Set */;
  getOutgoingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannels(): any /* java.util.Set */;
  getIncomingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin
  ): any /* java.util.Set */;
  getIncomingChannelRegistrations(arg0: string): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): any /* java.util.Set */;
  isRegistrationValid(
    arg0: org$bukkit$plugin$messaging$PluginMessageListenerRegistration
  ): boolean;
  isIncomingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  isOutgoingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  dispatchIncomingMessage(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
}

declare class org$bukkit$plugin$messaging$Messenger
  implements $org$bukkit$plugin$messaging$Messenger {
  static MAX_MESSAGE_SIZE: number;
  static MAX_CHANNEL_SIZE: number;
  isReservedChannel(arg0: string): boolean;
  registerOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  registerIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): org$bukkit$plugin$messaging$PluginMessageListenerRegistration;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): void;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterIncomingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  getOutgoingChannels(): any /* java.util.Set */;
  getOutgoingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannels(): any /* java.util.Set */;
  getIncomingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin
  ): any /* java.util.Set */;
  getIncomingChannelRegistrations(arg0: string): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): any /* java.util.Set */;
  isRegistrationValid(
    arg0: org$bukkit$plugin$messaging$PluginMessageListenerRegistration
  ): boolean;
  isIncomingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  isOutgoingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  dispatchIncomingMessage(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
}


declare interface $org$bukkit$plugin$messaging$PluginMessageListenerRegistration {
  getChannel(): string;
  getListener(): org$bukkit$plugin$messaging$PluginMessageListener;
  getPlugin(): org$bukkit$plugin$Plugin;
  isValid(): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class org$bukkit$plugin$messaging$PluginMessageListenerRegistration
  implements $org$bukkit$plugin$messaging$PluginMessageListenerRegistration {
  constructor(
    arg0: org$bukkit$plugin$messaging$Messenger,
    arg1: org$bukkit$plugin$Plugin,
    arg2: string,
    arg3: org$bukkit$plugin$messaging$PluginMessageListener
  );
  getChannel(): string;
  getListener(): org$bukkit$plugin$messaging$PluginMessageListener;
  getPlugin(): org$bukkit$plugin$Plugin;
  isValid(): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $org$bukkit$plugin$messaging$PluginMessageListener {
  onPluginMessageReceived(
    arg0: string,
    arg1: org$bukkit$entity$Player,
    arg2: JavaArray<Buffer>
  ): void;
}

declare class org$bukkit$plugin$messaging$PluginMessageListener
  implements $org$bukkit$plugin$messaging$PluginMessageListener {
  onPluginMessageReceived(
    arg0: string,
    arg1: org$bukkit$entity$Player,
    arg2: JavaArray<Buffer>
  ): void;
}


declare interface $org$bukkit$help$HelpMap {
  getHelpTopic(arg0: string): org$bukkit$help$HelpTopic;
  getHelpTopics(): java$util$Collection;
  addTopic(arg0: org$bukkit$help$HelpTopic): void;
  clear(): void;
  registerHelpTopicFactory(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$help$HelpTopicFactory
  ): void;
  getIgnoredPlugins(): any /* java.util.List */;
}

declare class org$bukkit$help$HelpMap implements $org$bukkit$help$HelpMap {
  getHelpTopic(arg0: string): org$bukkit$help$HelpTopic;
  getHelpTopics(): java$util$Collection;
  addTopic(arg0: org$bukkit$help$HelpTopic): void;
  clear(): void;
  registerHelpTopicFactory(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$help$HelpTopicFactory
  ): void;
  getIgnoredPlugins(): any /* java.util.List */;
}


declare interface $org$bukkit$help$HelpTopic {
  canSee(arg0: org$bukkit$command$CommandSender): boolean;
  amendCanSee(arg0: string): void;
  getName(): string;
  getShortText(): string;
  getFullText(arg0: org$bukkit$command$CommandSender): string;
  amendTopic(arg0: string, arg1: string): void;
  applyAmendment(arg0: string, arg1: string): string;
}

declare class org$bukkit$help$HelpTopic implements $org$bukkit$help$HelpTopic {
  constructor();
  canSee(arg0: org$bukkit$command$CommandSender): boolean;
  amendCanSee(arg0: string): void;
  getName(): string;
  getShortText(): string;
  getFullText(arg0: org$bukkit$command$CommandSender): string;
  amendTopic(arg0: string, arg1: string): void;
  applyAmendment(arg0: string, arg1: string): string;
}


declare interface $org$bukkit$help$HelpTopicFactory {
  createTopic(arg0: org$bukkit$command$Command): org$bukkit$help$HelpTopic;
}

declare class org$bukkit$help$HelpTopicFactory
  implements $org$bukkit$help$HelpTopicFactory {
  createTopic(arg0: org$bukkit$command$Command): org$bukkit$help$HelpTopic;
}


declare interface $org$bukkit$Warning$WarningState {
  printFor(arg0: org$bukkit$Warning): boolean;
}

declare class org$bukkit$Warning$WarningState
  implements $org$bukkit$Warning$WarningState {
  static ON: org$bukkit$Warning$WarningState;
  static OFF: org$bukkit$Warning$WarningState;
  static DEFAULT: org$bukkit$Warning$WarningState;
  static values(): JavaArray<org$bukkit$Warning$WarningState>;
  static valueOf(arg0: string): org$bukkit$Warning$WarningState;
  printFor(arg0: org$bukkit$Warning): boolean;
  static value(arg0: string): org$bukkit$Warning$WarningState;
}


declare interface $org$bukkit$Warning {
  value(): boolean;
  reason(): string;
}

declare class org$bukkit$Warning implements $org$bukkit$Warning {
  value(): boolean;
  reason(): string;
}


declare interface $org$bukkit$inventory$ItemFactory {
  getItemMeta(arg0: org$bukkit$Material): org$bukkit$inventory$meta$ItemMeta;
  isApplicable(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$inventory$ItemStack
  ): boolean;
  isApplicable(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$Material
  ): boolean;
  equals(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$inventory$meta$ItemMeta
  ): boolean;
  asMetaFor(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$meta$ItemMeta;
  asMetaFor(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$meta$ItemMeta;
  getDefaultLeatherColor(): org$bukkit$Color;
  updateMaterial(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$Material
  ): org$bukkit$Material;
  ensureServerConversions(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  getI18NDisplayName(arg0: org$bukkit$inventory$ItemStack): string;
}

declare class org$bukkit$inventory$ItemFactory
  implements $org$bukkit$inventory$ItemFactory {
  getItemMeta(arg0: org$bukkit$Material): org$bukkit$inventory$meta$ItemMeta;
  isApplicable(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$inventory$ItemStack
  ): boolean;
  isApplicable(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$Material
  ): boolean;
  equals(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$inventory$meta$ItemMeta
  ): boolean;
  asMetaFor(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$meta$ItemMeta;
  asMetaFor(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$meta$ItemMeta;
  getDefaultLeatherColor(): org$bukkit$Color;
  updateMaterial(
    arg0: org$bukkit$inventory$meta$ItemMeta,
    arg1: org$bukkit$Material
  ): org$bukkit$Material;
  ensureServerConversions(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  getI18NDisplayName(arg0: org$bukkit$inventory$ItemStack): string;
}


declare interface $org$bukkit$scoreboard$ScoreboardManager {
  getMainScoreboard(): org$bukkit$scoreboard$Scoreboard;
  getNewScoreboard(): org$bukkit$scoreboard$Scoreboard;
}

declare class org$bukkit$scoreboard$ScoreboardManager
  implements $org$bukkit$scoreboard$ScoreboardManager {
  getMainScoreboard(): org$bukkit$scoreboard$Scoreboard;
  getNewScoreboard(): org$bukkit$scoreboard$Scoreboard;
}


declare interface $org$bukkit$util$CachedServerIcon {
  getData(): string;
  isEmpty(): boolean;
}

declare class org$bukkit$util$CachedServerIcon
  implements $org$bukkit$util$CachedServerIcon {
  getData(): string;
  isEmpty(): boolean;
}


declare interface $org$bukkit$boss$KeyedBossBar
  extends $org$bukkit$boss$BossBar,
    $org$bukkit$Keyed {}

declare class org$bukkit$boss$KeyedBossBar
  implements $org$bukkit$boss$KeyedBossBar {
  getKey(): org$bukkit$NamespacedKey;
  getTitle(): string;
  setTitle(arg0: string): void;
  getColor(): org$bukkit$boss$BarColor;
  setColor(arg0: org$bukkit$boss$BarColor): void;
  getStyle(): org$bukkit$boss$BarStyle;
  setStyle(arg0: org$bukkit$boss$BarStyle): void;
  removeFlag(arg0: org$bukkit$boss$BarFlag): void;
  addFlag(arg0: org$bukkit$boss$BarFlag): void;
  hasFlag(arg0: org$bukkit$boss$BarFlag): boolean;
  setProgress(arg0: number): void;
  getProgress(): number;
  addPlayer(arg0: org$bukkit$entity$Player): void;
  removePlayer(arg0: org$bukkit$entity$Player): void;
  removeAll(): void;
  getPlayers(): any /* java.util.List */;
  setVisible(arg0: boolean): void;
  isVisible(): boolean;
  show(): void;
  hide(): void;
}


declare interface $org$bukkit$Tag extends $org$bukkit$Keyed {
  isTagged(arg0: org$bukkit$Keyed): boolean;
  getValues(): any /* java.util.Set */;
}

declare class org$bukkit$Tag implements $org$bukkit$Tag {
  static REGISTRY_BLOCKS: string;
  static WOOL: org$bukkit$Tag;
  static PLANKS: org$bukkit$Tag;
  static STONE_BRICKS: org$bukkit$Tag;
  static WOODEN_BUTTONS: org$bukkit$Tag;
  static BUTTONS: org$bukkit$Tag;
  static CARPETS: org$bukkit$Tag;
  static WOODEN_DOORS: org$bukkit$Tag;
  static WOODEN_STAIRS: org$bukkit$Tag;
  static WOODEN_SLABS: org$bukkit$Tag;
  static WOODEN_FENCES: org$bukkit$Tag;
  static WOODEN_PRESSURE_PLATES: org$bukkit$Tag;
  static WOODEN_TRAPDOORS: org$bukkit$Tag;
  static DOORS: org$bukkit$Tag;
  static SAPLINGS: org$bukkit$Tag;
  static LOGS: org$bukkit$Tag;
  static DARK_OAK_LOGS: org$bukkit$Tag;
  static OAK_LOGS: org$bukkit$Tag;
  static BIRCH_LOGS: org$bukkit$Tag;
  static ACACIA_LOGS: org$bukkit$Tag;
  static JUNGLE_LOGS: org$bukkit$Tag;
  static SPRUCE_LOGS: org$bukkit$Tag;
  static BANNERS: org$bukkit$Tag;
  static SAND: org$bukkit$Tag;
  static STAIRS: org$bukkit$Tag;
  static SLABS: org$bukkit$Tag;
  static WALLS: org$bukkit$Tag;
  static ANVIL: org$bukkit$Tag;
  static RAILS: org$bukkit$Tag;
  static LEAVES: org$bukkit$Tag;
  static TRAPDOORS: org$bukkit$Tag;
  static FLOWER_POTS: org$bukkit$Tag;
  static SMALL_FLOWERS: org$bukkit$Tag;
  static BEDS: org$bukkit$Tag;
  static FENCES: org$bukkit$Tag;
  static TALL_FLOWERS: org$bukkit$Tag;
  static FLOWERS: org$bukkit$Tag;
  static SHULKER_BOXES: org$bukkit$Tag;
  static ENDERMAN_HOLDABLE: org$bukkit$Tag;
  static ICE: org$bukkit$Tag;
  static VALID_SPAWN: org$bukkit$Tag;
  static IMPERMEABLE: org$bukkit$Tag;
  static UNDERWATER_BONEMEALS: org$bukkit$Tag;
  static CORAL_BLOCKS: org$bukkit$Tag;
  static WALL_CORALS: org$bukkit$Tag;
  static CORAL_PLANTS: org$bukkit$Tag;
  static CORALS: org$bukkit$Tag;
  static BAMBOO_PLANTABLE_ON: org$bukkit$Tag;
  static STANDING_SIGNS: org$bukkit$Tag;
  static WALL_SIGNS: org$bukkit$Tag;
  static SIGNS: org$bukkit$Tag;
  static DRAGON_IMMUNE: org$bukkit$Tag;
  static WITHER_IMMUNE: org$bukkit$Tag;
  static BEEHIVES: org$bukkit$Tag;
  static CROPS: org$bukkit$Tag;
  static BEE_GROWABLES: org$bukkit$Tag;
  static PORTALS: org$bukkit$Tag;
  static REGISTRY_ITEMS: string;
  static ITEMS_BANNERS: org$bukkit$Tag;
  static ITEMS_BOATS: org$bukkit$Tag;
  static ITEMS_FISHES: org$bukkit$Tag;
  static ITEMS_MUSIC_DISCS: org$bukkit$Tag;
  static ITEMS_COALS: org$bukkit$Tag;
  static ITEMS_ARROWS: org$bukkit$Tag;
  static ITEMS_LECTERN_BOOKS: org$bukkit$Tag;
  isTagged(arg0: org$bukkit$Keyed): boolean;
  getValues(): any /* java.util.Set */;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$UnsafeValues {
  reportTimings(): void;
  toLegacy(arg0: org$bukkit$Material): org$bukkit$Material;
  fromLegacy(arg0: org$bukkit$Material): org$bukkit$Material;
  fromLegacy(arg0: org$bukkit$material$MaterialData): org$bukkit$Material;
  fromLegacy(
    arg0: org$bukkit$material$MaterialData,
    arg1: boolean
  ): org$bukkit$Material;
  fromLegacy(
    arg0: org$bukkit$Material,
    arg1: Buffer
  ): org$bukkit$block$data$BlockData;
  getMaterial(arg0: string, arg1: number): org$bukkit$Material;
  getDataVersion(): number;
  modifyItemStack(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: string
  ): org$bukkit$inventory$ItemStack;
  checkSupported(arg0: org$bukkit$plugin$PluginDescriptionFile): void;
  processClass(
    arg0: org$bukkit$plugin$PluginDescriptionFile,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): JavaArray<Buffer>;
  loadAdvancement(
    arg0: org$bukkit$NamespacedKey,
    arg1: string
  ): org$bukkit$advancement$Advancement;
  removeAdvancement(arg0: org$bukkit$NamespacedKey): boolean;
  getTimingsServerName(): string;
  getVersionFetcher(): com$destroystokyo$paper$util$VersionFetcher;
  isSupportedApiVersion(arg0: string): boolean;
  serializeItem(arg0: org$bukkit$inventory$ItemStack): JavaArray<Buffer>;
  deserializeItem(arg0: JavaArray<Buffer>): org$bukkit$inventory$ItemStack;
}

declare class org$bukkit$UnsafeValues implements $org$bukkit$UnsafeValues {
  reportTimings(): void;
  toLegacy(arg0: org$bukkit$Material): org$bukkit$Material;
  fromLegacy(arg0: org$bukkit$Material): org$bukkit$Material;
  fromLegacy(arg0: org$bukkit$material$MaterialData): org$bukkit$Material;
  fromLegacy(
    arg0: org$bukkit$material$MaterialData,
    arg1: boolean
  ): org$bukkit$Material;
  fromLegacy(
    arg0: org$bukkit$Material,
    arg1: Buffer
  ): org$bukkit$block$data$BlockData;
  getMaterial(arg0: string, arg1: number): org$bukkit$Material;
  getDataVersion(): number;
  modifyItemStack(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: string
  ): org$bukkit$inventory$ItemStack;
  checkSupported(arg0: org$bukkit$plugin$PluginDescriptionFile): void;
  processClass(
    arg0: org$bukkit$plugin$PluginDescriptionFile,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): JavaArray<Buffer>;
  loadAdvancement(
    arg0: org$bukkit$NamespacedKey,
    arg1: string
  ): org$bukkit$advancement$Advancement;
  removeAdvancement(arg0: org$bukkit$NamespacedKey): boolean;
  getTimingsServerName(): string;
  getVersionFetcher(): com$destroystokyo$paper$util$VersionFetcher;
  isSupportedApiVersion(arg0: string): boolean;
  static isLegacyPlugin(arg0: org$bukkit$plugin$Plugin): boolean;
  serializeItem(arg0: org$bukkit$inventory$ItemStack): JavaArray<Buffer>;
  deserializeItem(arg0: JavaArray<Buffer>): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$plugin$PluginDescriptionFile {
  getName(): string;
  getProvides(): any /* java.util.List */;
  getVersion(): string;
  getMain(): string;
  getDescription(): string;
  getLoad(): org$bukkit$plugin$PluginLoadOrder;
  getAuthors(): any /* java.util.List */;
  getWebsite(): string;
  getDepend(): any /* java.util.List */;
  getSoftDepend(): any /* java.util.List */;
  getLoadBefore(): any /* java.util.List */;
  getPrefix(): string;
  getCommands(): any /* java.util.Map */;
  getPermissions(): any /* java.util.List */;
  getPermissionDefault(): org$bukkit$permissions$PermissionDefault;
  getAwareness(): any /* java.util.Set */;
  getFullName(): string;
  getAPIVersion(): string;
  getClassLoaderOf(): string;
  save(arg0: any /* java.io.Writer */): void;
  getRawName(): string;
}

declare class org$bukkit$plugin$PluginDescriptionFile
  implements $org$bukkit$plugin$PluginDescriptionFile {
  constructor(arg0: any /* java.io.InputStream */);
  constructor(arg0: any /* java.io.Reader */);
  constructor(arg0: string, arg1: string, arg2: string);
  getName(): string;
  getProvides(): any /* java.util.List */;
  getVersion(): string;
  getMain(): string;
  getDescription(): string;
  getLoad(): org$bukkit$plugin$PluginLoadOrder;
  getAuthors(): any /* java.util.List */;
  getWebsite(): string;
  getDepend(): any /* java.util.List */;
  getSoftDepend(): any /* java.util.List */;
  getLoadBefore(): any /* java.util.List */;
  getPrefix(): string;
  getCommands(): any /* java.util.Map */;
  getPermissions(): any /* java.util.List */;
  getPermissionDefault(): org$bukkit$permissions$PermissionDefault;
  getAwareness(): any /* java.util.Set */;
  getFullName(): string;
  getAPIVersion(): string;
  getClassLoaderOf(): string;
  save(arg0: any /* java.io.Writer */): void;
  getRawName(): string;
}


declare interface $org$bukkit$plugin$PluginLoadOrder {}

declare class org$bukkit$plugin$PluginLoadOrder
  implements $org$bukkit$plugin$PluginLoadOrder {
  static STARTUP: org$bukkit$plugin$PluginLoadOrder;
  static POSTWORLD: org$bukkit$plugin$PluginLoadOrder;
  static values(): JavaArray<org$bukkit$plugin$PluginLoadOrder>;
  static valueOf(arg0: string): org$bukkit$plugin$PluginLoadOrder;
}


declare interface $com$destroystokyo$paper$util$VersionFetcher {
  getCacheTime(): number;
  getVersionMessage(arg0: string): string;
}

declare class com$destroystokyo$paper$util$VersionFetcher
  implements $com$destroystokyo$paper$util$VersionFetcher {
  getCacheTime(): number;
  getVersionMessage(arg0: string): string;
}


declare interface $org$bukkit$Server$Spigot {
  getConfig(): org$bukkit$configuration$file$YamlConfiguration;
  getBukkitConfig(): org$bukkit$configuration$file$YamlConfiguration;
  getSpigotConfig(): org$bukkit$configuration$file$YamlConfiguration;
  getPaperConfig(): org$bukkit$configuration$file$YamlConfiguration;
  broadcast(arg0: unknown): void;
  broadcast(arg0: JavaArray<unknown>): void;
  restart(): void;
}

declare class org$bukkit$Server$Spigot implements $org$bukkit$Server$Spigot {
  constructor();
  getConfig(): org$bukkit$configuration$file$YamlConfiguration;
  getBukkitConfig(): org$bukkit$configuration$file$YamlConfiguration;
  getSpigotConfig(): org$bukkit$configuration$file$YamlConfiguration;
  getPaperConfig(): org$bukkit$configuration$file$YamlConfiguration;
  broadcast(arg0: unknown): void;
  broadcast(arg0: JavaArray<unknown>): void;
  restart(): void;
}


declare interface $org$bukkit$configuration$file$YamlConfiguration {
  saveToString(): string;
  loadFromString(arg0: string): void;
  convertMapsToSections(
    arg0: any /* java.util.Map */,
    arg1: org$bukkit$configuration$ConfigurationSection
  ): void;
  parseHeader(arg0: string): string;
  buildHeader(): string;
  options(): org$bukkit$configuration$file$YamlConfigurationOptions;
  options(): org$bukkit$configuration$file$FileConfigurationOptions;
  options(): org$bukkit$configuration$MemoryConfigurationOptions;
  options(): org$bukkit$configuration$ConfigurationOptions;
}

declare class org$bukkit$configuration$file$YamlConfiguration
  implements $org$bukkit$configuration$file$YamlConfiguration {
  constructor();
  saveToString(): string;
  loadFromString(arg0: string): void;
  convertMapsToSections(
    arg0: any /* java.util.Map */,
    arg1: org$bukkit$configuration$ConfigurationSection
  ): void;
  parseHeader(arg0: string): string;
  buildHeader(): string;
  options(): org$bukkit$configuration$file$YamlConfigurationOptions;
  static loadConfiguration(
    arg0: any /* java.io.File */
  ): org$bukkit$configuration$file$YamlConfiguration;
  static loadConfiguration(
    arg0: any /* java.io.Reader */
  ): org$bukkit$configuration$file$YamlConfiguration;
  options(): org$bukkit$configuration$file$FileConfigurationOptions;
  options(): org$bukkit$configuration$MemoryConfigurationOptions;
  options(): org$bukkit$configuration$ConfigurationOptions;
  addDefault(arg0: string, arg1: any): void;
  addDefaults(arg0: any /* java.util.Map */): void;
  addDefaults(arg0: org$bukkit$configuration$Configuration): void;
  setDefaults(arg0: org$bukkit$configuration$Configuration): void;
  getDefaults(): org$bukkit$configuration$Configuration;
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  set(arg0: string, arg1: any): void;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
}


declare interface $org$bukkit$configuration$Configuration
  extends $org$bukkit$configuration$ConfigurationSection {
  addDefault(arg0: string, arg1: any): void;
  addDefaults(arg0: any /* java.util.Map */): void;
  addDefaults(arg0: org$bukkit$configuration$Configuration): void;
  setDefaults(arg0: org$bukkit$configuration$Configuration): void;
  getDefaults(): org$bukkit$configuration$Configuration;
  options(): org$bukkit$configuration$ConfigurationOptions;
}

declare class org$bukkit$configuration$Configuration
  implements $org$bukkit$configuration$Configuration {
  addDefault(arg0: string, arg1: any): void;
  addDefaults(arg0: any /* java.util.Map */): void;
  addDefaults(arg0: org$bukkit$configuration$Configuration): void;
  setDefaults(arg0: org$bukkit$configuration$Configuration): void;
  getDefaults(): org$bukkit$configuration$Configuration;
  options(): org$bukkit$configuration$ConfigurationOptions;
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  set(arg0: string, arg1: any): void;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
}


declare interface $org$bukkit$configuration$ConfigurationSection {
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  set(arg0: string, arg1: any): void;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
  addDefault(arg0: string, arg1: any): void;
}

declare class org$bukkit$configuration$ConfigurationSection
  implements $org$bukkit$configuration$ConfigurationSection {
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  set(arg0: string, arg1: any): void;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
  addDefault(arg0: string, arg1: any): void;
}


declare interface $org$bukkit$configuration$ConfigurationOptions {
  configuration(): org$bukkit$configuration$Configuration;
  pathSeparator(): string;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  copyDefaults(): boolean;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
}

declare class org$bukkit$configuration$ConfigurationOptions
  implements $org$bukkit$configuration$ConfigurationOptions {
  constructor(arg0: org$bukkit$configuration$Configuration);
  configuration(): org$bukkit$configuration$Configuration;
  pathSeparator(): string;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  copyDefaults(): boolean;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
}


declare interface $org$bukkit$configuration$file$YamlConfigurationOptions {
  configuration(): org$bukkit$configuration$file$YamlConfiguration;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$file$YamlConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$file$YamlConfigurationOptions;
  header(arg0: string): org$bukkit$configuration$file$YamlConfigurationOptions;
  copyHeader(
    arg0: boolean
  ): org$bukkit$configuration$file$YamlConfigurationOptions;
  indent(): number;
  indent(arg0: number): org$bukkit$configuration$file$YamlConfigurationOptions;
  copyHeader(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  header(arg0: string): org$bukkit$configuration$file$FileConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  configuration(): org$bukkit$configuration$file$FileConfiguration;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  configuration(): org$bukkit$configuration$MemoryConfiguration;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  configuration(): org$bukkit$configuration$Configuration;
}

declare class org$bukkit$configuration$file$YamlConfigurationOptions
  implements $org$bukkit$configuration$file$YamlConfigurationOptions {
  constructor(arg0: org$bukkit$configuration$file$YamlConfiguration);
  configuration(): org$bukkit$configuration$file$YamlConfiguration;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$file$YamlConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$file$YamlConfigurationOptions;
  header(arg0: string): org$bukkit$configuration$file$YamlConfigurationOptions;
  copyHeader(
    arg0: boolean
  ): org$bukkit$configuration$file$YamlConfigurationOptions;
  indent(): number;
  indent(arg0: number): org$bukkit$configuration$file$YamlConfigurationOptions;
  copyHeader(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  header(arg0: string): org$bukkit$configuration$file$FileConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  configuration(): org$bukkit$configuration$file$FileConfiguration;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  configuration(): org$bukkit$configuration$MemoryConfiguration;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  configuration(): org$bukkit$configuration$Configuration;
}


declare interface $org$bukkit$configuration$file$FileConfigurationOptions {
  configuration(): org$bukkit$configuration$file$FileConfiguration;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  header(): string;
  header(arg0: string): org$bukkit$configuration$file$FileConfigurationOptions;
  copyHeader(): boolean;
  copyHeader(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  configuration(): org$bukkit$configuration$MemoryConfiguration;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  configuration(): org$bukkit$configuration$Configuration;
}

declare class org$bukkit$configuration$file$FileConfigurationOptions
  implements $org$bukkit$configuration$file$FileConfigurationOptions {
  constructor(arg0: org$bukkit$configuration$MemoryConfiguration);
  configuration(): org$bukkit$configuration$file$FileConfiguration;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  header(): string;
  header(arg0: string): org$bukkit$configuration$file$FileConfigurationOptions;
  copyHeader(): boolean;
  copyHeader(
    arg0: boolean
  ): org$bukkit$configuration$file$FileConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  configuration(): org$bukkit$configuration$MemoryConfiguration;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  configuration(): org$bukkit$configuration$Configuration;
}


declare interface $org$bukkit$configuration$MemoryConfiguration
  extends $org$bukkit$configuration$Configuration {
  addDefault(arg0: string, arg1: any): void;
  addDefaults(arg0: any /* java.util.Map */): void;
  addDefaults(arg0: org$bukkit$configuration$Configuration): void;
  setDefaults(arg0: org$bukkit$configuration$Configuration): void;
  getDefaults(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  options(): org$bukkit$configuration$MemoryConfigurationOptions;
  options(): org$bukkit$configuration$ConfigurationOptions;
}

declare class org$bukkit$configuration$MemoryConfiguration
  implements $org$bukkit$configuration$MemoryConfiguration {
  constructor();
  constructor(arg0: org$bukkit$configuration$Configuration);
  addDefault(arg0: string, arg1: any): void;
  addDefaults(arg0: any /* java.util.Map */): void;
  addDefaults(arg0: org$bukkit$configuration$Configuration): void;
  setDefaults(arg0: org$bukkit$configuration$Configuration): void;
  getDefaults(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  options(): org$bukkit$configuration$MemoryConfigurationOptions;
  options(): org$bukkit$configuration$ConfigurationOptions;
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  set(arg0: string, arg1: any): void;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
}


declare interface $org$bukkit$configuration$MemoryConfigurationOptions {
  configuration(): org$bukkit$configuration$MemoryConfiguration;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  configuration(): org$bukkit$configuration$Configuration;
}

declare class org$bukkit$configuration$MemoryConfigurationOptions
  implements $org$bukkit$configuration$MemoryConfigurationOptions {
  constructor(arg0: org$bukkit$configuration$MemoryConfiguration);
  configuration(): org$bukkit$configuration$MemoryConfiguration;
  copyDefaults(
    arg0: boolean
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  pathSeparator(
    arg0: string
  ): org$bukkit$configuration$MemoryConfigurationOptions;
  copyDefaults(arg0: boolean): org$bukkit$configuration$ConfigurationOptions;
  pathSeparator(arg0: string): org$bukkit$configuration$ConfigurationOptions;
  configuration(): org$bukkit$configuration$Configuration;
}


declare interface $org$bukkit$configuration$file$FileConfiguration {
  save(arg0: any /* java.io.File */): void;
  save(arg0: string): void;
  saveToString(): string;
  load(arg0: any /* java.io.File */): void;
  load(arg0: any /* java.io.Reader */): void;
  load(arg0: string): void;
  loadFromString(arg0: string): void;
  buildHeader(): string;
  options(): org$bukkit$configuration$file$FileConfigurationOptions;
  options(): org$bukkit$configuration$MemoryConfigurationOptions;
  options(): org$bukkit$configuration$ConfigurationOptions;
}

declare class org$bukkit$configuration$file$FileConfiguration
  implements $org$bukkit$configuration$file$FileConfiguration {
  constructor();
  constructor(arg0: org$bukkit$configuration$Configuration);
  save(arg0: any /* java.io.File */): void;
  save(arg0: string): void;
  saveToString(): string;
  load(arg0: any /* java.io.File */): void;
  load(arg0: any /* java.io.Reader */): void;
  load(arg0: string): void;
  loadFromString(arg0: string): void;
  buildHeader(): string;
  options(): org$bukkit$configuration$file$FileConfigurationOptions;
  options(): org$bukkit$configuration$MemoryConfigurationOptions;
  options(): org$bukkit$configuration$ConfigurationOptions;
  addDefault(arg0: string, arg1: any): void;
  addDefaults(arg0: any /* java.util.Map */): void;
  addDefaults(arg0: org$bukkit$configuration$Configuration): void;
  setDefaults(arg0: org$bukkit$configuration$Configuration): void;
  getDefaults(): org$bukkit$configuration$Configuration;
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  set(arg0: string, arg1: any): void;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
}


declare interface $com$destroystokyo$paper$entity$ai$MobGoals {
  addGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: number,
    arg2: com$destroystokyo$paper$entity$ai$Goal
  ): void;
  removeGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$Goal
  ): void;
  removeAllGoals(arg0: org$bukkit$entity$Mob): void;
  removeAllGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): void;
  removeGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): void;
  hasGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): boolean;
  getGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): com$destroystokyo$paper$entity$ai$Goal;
  getGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): java$util$Collection;
  getAllGoals(arg0: org$bukkit$entity$Mob): java$util$Collection;
  getAllGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
  getAllGoalsWithout(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
  getRunningGoals(arg0: org$bukkit$entity$Mob): java$util$Collection;
  getRunningGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
  getRunningGoalsWithout(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
}

declare class com$destroystokyo$paper$entity$ai$MobGoals
  implements $com$destroystokyo$paper$entity$ai$MobGoals {
  addGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: number,
    arg2: com$destroystokyo$paper$entity$ai$Goal
  ): void;
  removeGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$Goal
  ): void;
  removeAllGoals(arg0: org$bukkit$entity$Mob): void;
  removeAllGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): void;
  removeGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): void;
  hasGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): boolean;
  getGoal(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): com$destroystokyo$paper$entity$ai$Goal;
  getGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalKey
  ): java$util$Collection;
  getAllGoals(arg0: org$bukkit$entity$Mob): java$util$Collection;
  getAllGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
  getAllGoalsWithout(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
  getRunningGoals(arg0: org$bukkit$entity$Mob): java$util$Collection;
  getRunningGoals(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
  getRunningGoalsWithout(
    arg0: org$bukkit$entity$Mob,
    arg1: com$destroystokyo$paper$entity$ai$GoalType
  ): java$util$Collection;
}


declare interface $com$destroystokyo$paper$entity$ai$Goal {
  shouldActivate(): boolean;
  shouldStayActive(): boolean;
  start(): void;
  stop(): void;
  tick(): void;
  getKey(): com$destroystokyo$paper$entity$ai$GoalKey;
  getTypes(): any /* java.util.EnumSet */;
}

declare class com$destroystokyo$paper$entity$ai$Goal
  implements $com$destroystokyo$paper$entity$ai$Goal {
  shouldActivate(): boolean;
  shouldStayActive(): boolean;
  start(): void;
  stop(): void;
  tick(): void;
  getKey(): com$destroystokyo$paper$entity$ai$GoalKey;
  getTypes(): any /* java.util.EnumSet */;
}


declare interface $com$destroystokyo$paper$entity$ai$GoalKey {
  getEntityClass(): any /* java.lang.Class */;
  getNamespacedKey(): org$bukkit$NamespacedKey;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
}

declare class com$destroystokyo$paper$entity$ai$GoalKey
  implements $com$destroystokyo$paper$entity$ai$GoalKey {
  getEntityClass(): any /* java.lang.Class */;
  getNamespacedKey(): org$bukkit$NamespacedKey;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  static of(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$NamespacedKey
  ): com$destroystokyo$paper$entity$ai$GoalKey;
}


declare interface $com$destroystokyo$paper$entity$ai$GoalType {}

declare class com$destroystokyo$paper$entity$ai$GoalType
  implements $com$destroystokyo$paper$entity$ai$GoalType {
  static MOVE: com$destroystokyo$paper$entity$ai$GoalType;
  static LOOK: com$destroystokyo$paper$entity$ai$GoalType;
  static JUMP: com$destroystokyo$paper$entity$ai$GoalType;
  static TARGET: com$destroystokyo$paper$entity$ai$GoalType;
  static UNKNOWN_BEHAVIOR: com$destroystokyo$paper$entity$ai$GoalType;
  static values(): JavaArray<com$destroystokyo$paper$entity$ai$GoalType>;
  static valueOf(arg0: string): com$destroystokyo$paper$entity$ai$GoalType;
}


declare interface $org$bukkit$command$TabExecutor
  extends $org$bukkit$command$TabCompleter,
    $org$bukkit$command$CommandExecutor {}

declare class org$bukkit$command$TabExecutor
  implements $org$bukkit$command$TabExecutor {
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
}


declare interface $org$bukkit$plugin$PluginLoader {
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  getPluginDescription(
    arg0: any /* java.io.File */
  ): org$bukkit$plugin$PluginDescriptionFile;
  getPluginFileFilters(): JavaArray<any /* java.util.regex.Pattern */>;
  createRegisteredListeners(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): any /* java.util.Map */;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
}

declare class org$bukkit$plugin$PluginLoader
  implements $org$bukkit$plugin$PluginLoader {
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  getPluginDescription(
    arg0: any /* java.io.File */
  ): org$bukkit$plugin$PluginDescriptionFile;
  getPluginFileFilters(): JavaArray<any /* java.util.regex.Pattern */>;
  createRegisteredListeners(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): any /* java.util.Map */;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
}


declare interface $org$bukkit$plugin$RegisteredListener {
  getListener(): org$bukkit$event$Listener;
  getPlugin(): org$bukkit$plugin$Plugin;
  getPriority(): org$bukkit$event$EventPriority;
  callEvent(arg0: org$bukkit$event$Event): void;
  isIgnoringCancelled(): boolean;
}

declare class org$bukkit$plugin$RegisteredListener
  implements $org$bukkit$plugin$RegisteredListener {
  constructor(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$EventExecutor,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$Plugin,
    arg4: boolean
  );
  getListener(): org$bukkit$event$Listener;
  getPlugin(): org$bukkit$plugin$Plugin;
  getPriority(): org$bukkit$event$EventPriority;
  callEvent(arg0: org$bukkit$event$Event): void;
  isIgnoringCancelled(): boolean;
}


declare interface $co$aikar$timings$TimingHistory {
  export(): any;
}

declare class co$aikar$timings$TimingHistory
  implements $co$aikar$timings$TimingHistory {
  static lastMinuteTime: number;
  static timedTicks: number;
  static playerTicks: number;
  static entityTicks: number;
  static tileEntityTicks: number;
  static activatedEntityTicks: number;
  constructor();
  static resetTicks(arg0: boolean): void;
  export(): any;
  static access$008(): number;
}


declare interface $co$aikar$timings$TimingHistory$MinuteReport {
  export(): any /* java.util.List */;
}

declare class co$aikar$timings$TimingHistory$MinuteReport
  implements $co$aikar$timings$TimingHistory$MinuteReport {
  constructor();
  export(): any /* java.util.List */;
}


declare interface $co$aikar$timings$TimingHistory$TicksRecord {}

declare class co$aikar$timings$TimingHistory$TicksRecord
  implements $co$aikar$timings$TimingHistory$TicksRecord {
  constructor();
}


declare interface $co$aikar$timings$TimingHistory$PingRecord {}

declare class co$aikar$timings$TimingHistory$PingRecord
  implements $co$aikar$timings$TimingHistory$PingRecord {
  constructor();
}


declare interface $co$aikar$timings$TimingHistoryEntry {
  export(): any /* java.util.List */;
}

declare class co$aikar$timings$TimingHistoryEntry
  implements $co$aikar$timings$TimingHistoryEntry {
  constructor(arg0: co$aikar$timings$TimingHandler);
  export(): any /* java.util.List */;
}


declare interface $co$aikar$timings$TimingHistory$1
  extends $com$google$common$base$Function {
  apply(arg0: string): any /* java.lang.Integer */;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$1
  implements $co$aikar$timings$TimingHistory$1 {
  constructor();
  apply(arg0: string): any /* java.lang.Integer */;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistory$2
  extends $com$google$common$base$Function {
  apply(arg0: org$bukkit$World): co$aikar$util$JSONUtil$JSONPair;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$2
  implements $co$aikar$timings$TimingHistory$2 {
  constructor(arg0: co$aikar$timings$TimingHistory);
  apply(arg0: org$bukkit$World): co$aikar$util$JSONUtil$JSONPair;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$util$JSONUtil$JSONPair {}

declare class co$aikar$util$JSONUtil$JSONPair
  implements $co$aikar$util$JSONUtil$JSONPair {
  constructor(arg0: string, arg1: any);
}


declare interface $co$aikar$timings$TimingHistory$2$1
  extends $com$google$common$base$Function {
  apply(arg0: co$aikar$timings$TimingHistory$RegionData): any;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$2$1
  implements $co$aikar$timings$TimingHistory$2$1 {
  constructor(arg0: co$aikar$timings$TimingHistory$2);
  apply(arg0: co$aikar$timings$TimingHistory$RegionData): any;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistory$RegionData {
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class co$aikar$timings$TimingHistory$RegionData
  implements $co$aikar$timings$TimingHistory$RegionData {
  constructor(arg0: co$aikar$timings$TimingHistory$RegionData$RegionId);
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $co$aikar$timings$TimingHistory$RegionData$RegionId {
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class co$aikar$timings$TimingHistory$RegionData$RegionId
  implements $co$aikar$timings$TimingHistory$RegionData$RegionId {
  constructor(arg0: number, arg1: number);
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $co$aikar$timings$TimingHistory$2$1$1
  extends $com$google$common$base$Function {
  apply(arg0: any /* java.util.Map$Entry */): co$aikar$util$JSONUtil$JSONPair;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$2$1$1
  implements $co$aikar$timings$TimingHistory$2$1$1 {
  constructor(arg0: co$aikar$timings$TimingHistory$2$1);
  apply(arg0: any /* java.util.Map$Entry */): co$aikar$util$JSONUtil$JSONPair;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistory$2$1$2
  extends $com$google$common$base$Function {
  apply(arg0: any /* java.util.Map$Entry */): co$aikar$util$JSONUtil$JSONPair;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$2$1$2
  implements $co$aikar$timings$TimingHistory$2$1$2 {
  constructor(arg0: co$aikar$timings$TimingHistory$2$1);
  apply(arg0: any /* java.util.Map$Entry */): co$aikar$util$JSONUtil$JSONPair;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistory$3
  extends $com$google$common$base$Function {
  apply(arg0: co$aikar$timings$TimingHistoryEntry): any;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$3
  implements $co$aikar$timings$TimingHistory$3 {
  constructor(arg0: co$aikar$timings$TimingHistory);
  apply(arg0: co$aikar$timings$TimingHistoryEntry): any;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistory$4
  extends $com$google$common$base$Function {
  apply(arg0: co$aikar$timings$TimingHistory$MinuteReport): any;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$4
  implements $co$aikar$timings$TimingHistory$4 {
  constructor(arg0: co$aikar$timings$TimingHistory);
  apply(arg0: co$aikar$timings$TimingHistory$MinuteReport): any;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistory$Counter {
  increment(): number;
  count(): number;
}

declare class co$aikar$timings$TimingHistory$Counter
  implements $co$aikar$timings$TimingHistory$Counter {
  increment(): number;
  count(): number;
  constructor(arg0: co$aikar$timings$TimingHistory$1);
}


declare interface $co$aikar$timings$TimingHistory$RegionData$1
  extends $com$google$common$base$Function {
  apply(
    arg0: co$aikar$timings$TimingHistory$RegionData$RegionId
  ): co$aikar$timings$TimingHistory$RegionData;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistory$RegionData$1
  implements $co$aikar$timings$TimingHistory$RegionData$1 {
  constructor();
  apply(
    arg0: co$aikar$timings$TimingHistory$RegionData$RegionId
  ): co$aikar$timings$TimingHistory$RegionData;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$TimingHistoryEntry$1
  extends $com$google$common$base$Function {
  apply(arg0: co$aikar$timings$TimingData): any;
  apply(arg0: any): any;
}

declare class co$aikar$timings$TimingHistoryEntry$1
  implements $co$aikar$timings$TimingHistoryEntry$1 {
  constructor(arg0: co$aikar$timings$TimingHistoryEntry);
  apply(arg0: co$aikar$timings$TimingData): any;
  apply(arg0: any): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$timings$Timings {}

declare class co$aikar$timings$Timings implements $co$aikar$timings$Timings {
  static NULL_HANDLER: co$aikar$timings$Timing;
  static of(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): co$aikar$timings$Timing;
  static of(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: co$aikar$timings$Timing
  ): co$aikar$timings$Timing;
  static ofStart(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): co$aikar$timings$Timing;
  static ofStart(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: co$aikar$timings$Timing
  ): co$aikar$timings$Timing;
  static isTimingsEnabled(): boolean;
  static setTimingsEnabled(arg0: boolean): void;
  static isVerboseTimingsEnabled(): boolean;
  static setVerboseTimingsEnabled(arg0: boolean): void;
  static getHistoryInterval(): number;
  static setHistoryInterval(arg0: number): void;
  static getHistoryLength(): number;
  static setHistoryLength(arg0: number): void;
  static reset(): void;
  static generateReport(arg0: org$bukkit$command$CommandSender): void;
  static generateReport(arg0: co$aikar$timings$TimingsReportListener): void;
  static ofSafe(arg0: string): co$aikar$timings$TimingHandler;
  static ofSafe(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): co$aikar$timings$Timing;
  static ofSafe(
    arg0: string,
    arg1: co$aikar$timings$Timing
  ): co$aikar$timings$TimingHandler;
  static ofSafe(
    arg0: string,
    arg1: string,
    arg2: co$aikar$timings$Timing
  ): co$aikar$timings$TimingHandler;
}


declare interface $co$aikar$timings$TimingsReportListener
  extends $org$bukkit$command$MessageCommandSender {
  getTimingsURL(): string;
  done(): void;
  done(arg0: string): void;
  sendMessage(arg0: string): void;
  addConsoleIfNeeded(): void;
}

declare class co$aikar$timings$TimingsReportListener
  implements $co$aikar$timings$TimingsReportListener {
  constructor(arg0: org$bukkit$command$CommandSender);
  constructor(
    arg0: org$bukkit$command$CommandSender,
    arg1: any /* java.lang.Runnable */
  );
  constructor(arg0: any /* java.util.List */);
  constructor(
    arg0: any /* java.util.List */,
    arg1: any /* java.lang.Runnable */
  );
  getTimingsURL(): string;
  done(): void;
  done(arg0: string): void;
  sendMessage(arg0: string): void;
  addConsoleIfNeeded(): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
}


declare interface $org$bukkit$command$MessageCommandSender
  extends $org$bukkit$command$CommandSender {
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  spigot(): org$bukkit$command$CommandSender$Spigot;
}

declare class org$bukkit$command$MessageCommandSender
  implements $org$bukkit$command$MessageCommandSender {
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: string): void;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
}


declare interface $co$aikar$timings$TimingsCommand {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}

declare class co$aikar$timings$TimingsCommand
  implements $co$aikar$timings$TimingsCommand {
  constructor(arg0: string);
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}


declare interface $co$aikar$timings$TimingsManager {}

declare class co$aikar$timings$TimingsManager
  implements $co$aikar$timings$TimingsManager {
  static FULL_SERVER_TICK: co$aikar$timings$FullServerTickHandler;
  static TIMINGS_TICK: co$aikar$timings$TimingHandler;
  static PLUGIN_GROUP_HANDLER: co$aikar$timings$Timing;
  static hiddenConfigs: any; /* java.util.List */
  static privacy: boolean;
  static reset(): void;
  static tick(): void;
  static stopServer(): void;
  static recheckEnabled(): void;
  static resetTimings(): void;
  static getHandler(
    arg0: string,
    arg1: string,
    arg2: co$aikar$timings$Timing
  ): co$aikar$timings$TimingHandler;
  static getCommandTiming(
    arg0: string,
    arg1: org$bukkit$command$Command
  ): co$aikar$timings$Timing;
  static getPluginByClassloader(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$Plugin;
}


declare interface $com$google$common$collect$EvictingQueue {
  remainingCapacity(): number;
  delegate(): any /* java.util.Queue */;
  offer(arg0: any): boolean;
  add(arg0: any): boolean;
  addAll(arg0: java$util$Collection): boolean;
  contains(arg0: any): boolean;
  remove(arg0: any): boolean;
  delegate(): java$util$Collection;
  delegate(): any;
}

declare class com$google$common$collect$EvictingQueue
  implements $com$google$common$collect$EvictingQueue {
  static create(arg0: number): com$google$common$collect$EvictingQueue;
  remainingCapacity(): number;
  delegate(): any /* java.util.Queue */;
  offer(arg0: any): boolean;
  add(arg0: any): boolean;
  addAll(arg0: java$util$Collection): boolean;
  contains(arg0: any): boolean;
  remove(arg0: any): boolean;
  delegate(): java$util$Collection;
  delegate(): any;
  size(): number;
  isEmpty(): boolean;
  iterator(): any /* java.util.Iterator */;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  containsAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  equals(arg0: any): boolean;
  hashCode(): number;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}


declare interface $co$aikar$timings$UnsafeTimingHandler {
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
}

declare class co$aikar$timings$UnsafeTimingHandler
  implements $co$aikar$timings$UnsafeTimingHandler {
  constructor(arg0: co$aikar$timings$TimingIdentifier);
  startTiming(): co$aikar$timings$Timing;
  stopTiming(): void;
  startTimingIfSync(): co$aikar$timings$Timing;
  stopTimingIfSync(): void;
  abort(): void;
  getTimingHandler(): co$aikar$timings$TimingHandler;
  close(): void;
}


declare interface $co$aikar$util$Counter {
  decrement(arg0: any): number;
  increment(arg0: any): number;
  decrement(arg0: any, arg1: number): number;
  increment(arg0: any, arg1: number): number;
  getCount(arg0: any): number;
  delegate(): any /* java.util.Map */;
  delegate(): any;
}

declare class co$aikar$util$Counter implements $co$aikar$util$Counter {
  constructor();
  decrement(arg0: any): number;
  increment(arg0: any): number;
  decrement(arg0: any, arg1: number): number;
  increment(arg0: any, arg1: number): number;
  getCount(arg0: any): number;
  delegate(): any /* java.util.Map */;
  delegate(): any;
}


declare interface $co$aikar$util$JSONUtil {}

declare class co$aikar$util$JSONUtil implements $co$aikar$util$JSONUtil {
  static pair(arg0: string, arg1: any): co$aikar$util$JSONUtil$JSONPair;
  static pair(arg0: number, arg1: any): co$aikar$util$JSONUtil$JSONPair;
  static createObject(
    arg0: JavaArray<co$aikar$util$JSONUtil$JSONPair>
  ): any /* java.util.Map */;
  static appendObjectData(
    arg0: any /* java.util.Map */,
    arg1: JavaArray<co$aikar$util$JSONUtil$JSONPair>
  ): any /* java.util.Map */;
  static toArray(arg0: JavaArray<any>): any /* java.util.List */;
  static toArrayMapper(
    arg0: JavaArray<any>,
    arg1: com$google$common$base$Function
  ): any /* java.util.List */;
  static toArrayMapper(
    arg0: any /* java.lang.Iterable */,
    arg1: com$google$common$base$Function
  ): any /* java.util.List */;
  static toObjectMapper(
    arg0: JavaArray<any>,
    arg1: com$google$common$base$Function
  ): any /* java.util.Map */;
  static toObjectMapper(
    arg0: any /* java.lang.Iterable */,
    arg1: com$google$common$base$Function
  ): any /* java.util.Map */;
}


declare interface $co$aikar$util$LoadingIntMap {
  get(arg0: number): any;
}

declare class co$aikar$util$LoadingIntMap
  implements $co$aikar$util$LoadingIntMap {
  constructor(arg0: com$google$common$base$Function);
  constructor(arg0: number, arg1: com$google$common$base$Function);
  constructor(
    arg0: number,
    arg1: number,
    arg2: com$google$common$base$Function
  );
  get(arg0: number): any;
}


declare interface $co$aikar$util$LoadingIntMap$Feeder
  extends $com$google$common$base$Function {
  apply(arg0: any): any;
  apply(): any;
}

declare class co$aikar$util$LoadingIntMap$Feeder
  implements $co$aikar$util$LoadingIntMap$Feeder {
  constructor();
  apply(arg0: any): any;
  apply(): any;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$util$LoadingMap {
  size(): number;
  isEmpty(): boolean;
  containsKey(arg0: any): boolean;
  containsValue(arg0: any): boolean;
  get(arg0: any): any;
  put(arg0: any, arg1: any): any;
  remove(arg0: any): any;
  putAll(arg0: any /* java.util.Map */): void;
  clear(): void;
  keySet(): any /* java.util.Set */;
  values(): java$util$Collection;
  equals(arg0: any): boolean;
  hashCode(): number;
  entrySet(): any /* java.util.Set */;
  clone(): co$aikar$util$LoadingMap;
  clone(): any;
}

declare class co$aikar$util$LoadingMap implements $co$aikar$util$LoadingMap {
  constructor(
    arg0: any /* java.util.Map */,
    arg1: any /* java.util.function.Function */
  );
  static of(
    arg0: any /* java.util.Map */,
    arg1: any /* java.util.function.Function */
  ): any /* java.util.Map */;
  static newAutoMap(
    arg0: any /* java.util.Map */,
    arg1: any /* java.lang.Class */,
    arg2: any /* java.lang.Class */
  ): any /* java.util.Map */;
  static newAutoMap(
    arg0: any /* java.util.Map */,
    arg1: any /* java.lang.Class */
  ): any /* java.util.Map */;
  static newHashAutoMap(
    arg0: any /* java.lang.Class */,
    arg1: any /* java.lang.Class */
  ): any /* java.util.Map */;
  static newHashAutoMap(
    arg0: any /* java.lang.Class */
  ): any /* java.util.Map */;
  static newHashAutoMap(
    arg0: any /* java.lang.Class */,
    arg1: any /* java.lang.Class */,
    arg2: number,
    arg3: number
  ): any /* java.util.Map */;
  static newHashAutoMap(
    arg0: any /* java.lang.Class */,
    arg1: number,
    arg2: number
  ): any /* java.util.Map */;
  static newHashMap(
    arg0: any /* java.util.function.Function */
  ): any /* java.util.Map */;
  static newHashMap(
    arg0: any /* java.util.function.Function */,
    arg1: number
  ): any /* java.util.Map */;
  static newHashMap(
    arg0: any /* java.util.function.Function */,
    arg1: number,
    arg2: number
  ): any /* java.util.Map */;
  static newIdentityHashMap(
    arg0: any /* java.util.function.Function */
  ): any /* java.util.Map */;
  static newIdentityHashMap(
    arg0: any /* java.util.function.Function */,
    arg1: number
  ): any /* java.util.Map */;
  size(): number;
  isEmpty(): boolean;
  containsKey(arg0: any): boolean;
  containsValue(arg0: any): boolean;
  get(arg0: any): any;
  put(arg0: any, arg1: any): any;
  remove(arg0: any): any;
  putAll(arg0: any /* java.util.Map */): void;
  clear(): void;
  keySet(): any /* java.util.Set */;
  values(): java$util$Collection;
  equals(arg0: any): boolean;
  hashCode(): number;
  entrySet(): any /* java.util.Set */;
  clone(): co$aikar$util$LoadingMap;
  clone(): any;
}


declare interface $co$aikar$util$LoadingMap$AutoInstantiatingLoader {
  apply(arg0: any): any;
  hashCode(): number;
  equals(arg0: any): boolean;
}

declare class co$aikar$util$LoadingMap$AutoInstantiatingLoader
  implements $co$aikar$util$LoadingMap$AutoInstantiatingLoader {
  constructor(arg0: any /* java.lang.Class */, arg1: any /* java.lang.Class */);
  apply(arg0: any): any;
  hashCode(): number;
  equals(arg0: any): boolean;
}


declare interface $co$aikar$util$LoadingMap$Feeder {
  apply(arg0: any): any;
  apply(): any;
}

declare class co$aikar$util$LoadingMap$Feeder
  implements $co$aikar$util$LoadingMap$Feeder {
  constructor();
  apply(arg0: any): any;
  apply(): any;
}


declare interface $co$aikar$util$MRUMapCache {
  size(): number;
  isEmpty(): boolean;
  containsKey(arg0: any): boolean;
  containsValue(arg0: any): boolean;
  get(arg0: any): any;
  put(arg0: any, arg1: any): any;
  remove(arg0: any): any;
  putAll(arg0: any /* java.util.Map */): void;
  clear(): void;
  keySet(): any /* java.util.Set */;
  values(): java$util$Collection;
  entrySet(): any /* java.util.Set */;
}

declare class co$aikar$util$MRUMapCache implements $co$aikar$util$MRUMapCache {
  constructor(arg0: any /* java.util.Map */);
  size(): number;
  isEmpty(): boolean;
  containsKey(arg0: any): boolean;
  containsValue(arg0: any): boolean;
  get(arg0: any): any;
  put(arg0: any, arg1: any): any;
  remove(arg0: any): any;
  putAll(arg0: any /* java.util.Map */): void;
  clear(): void;
  keySet(): any /* java.util.Set */;
  values(): java$util$Collection;
  entrySet(): any /* java.util.Set */;
  static of(arg0: any /* java.util.Map */): any /* java.util.Map */;
}


declare interface $com$destroystokyo$paper$ClientOption$ChatVisibility {}

declare class com$destroystokyo$paper$ClientOption$ChatVisibility
  implements $com$destroystokyo$paper$ClientOption$ChatVisibility {
  static FULL: com$destroystokyo$paper$ClientOption$ChatVisibility;
  static SYSTEM: com$destroystokyo$paper$ClientOption$ChatVisibility;
  static HIDDEN: com$destroystokyo$paper$ClientOption$ChatVisibility;
  static UNKNOWN: com$destroystokyo$paper$ClientOption$ChatVisibility;
  static values(): JavaArray<
    com$destroystokyo$paper$ClientOption$ChatVisibility
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$ClientOption$ChatVisibility;
}


declare interface $com$destroystokyo$paper$entity$ai$VanillaGoal
  extends $com$destroystokyo$paper$entity$ai$Goal {}

declare class com$destroystokyo$paper$entity$ai$VanillaGoal
  implements $com$destroystokyo$paper$entity$ai$VanillaGoal {
  static BEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_BECOME_ANGRY: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_ENTER_HIVE: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_GO_TO_HIVE: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_GO_TO_KNOWN_FLOWER: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_GROW_CROP: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_HURT_BY_OTHER: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_LOCATE_HIVE: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_POLLINATE: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEE_WANDER: com$destroystokyo$paper$entity$ai$GoalKey;
  static BLAZE_FIREBALL: com$destroystokyo$paper$entity$ai$GoalKey;
  static TEMPT_CHANCE: com$destroystokyo$paper$entity$ai$GoalKey;
  static CAT_AVOID_ENTITY: com$destroystokyo$paper$entity$ai$GoalKey;
  static CAT_RELAX_ON_OWNER: com$destroystokyo$paper$entity$ai$GoalKey;
  static DOLPHIN_SWIM_TO_TREASURE: com$destroystokyo$paper$entity$ai$GoalKey;
  static DOLPHIN_SWIM_WITH_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static DOLPHIN_PLAY_WITH_ITEMS: com$destroystokyo$paper$entity$ai$GoalKey;
  static DROWNED_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static DROWNED_GOTO_BEACH: com$destroystokyo$paper$entity$ai$GoalKey;
  static DROWNED_GOTO_WATER: com$destroystokyo$paper$entity$ai$GoalKey;
  static DROWNED_SWIM_UP: com$destroystokyo$paper$entity$ai$GoalKey;
  static DROWNED_TRIDENT_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static ENDERMAN_PICKUP_BLOCK: com$destroystokyo$paper$entity$ai$GoalKey;
  static ENDERMAN_PLACE_BLOCK: com$destroystokyo$paper$entity$ai$GoalKey;
  static PLAYER_WHO_LOOKED_AT_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static ENDERMAN_FREEZE_WHEN_LOOKED_AT: com$destroystokyo$paper$entity$ai$GoalKey;
  static EVOKER_ATTACK_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static EVOKER_CAST_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static EVOKER_SUMMON_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static EVOKER_WOLOLO_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static FISH_SWIM: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_DEFEND_TRUSTED: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_FACEPLANT: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_BREED: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_EAT_BERRIES: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_FLOAT: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_FOLLOW_PARENT: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_LOOK_AT_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_MELEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_PANIC: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_PERCH_AND_SEARCH: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_POUNCE: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_SEARCH_FOR_ITEMS: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_SLEEP: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_STROLL_THROUGH_VILLAGE: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_SEEK_SHELTER: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOX_STALK_PREY: com$destroystokyo$paper$entity$ai$GoalKey;
  static GHAST_ATTACK_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static GHAST_IDLE_MOVE: com$destroystokyo$paper$entity$ai$GoalKey;
  static GHAST_MOVE_TOWARDS_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static GUARDIAN_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAIDER_OPEN_DOOR: com$destroystokyo$paper$entity$ai$GoalKey;
  static ILLUSIONER_BLINDNESS_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static ILLUSIONER_MIRROR_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static SPELLCASTER_CAST_SPELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static LLAMA_ATTACK_WOLF: com$destroystokyo$paper$entity$ai$GoalKey;
  static LLAMA_HURT_BY: com$destroystokyo$paper$entity$ai$GoalKey;
  static LLAMATRADER_DEFENDED_WANDERING_TRADER: com$destroystokyo$paper$entity$ai$GoalKey;
  static LONG_DISTANCE_PATROL: com$destroystokyo$paper$entity$ai$GoalKey;
  static OCELOT_AVOID_ENTITY: com$destroystokyo$paper$entity$ai$GoalKey;
  static OCELOT_TEMPT: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_AVOID: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_BREED: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_HURT_BY_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_LIE_ON_BACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_LOOK_AT_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_PANIC: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_ROLL: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_SIT: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANDA_SNEEZE: com$destroystokyo$paper$entity$ai$GoalKey;
  static PHANTOM_ATTACK_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static PHANTOM_ATTACK_STRATEGY: com$destroystokyo$paper$entity$ai$GoalKey;
  static PHANTOM_CIRCLE_AROUND_ANCHOR: com$destroystokyo$paper$entity$ai$GoalKey;
  static PHANTOM_SWEEP_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static ANGER: com$destroystokyo$paper$entity$ai$GoalKey;
  static ANGER_OTHER: com$destroystokyo$paper$entity$ai$GoalKey;
  static POLARBEAR_ATTACK_PLAYERS: com$destroystokyo$paper$entity$ai$GoalKey;
  static POLARBEAR_HURT_BY: com$destroystokyo$paper$entity$ai$GoalKey;
  static POLARBEAR_MELEE: com$destroystokyo$paper$entity$ai$GoalKey;
  static POLARBEAR_PANIC: com$destroystokyo$paper$entity$ai$GoalKey;
  static PUFFERFISH_PUFF: com$destroystokyo$paper$entity$ai$GoalKey;
  static EAT_CARROTS: com$destroystokyo$paper$entity$ai$GoalKey;
  static KILLER_RABBIT_MELEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static RABBIT_AVOID_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static RABBIT_PANIC: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAIDER_HOLD_GROUND: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAIDER_OBTAIN_BANNER: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAIDER_CELEBRATION: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAIDER_MOVE_THROUGH_VILLAGE: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAVAGER_MELEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static SHULKER_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static SHULKER_DEFENSE: com$destroystokyo$paper$entity$ai$GoalKey;
  static SHULKER_NEAREST: com$destroystokyo$paper$entity$ai$GoalKey;
  static SHULKER_PEEK: com$destroystokyo$paper$entity$ai$GoalKey;
  static SILVERFISH_HIDE_IN_BLOCK: com$destroystokyo$paper$entity$ai$GoalKey;
  static SILVERFISH_WAKE_OTHERS: com$destroystokyo$paper$entity$ai$GoalKey;
  static SKELETON_MELEE: com$destroystokyo$paper$entity$ai$GoalKey;
  static SLIME_IDLE: com$destroystokyo$paper$entity$ai$GoalKey;
  static SLIME_NEAREST_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static SLIME_RANDOM_DIRECTION: com$destroystokyo$paper$entity$ai$GoalKey;
  static SLIME_RANDOM_JUMP: com$destroystokyo$paper$entity$ai$GoalKey;
  static SPIDER_MELEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static SPIDER_NEAREST_ATTACKABLE_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static SQUID: com$destroystokyo$paper$entity$ai$GoalKey;
  static SQUID_FLEE: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_BREED: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_GO_HOME: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_GOTO_WATER: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_LAY_EGG: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_PANIC: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_RANDOM_STROLL: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_TEMPT: com$destroystokyo$paper$entity$ai$GoalKey;
  static TURTLE_TRAVEL: com$destroystokyo$paper$entity$ai$GoalKey;
  static VEX_CHARGE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static VEX_COPY_TARGET_OF_OWNER: com$destroystokyo$paper$entity$ai$GoalKey;
  static VEX_RANDOM_MOVE: com$destroystokyo$paper$entity$ai$GoalKey;
  static VILLAGERTRADER_WANDER_TO_POSITION: com$destroystokyo$paper$entity$ai$GoalKey;
  static VINDICATOR_BREAK_DOOR: com$destroystokyo$paper$entity$ai$GoalKey;
  static VINDICATOR_JOHNNY_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static VINDICATOR_MELEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static WITHER_DO_NOTHING: com$destroystokyo$paper$entity$ai$GoalKey;
  static WOLF_AVOID_ENTITY: com$destroystokyo$paper$entity$ai$GoalKey;
  static ZOMBIE_ATTACK_TURTLE_EGG: com$destroystokyo$paper$entity$ai$GoalKey;
  static ARROW_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static AVOID_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static BEG: com$destroystokyo$paper$entity$ai$GoalKey;
  static BOW_SHOOT: com$destroystokyo$paper$entity$ai$GoalKey;
  static BREAK_DOOR: com$destroystokyo$paper$entity$ai$GoalKey;
  static BREATH: com$destroystokyo$paper$entity$ai$GoalKey;
  static BREED: com$destroystokyo$paper$entity$ai$GoalKey;
  static CAT_SIT_ON_BED: com$destroystokyo$paper$entity$ai$GoalKey;
  static CROSSBOW_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static DEFEND_VILLAGE: com$destroystokyo$paper$entity$ai$GoalKey;
  static DOOR_OPEN: com$destroystokyo$paper$entity$ai$GoalKey;
  static EAT_TILE: com$destroystokyo$paper$entity$ai$GoalKey;
  static FISH_SCHOOL: com$destroystokyo$paper$entity$ai$GoalKey;
  static FLEE_SUN: com$destroystokyo$paper$entity$ai$GoalKey;
  static FLOAT: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOLLOW_BOAT: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOLLOW_ENTITY: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOLLOW_OWNER: com$destroystokyo$paper$entity$ai$GoalKey;
  static FOLLOW_PARENT: com$destroystokyo$paper$entity$ai$GoalKey;
  static HORSE_TRAP: com$destroystokyo$paper$entity$ai$GoalKey;
  static HURT_BY_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static INTERACT: com$destroystokyo$paper$entity$ai$GoalKey;
  static JUMP_ON_BLOCK: com$destroystokyo$paper$entity$ai$GoalKey;
  static LEAP_AT_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static LLAMA_FOLLOW: com$destroystokyo$paper$entity$ai$GoalKey;
  static LOOK_AT_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static LOOK_AT_TRADING_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static MELEE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static MOVE_THROUGH_VILLAGE: com$destroystokyo$paper$entity$ai$GoalKey;
  static MOVE_TOWARDS_RESTRICTION: com$destroystokyo$paper$entity$ai$GoalKey;
  static MOVE_TOWARDS_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static NEAREST_ATTACKABLE_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static NEAREST_ATTACKABLE_TARGET_WITCH: com$destroystokyo$paper$entity$ai$GoalKey;
  static NEAREST_HEALABLE_RAIDER: com$destroystokyo$paper$entity$ai$GoalKey;
  static NEAREST_VILLAGE: com$destroystokyo$paper$entity$ai$GoalKey;
  static OCELOT_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  static OFFER_FLOWER: com$destroystokyo$paper$entity$ai$GoalKey;
  static OWNER_HURT_BY_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static OWNER_HURT_TARGET: com$destroystokyo$paper$entity$ai$GoalKey;
  static PANIC: com$destroystokyo$paper$entity$ai$GoalKey;
  static PERCH: com$destroystokyo$paper$entity$ai$GoalKey;
  static RAID: com$destroystokyo$paper$entity$ai$GoalKey;
  static RANDOM_FLY: com$destroystokyo$paper$entity$ai$GoalKey;
  static RANDOM_LOOKAROUND: com$destroystokyo$paper$entity$ai$GoalKey;
  static RANDOM_STROLL: com$destroystokyo$paper$entity$ai$GoalKey;
  static RANDOM_STROLL_LAND: com$destroystokyo$paper$entity$ai$GoalKey;
  static RANDOM_SWIM: com$destroystokyo$paper$entity$ai$GoalKey;
  static RANDOM_TARGET_NON_TAMED: com$destroystokyo$paper$entity$ai$GoalKey;
  static REMOVE_BLOCK: com$destroystokyo$paper$entity$ai$GoalKey;
  static RESTRICT_SUN: com$destroystokyo$paper$entity$ai$GoalKey;
  static SIT: com$destroystokyo$paper$entity$ai$GoalKey;
  static STROLL_VILLAGE: com$destroystokyo$paper$entity$ai$GoalKey;
  static SWELL: com$destroystokyo$paper$entity$ai$GoalKey;
  static TAME: com$destroystokyo$paper$entity$ai$GoalKey;
  static TEMPT: com$destroystokyo$paper$entity$ai$GoalKey;
  static TRADE_WITH_PLAYER: com$destroystokyo$paper$entity$ai$GoalKey;
  static USE_ITEM: com$destroystokyo$paper$entity$ai$GoalKey;
  static WATER: com$destroystokyo$paper$entity$ai$GoalKey;
  static WATER_JUMP: com$destroystokyo$paper$entity$ai$GoalKey;
  static ZOMBIE_ATTACK: com$destroystokyo$paper$entity$ai$GoalKey;
  shouldActivate(): boolean;
  shouldStayActive(): boolean;
  start(): void;
  stop(): void;
  tick(): void;
  getKey(): com$destroystokyo$paper$entity$ai$GoalKey;
  getTypes(): any /* java.util.EnumSet */;
}


declare interface $com$destroystokyo$paper$entity$RangedEntity
  extends $org$bukkit$entity$Mob {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
}

declare class com$destroystokyo$paper$entity$RangedEntity
  implements $com$destroystokyo$paper$entity$RangedEntity {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$event$block$AnvilDamagedEvent
  extends $org$bukkit$event$Cancellable {
  getInventory(): org$bukkit$inventory$AnvilInventory;
  getDamageState(): com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  setDamageState(
    arg0: com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState
  ): void;
  isBreaking(): boolean;
  setBreaking(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class com$destroystokyo$paper$event$block$AnvilDamagedEvent
  implements $com$destroystokyo$paper$event$block$AnvilDamagedEvent {
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$block$data$BlockData
  );
  getInventory(): org$bukkit$inventory$AnvilInventory;
  getDamageState(): com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  setDamageState(
    arg0: com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState
  ): void;
  isBreaking(): boolean;
  setBreaking(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}


declare interface $org$bukkit$inventory$AnvilInventory
  extends $org$bukkit$inventory$Inventory {
  getRenameText(): string;
  getRepairCost(): number;
  setRepairCost(arg0: number): void;
  getMaximumRepairCost(): number;
  setMaximumRepairCost(arg0: number): void;
  getFirstItem(): org$bukkit$inventory$ItemStack;
  setFirstItem(arg0: org$bukkit$inventory$ItemStack): void;
  getSecondItem(): org$bukkit$inventory$ItemStack;
  setSecondItem(arg0: org$bukkit$inventory$ItemStack): void;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$AnvilInventory
  implements $org$bukkit$inventory$AnvilInventory {
  getRenameText(): string;
  getRepairCost(): number;
  setRepairCost(arg0: number): void;
  getMaximumRepairCost(): number;
  setMaximumRepairCost(arg0: number): void;
  getFirstItem(): org$bukkit$inventory$ItemStack;
  setFirstItem(arg0: org$bukkit$inventory$ItemStack): void;
  getSecondItem(): org$bukkit$inventory$ItemStack;
  setSecondItem(arg0: org$bukkit$inventory$ItemStack): void;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState {
  getMaterial(): org$bukkit$Material;
}

declare class com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState
  implements
    $com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState {
  static FULL: com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  static CHIPPED: com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  static DAMAGED: com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  static BROKEN: com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  static values(): JavaArray<
    com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  getMaterial(): org$bukkit$Material;
  static getState(
    arg0: org$bukkit$block$data$BlockData
  ): com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  static getState(
    arg0: org$bukkit$Material
  ): com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
}


declare interface $com$destroystokyo$paper$event$block$BeaconEffectEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEffect(): org$bukkit$potion$PotionEffect;
  setEffect(arg0: org$bukkit$potion$PotionEffect): void;
  getPlayer(): org$bukkit$entity$Player;
  isPrimary(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$block$BeaconEffectEvent
  implements $com$destroystokyo$paper$event$block$BeaconEffectEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$potion$PotionEffect,
    arg2: org$bukkit$entity$Player,
    arg3: boolean
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEffect(): org$bukkit$potion$PotionEffect;
  setEffect(arg0: org$bukkit$potion$PotionEffect): void;
  getPlayer(): org$bukkit$entity$Player;
  isPrimary(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$block$BlockDestroyEvent
  extends $org$bukkit$event$Cancellable {
  getNewState(): org$bukkit$block$data$BlockData;
  willDrop(): boolean;
  playEffect(): boolean;
  setPlayEffect(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$block$BlockDestroyEvent
  implements $com$destroystokyo$paper$event$block$BlockDestroyEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$data$BlockData,
    arg2: boolean
  );
  getNewState(): org$bukkit$block$data$BlockData;
  willDrop(): boolean;
  playEffect(): boolean;
  setPlayEffect(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$block$TNTPrimeEvent
  extends $org$bukkit$event$Cancellable {
  getReason(): com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  getPrimerEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$block$TNTPrimeEvent
  implements $com$destroystokyo$paper$event$block$TNTPrimeEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason,
    arg2: org$bukkit$entity$Entity
  );
  getReason(): com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  getPrimerEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason {}

declare class com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason
  implements $com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason {
  static EXPLOSION: com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  static FIRE: com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  static ITEM: com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  static PROJECTILE: com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  static REDSTONE: com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  static values(): JavaArray<
    com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
}


declare interface $com$destroystokyo$paper$event$entity$CreeperIgniteEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Creeper;
  isIgnited(): boolean;
  setIgnited(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$CreeperIgniteEvent
  implements $com$destroystokyo$paper$event$entity$CreeperIgniteEvent {
  constructor(arg0: org$bukkit$entity$Creeper, arg1: boolean);
  getEntity(): org$bukkit$entity$Creeper;
  isIgnited(): boolean;
  setIgnited(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$Creeper
  extends $org$bukkit$entity$Monster {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  setMaxFuseTicks(arg0: number): void;
  getMaxFuseTicks(): number;
  setExplosionRadius(arg0: number): void;
  getExplosionRadius(): number;
  explode(): void;
  ignite(): void;
  setIgnited(arg0: boolean): void;
  isIgnited(): boolean;
  getFuseTicks(): number;
}

declare class org$bukkit$entity$Creeper implements $org$bukkit$entity$Creeper {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  setMaxFuseTicks(arg0: number): void;
  getMaxFuseTicks(): number;
  setExplosionRadius(arg0: number): void;
  getExplosionRadius(): number;
  explode(): void;
  ignite(): void;
  setIgnited(arg0: boolean): void;
  isIgnited(): boolean;
  getFuseTicks(): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Monster
  extends $org$bukkit$entity$Creature {}

declare class org$bukkit$entity$Monster implements $org$bukkit$entity$Monster {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$event$entity$EnderDragonFireballHitEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$DragonFireball;
  getTargets(): java$util$Collection;
  getAreaEffectCloud(): org$bukkit$entity$AreaEffectCloud;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EnderDragonFireballHitEvent
  implements $com$destroystokyo$paper$event$entity$EnderDragonFireballHitEvent {
  constructor(
    arg0: org$bukkit$entity$DragonFireball,
    arg1: java$util$Collection,
    arg2: org$bukkit$entity$AreaEffectCloud
  );
  getEntity(): org$bukkit$entity$DragonFireball;
  getTargets(): java$util$Collection;
  getAreaEffectCloud(): org$bukkit$entity$AreaEffectCloud;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$DragonFireball
  extends $org$bukkit$entity$Fireball {}

declare class org$bukkit$entity$DragonFireball
  implements $org$bukkit$entity$DragonFireball {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Explosive
  extends $org$bukkit$entity$Entity {
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
}

declare class org$bukkit$entity$Explosive
  implements $org$bukkit$entity$Explosive {
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Fireball
  extends $org$bukkit$entity$Projectile,
    $org$bukkit$entity$Explosive {
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
}

declare class org$bukkit$entity$Fireball
  implements $org$bukkit$entity$Fireball {
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$AreaEffectCloud
  extends $org$bukkit$entity$Entity {
  getDuration(): number;
  setDuration(arg0: number): void;
  getWaitTime(): number;
  setWaitTime(arg0: number): void;
  getReapplicationDelay(): number;
  setReapplicationDelay(arg0: number): void;
  getDurationOnUse(): number;
  setDurationOnUse(arg0: number): void;
  getRadius(): number;
  setRadius(arg0: number): void;
  getRadiusOnUse(): number;
  setRadiusOnUse(arg0: number): void;
  getRadiusPerTick(): number;
  setRadiusPerTick(arg0: number): void;
  getParticle(): org$bukkit$Particle;
  setParticle(arg0: org$bukkit$Particle): void;
  setParticle(arg0: org$bukkit$Particle, arg1: any): void;
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): void;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  getSource(): org$bukkit$projectiles$ProjectileSource;
  setSource(arg0: org$bukkit$projectiles$ProjectileSource): void;
}

declare class org$bukkit$entity$AreaEffectCloud
  implements $org$bukkit$entity$AreaEffectCloud {
  getDuration(): number;
  setDuration(arg0: number): void;
  getWaitTime(): number;
  setWaitTime(arg0: number): void;
  getReapplicationDelay(): number;
  setReapplicationDelay(arg0: number): void;
  getDurationOnUse(): number;
  setDurationOnUse(arg0: number): void;
  getRadius(): number;
  setRadius(arg0: number): void;
  getRadiusOnUse(): number;
  setRadiusOnUse(arg0: number): void;
  getRadiusPerTick(): number;
  setRadiusPerTick(arg0: number): void;
  getParticle(): org$bukkit$Particle;
  setParticle(arg0: org$bukkit$Particle): void;
  setParticle(arg0: org$bukkit$Particle, arg1: any): void;
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): void;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  getSource(): org$bukkit$projectiles$ProjectileSource;
  setSource(arg0: org$bukkit$projectiles$ProjectileSource): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $com$destroystokyo$paper$event$entity$EnderDragonFlameEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$EnderDragon;
  getAreaEffectCloud(): org$bukkit$entity$AreaEffectCloud;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EnderDragonFlameEvent
  implements $com$destroystokyo$paper$event$entity$EnderDragonFlameEvent {
  constructor(
    arg0: org$bukkit$entity$EnderDragon,
    arg1: org$bukkit$entity$AreaEffectCloud
  );
  getEntity(): org$bukkit$entity$EnderDragon;
  getAreaEffectCloud(): org$bukkit$entity$AreaEffectCloud;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$EnderDragonShootFireballEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$EnderDragon;
  getFireball(): org$bukkit$entity$DragonFireball;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EnderDragonShootFireballEvent
  implements
    $com$destroystokyo$paper$event$entity$EnderDragonShootFireballEvent {
  constructor(
    arg0: org$bukkit$entity$EnderDragon,
    arg1: org$bukkit$entity$DragonFireball
  );
  getEntity(): org$bukkit$entity$EnderDragon;
  getFireball(): org$bukkit$entity$DragonFireball;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$EndermanAttackPlayerEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Enderman;
  getPlayer(): org$bukkit$entity$Player;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EndermanAttackPlayerEvent
  implements $com$destroystokyo$paper$event$entity$EndermanAttackPlayerEvent {
  constructor(arg0: org$bukkit$entity$Enderman, arg1: org$bukkit$entity$Player);
  getEntity(): org$bukkit$entity$Enderman;
  getPlayer(): org$bukkit$entity$Player;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$Enderman
  extends $org$bukkit$entity$Monster {
  teleportRandomly(): boolean;
  getCarriedMaterial(): org$bukkit$material$MaterialData;
  setCarriedMaterial(arg0: org$bukkit$material$MaterialData): void;
  getCarriedBlock(): org$bukkit$block$data$BlockData;
  setCarriedBlock(arg0: org$bukkit$block$data$BlockData): void;
}

declare class org$bukkit$entity$Enderman
  implements $org$bukkit$entity$Enderman {
  teleportRandomly(): boolean;
  getCarriedMaterial(): org$bukkit$material$MaterialData;
  setCarriedMaterial(arg0: org$bukkit$material$MaterialData): void;
  getCarriedBlock(): org$bukkit$block$data$BlockData;
  setCarriedBlock(arg0: org$bukkit$block$data$BlockData): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$event$entity$EndermanEscapeEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Enderman;
  getReason(): com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EndermanEscapeEvent
  implements $com$destroystokyo$paper$event$entity$EndermanEscapeEvent {
  constructor(
    arg0: org$bukkit$entity$Enderman,
    arg1: com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason
  );
  getEntity(): org$bukkit$entity$Enderman;
  getReason(): com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason {}

declare class com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason
  implements $com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason {
  static RUNAWAY: com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  static INDIRECT: com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  static CRITICAL_HIT: com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  static STARE: com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  static DROWN: com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  static values(): JavaArray<
    com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
}


declare interface $com$destroystokyo$paper$event$entity$EntityAddToWorldEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$entity$EntityAddToWorldEvent
  implements $com$destroystokyo$paper$event$entity$EntityAddToWorldEvent {
  constructor(arg0: org$bukkit$entity$Entity);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$entity$EntityJumpEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EntityJumpEvent
  implements $com$destroystokyo$paper$event$entity$EntityJumpEvent {
  constructor(arg0: org$bukkit$entity$LivingEntity);
  getEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$EntityKnockbackByEntityEvent
  extends $org$bukkit$event$Cancellable {
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$LivingEntity;
  getKnockbackStrength(): number;
  getHitBy(): org$bukkit$entity$Entity;
  getAcceleration(): org$bukkit$util$Vector;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$EntityKnockbackByEntityEvent
  implements
    $com$destroystokyo$paper$event$entity$EntityKnockbackByEntityEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$entity$Entity,
    arg2: number,
    arg3: org$bukkit$util$Vector
  );
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$LivingEntity;
  getKnockbackStrength(): number;
  getHitBy(): org$bukkit$entity$Entity;
  getAcceleration(): org$bukkit$util$Vector;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$EntityPathfindEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Entity;
  getTargetEntity(): org$bukkit$entity$Entity;
  getLoc(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$entity$EntityPathfindEvent
  implements $com$destroystokyo$paper$event$entity$EntityPathfindEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$entity$Entity
  );
  getEntity(): org$bukkit$entity$Entity;
  getTargetEntity(): org$bukkit$entity$Entity;
  getLoc(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$EntityRemoveFromWorldEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$entity$EntityRemoveFromWorldEvent
  implements $com$destroystokyo$paper$event$entity$EntityRemoveFromWorldEvent {
  constructor(arg0: org$bukkit$entity$Entity);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$entity$EntityTeleportEndGatewayEvent {
  getGateway(): org$bukkit$block$EndGateway;
}

declare class com$destroystokyo$paper$event$entity$EntityTeleportEndGatewayEvent
  implements
    $com$destroystokyo$paper$event$entity$EntityTeleportEndGatewayEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: org$bukkit$block$EndGateway
  );
  getGateway(): org$bukkit$block$EndGateway;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$block$EndGateway
  extends $org$bukkit$block$TileState {
  getExitLocation(): org$bukkit$Location;
  setExitLocation(arg0: org$bukkit$Location): void;
  isExactTeleport(): boolean;
  setExactTeleport(arg0: boolean): void;
  getAge(): number;
  setAge(arg0: number): void;
}

declare class org$bukkit$block$EndGateway
  implements $org$bukkit$block$EndGateway {
  getExitLocation(): org$bukkit$Location;
  setExitLocation(arg0: org$bukkit$Location): void;
  isExactTeleport(): boolean;
  setExactTeleport(arg0: boolean): void;
  getAge(): number;
  setAge(arg0: number): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $com$destroystokyo$paper$event$entity$EntityTransformedEvent
  extends $org$bukkit$event$Cancellable {
  getTransformed(): org$bukkit$entity$Entity;
  getReason(): com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$entity$EntityTransformedEvent
  implements $com$destroystokyo$paper$event$entity$EntityTransformedEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason
  );
  getTransformed(): org$bukkit$entity$Entity;
  getReason(): com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason {}

declare class com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason
  implements
    $com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason {
  static DROWNED: com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  static CURED: com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  static INFECTED: com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  static SHEARED: com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  static LIGHTNING: com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  static values(): JavaArray<
    com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
}


declare interface $com$destroystokyo$paper$event$entity$EntityZapEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getBolt(): org$bukkit$entity$LightningStrike;
  getReplacementEntity(): org$bukkit$entity$Entity;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$entity$EntityZapEvent
  implements $com$destroystokyo$paper$event$entity$EntityZapEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$LightningStrike,
    arg2: org$bukkit$entity$Entity
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getBolt(): org$bukkit$entity$LightningStrike;
  getReplacementEntity(): org$bukkit$entity$Entity;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$entity$ExperienceOrbMergeEvent
  extends $org$bukkit$event$Cancellable {
  getMergeTarget(): org$bukkit$entity$ExperienceOrb;
  getMergeSource(): org$bukkit$entity$ExperienceOrb;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$entity$ExperienceOrbMergeEvent
  implements $com$destroystokyo$paper$event$entity$ExperienceOrbMergeEvent {
  constructor(
    arg0: org$bukkit$entity$ExperienceOrb,
    arg1: org$bukkit$entity$ExperienceOrb
  );
  getMergeTarget(): org$bukkit$entity$ExperienceOrb;
  getMergeSource(): org$bukkit$entity$ExperienceOrb;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$entity$ExperienceOrb
  extends $org$bukkit$entity$Entity {
  getExperience(): number;
  setExperience(arg0: number): void;
  isFromBottle(): boolean;
  getTriggerEntityId(): any /* java.util.UUID */;
  getSourceEntityId(): any /* java.util.UUID */;
  getSpawnReason(): org$bukkit$entity$ExperienceOrb$SpawnReason;
}

declare class org$bukkit$entity$ExperienceOrb
  implements $org$bukkit$entity$ExperienceOrb {
  getExperience(): number;
  setExperience(arg0: number): void;
  isFromBottle(): boolean;
  getTriggerEntityId(): any /* java.util.UUID */;
  getSourceEntityId(): any /* java.util.UUID */;
  getSpawnReason(): org$bukkit$entity$ExperienceOrb$SpawnReason;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$ExperienceOrb$SpawnReason {}

declare class org$bukkit$entity$ExperienceOrb$SpawnReason
  implements $org$bukkit$entity$ExperienceOrb$SpawnReason {
  static PLAYER_DEATH: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static ENTITY_DEATH: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static FURNACE: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static BREED: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static VILLAGER_TRADE: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static FISHING: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static BLOCK_BREAK: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static CUSTOM: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static EXP_BOTTLE: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static GRINDSTONE: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static UNKNOWN: org$bukkit$entity$ExperienceOrb$SpawnReason;
  static values(): JavaArray<org$bukkit$entity$ExperienceOrb$SpawnReason>;
  static valueOf(arg0: string): org$bukkit$entity$ExperienceOrb$SpawnReason;
}


declare interface $com$destroystokyo$paper$event$entity$PhantomPreSpawnEvent {
  getSpawningEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$PhantomPreSpawnEvent
  implements $com$destroystokyo$paper$event$entity$PhantomPreSpawnEvent {
  constructor(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  );
  getSpawningEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$PlayerNaturallySpawnCreaturesEvent
  extends $org$bukkit$event$Cancellable {
  getSpawnRadius(): Buffer;
  setSpawnRadius(arg0: Buffer): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$entity$PlayerNaturallySpawnCreaturesEvent
  implements
    $com$destroystokyo$paper$event$entity$PlayerNaturallySpawnCreaturesEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: Buffer);
  getSpawnRadius(): Buffer;
  setSpawnRadius(arg0: Buffer): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$PreCreatureSpawnEvent
  extends $org$bukkit$event$Cancellable {
  getSpawnLocation(): org$bukkit$Location;
  getType(): org$bukkit$entity$EntityType;
  getReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  shouldAbortSpawn(): boolean;
  setShouldAbortSpawn(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$entity$PreCreatureSpawnEvent
  implements $com$destroystokyo$paper$event$entity$PreCreatureSpawnEvent {
  constructor(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType,
    arg2: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  );
  getSpawnLocation(): org$bukkit$Location;
  getType(): org$bukkit$entity$EntityType;
  getReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  shouldAbortSpawn(): boolean;
  setShouldAbortSpawn(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$PreSpawnerSpawnEvent {
  getSpawnerLocation(): org$bukkit$Location;
}

declare class com$destroystokyo$paper$event$entity$PreSpawnerSpawnEvent
  implements $com$destroystokyo$paper$event$entity$PreSpawnerSpawnEvent {
  constructor(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$entity$EntityType,
    arg2: org$bukkit$Location
  );
  getSpawnerLocation(): org$bukkit$Location;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$ProjectileCollideEvent
  extends $org$bukkit$event$Cancellable {
  getCollidedWith(): org$bukkit$entity$Entity;

  getEntity(): org$bukkit$entity$Projectile;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$ProjectileCollideEvent
  implements $com$destroystokyo$paper$event$entity$ProjectileCollideEvent {
  getCollidedWith(): org$bukkit$entity$Entity;
  constructor(
    arg0: org$bukkit$entity$Projectile,
    arg1: org$bukkit$entity$Entity
  );
  getEntity(): org$bukkit$entity$Projectile;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$SkeletonHorseTrapEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$SkeletonHorse;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$SkeletonHorseTrapEvent
  implements $com$destroystokyo$paper$event$entity$SkeletonHorseTrapEvent {
  constructor(arg0: org$bukkit$entity$SkeletonHorse);
  getEntity(): org$bukkit$entity$SkeletonHorse;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$SkeletonHorse
  extends $org$bukkit$entity$AbstractHorse {
  getTrapTime(): number;
  isTrap(): boolean;
  setTrap(arg0: boolean): void;
}

declare class org$bukkit$entity$SkeletonHorse
  implements $org$bukkit$entity$SkeletonHorse {
  getTrapTime(): number;
  isTrap(): boolean;
  setTrap(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$AbstractHorse
  extends $org$bukkit$entity$Vehicle,
    $org$bukkit$inventory$InventoryHolder,
    $org$bukkit$entity$Tameable {
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$entity$AbstractHorse
  implements $org$bukkit$entity$AbstractHorse {
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Animals
  extends $org$bukkit$entity$Ageable {
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
}

declare class org$bukkit$entity$Animals implements $org$bukkit$entity$Animals {
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Tameable
  extends $org$bukkit$entity$Animals {
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
}

declare class org$bukkit$entity$Tameable
  implements $org$bukkit$entity$Tameable {
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Vehicle extends $org$bukkit$entity$Entity {
  getVelocity(): org$bukkit$util$Vector;
  setVelocity(arg0: org$bukkit$util$Vector): void;
}

declare class org$bukkit$entity$Vehicle implements $org$bukkit$entity$Vehicle {
  getVelocity(): org$bukkit$util$Vector;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Horse$Variant {}

declare class org$bukkit$entity$Horse$Variant
  implements $org$bukkit$entity$Horse$Variant {
  static HORSE: org$bukkit$entity$Horse$Variant;
  static DONKEY: org$bukkit$entity$Horse$Variant;
  static MULE: org$bukkit$entity$Horse$Variant;
  static UNDEAD_HORSE: org$bukkit$entity$Horse$Variant;
  static SKELETON_HORSE: org$bukkit$entity$Horse$Variant;
  static LLAMA: org$bukkit$entity$Horse$Variant;
  static values(): JavaArray<org$bukkit$entity$Horse$Variant>;
  static valueOf(arg0: string): org$bukkit$entity$Horse$Variant;
}


declare interface $org$bukkit$inventory$AbstractHorseInventory
  extends $org$bukkit$inventory$Inventory {
  getSaddle(): org$bukkit$inventory$ItemStack;
  setSaddle(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$AbstractHorseInventory
  implements $org$bukkit$inventory$AbstractHorseInventory {
  getSaddle(): org$bukkit$inventory$ItemStack;
  setSaddle(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $com$destroystokyo$paper$event$entity$SlimeChangeDirectionEvent
  extends $org$bukkit$event$Cancellable {
  getNewYaw(): number;
  setNewYaw(arg0: number): void;
}

declare class com$destroystokyo$paper$event$entity$SlimeChangeDirectionEvent
  implements $com$destroystokyo$paper$event$entity$SlimeChangeDirectionEvent {
  constructor(arg0: org$bukkit$entity$Slime, arg1: number);
  getNewYaw(): number;
  setNewYaw(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$entity$Slime extends $org$bukkit$entity$Mob {
  getSize(): number;
  setSize(arg0: number): void;
  canWander(): boolean;
  setWander(arg0: boolean): void;
}

declare class org$bukkit$entity$Slime implements $org$bukkit$entity$Slime {
  getSize(): number;
  setSize(arg0: number): void;
  canWander(): boolean;
  setWander(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$event$entity$SlimePathfindEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Slime;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$SlimePathfindEvent
  implements $com$destroystokyo$paper$event$entity$SlimePathfindEvent {
  constructor(arg0: org$bukkit$entity$Slime);
  getEntity(): org$bukkit$entity$Slime;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$SlimeSwimEvent
  extends $org$bukkit$event$Cancellable {}

declare class com$destroystokyo$paper$event$entity$SlimeSwimEvent
  implements $com$destroystokyo$paper$event$entity$SlimeSwimEvent {
  constructor(arg0: org$bukkit$entity$Slime);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$SlimeTargetLivingEntityEvent
  extends $org$bukkit$event$Cancellable {
  getTarget(): org$bukkit$entity$LivingEntity;
}

declare class com$destroystokyo$paper$event$entity$SlimeTargetLivingEntityEvent
  implements
    $com$destroystokyo$paper$event$entity$SlimeTargetLivingEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Slime,
    arg1: org$bukkit$entity$LivingEntity
  );
  getTarget(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$SlimeWanderEvent
  extends $org$bukkit$event$Cancellable {}

declare class com$destroystokyo$paper$event$entity$SlimeWanderEvent
  implements $com$destroystokyo$paper$event$entity$SlimeWanderEvent {
  constructor(arg0: org$bukkit$entity$Slime);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$entity$ThrownEggHatchEvent {
  getEgg(): org$bukkit$entity$Egg;
  isHatching(): boolean;
  setHatching(arg0: boolean): void;
  getHatchingType(): org$bukkit$entity$EntityType;
  setHatchingType(arg0: org$bukkit$entity$EntityType): void;
  getNumHatches(): Buffer;
  setNumHatches(arg0: Buffer): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$entity$ThrownEggHatchEvent
  implements $com$destroystokyo$paper$event$entity$ThrownEggHatchEvent {
  constructor(
    arg0: org$bukkit$entity$Egg,
    arg1: boolean,
    arg2: Buffer,
    arg3: org$bukkit$entity$EntityType
  );
  getEgg(): org$bukkit$entity$Egg;
  isHatching(): boolean;
  setHatching(arg0: boolean): void;
  getHatchingType(): org$bukkit$entity$EntityType;
  setHatchingType(arg0: org$bukkit$entity$EntityType): void;
  getNumHatches(): Buffer;
  setNumHatches(arg0: Buffer): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$entity$Egg
  extends $org$bukkit$entity$ThrowableProjectile {}

declare class org$bukkit$entity$Egg implements $org$bukkit$entity$Egg {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$ThrowableProjectile
  extends $org$bukkit$entity$Projectile {
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$entity$ThrowableProjectile
  implements $org$bukkit$entity$ThrowableProjectile {
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $com$destroystokyo$paper$event$entity$TurtleGoHomeEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Turtle;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$TurtleGoHomeEvent
  implements $com$destroystokyo$paper$event$entity$TurtleGoHomeEvent {
  constructor(arg0: org$bukkit$entity$Turtle);
  getEntity(): org$bukkit$entity$Turtle;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$Turtle extends $org$bukkit$entity$Animals {
  getHome(): org$bukkit$Location;
  setHome(arg0: org$bukkit$Location): void;
  isGoingHome(): boolean;
  isDigging(): boolean;
  hasEgg(): boolean;
  setHasEgg(arg0: boolean): void;
}

declare class org$bukkit$entity$Turtle implements $org$bukkit$entity$Turtle {
  getHome(): org$bukkit$Location;
  setHome(arg0: org$bukkit$Location): void;
  isGoingHome(): boolean;
  isDigging(): boolean;
  hasEgg(): boolean;
  setHasEgg(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$event$entity$TurtleLayEggEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Turtle;
  getLocation(): org$bukkit$Location;
  getEggCount(): number;
  setEggCount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$TurtleLayEggEvent
  implements $com$destroystokyo$paper$event$entity$TurtleLayEggEvent {
  constructor(
    arg0: org$bukkit$entity$Turtle,
    arg1: org$bukkit$Location,
    arg2: number
  );
  getEntity(): org$bukkit$entity$Turtle;
  getLocation(): org$bukkit$Location;
  getEggCount(): number;
  setEggCount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$TurtleStartDiggingEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Turtle;
  getLocation(): org$bukkit$Location;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$TurtleStartDiggingEvent
  implements $com$destroystokyo$paper$event$entity$TurtleStartDiggingEvent {
  constructor(arg0: org$bukkit$entity$Turtle, arg1: org$bukkit$Location);
  getEntity(): org$bukkit$entity$Turtle;
  getLocation(): org$bukkit$Location;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$WitchConsumePotionEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Witch;
  getPotion(): org$bukkit$inventory$ItemStack;
  setPotion(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$WitchConsumePotionEvent
  implements $com$destroystokyo$paper$event$entity$WitchConsumePotionEvent {
  constructor(
    arg0: org$bukkit$entity$Witch,
    arg1: org$bukkit$inventory$ItemStack
  );
  getEntity(): org$bukkit$entity$Witch;
  getPotion(): org$bukkit$inventory$ItemStack;
  setPotion(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$entity$Witch
  extends $org$bukkit$entity$Raider,
    $com$destroystokyo$paper$entity$RangedEntity {
  isDrinkingPotion(): boolean;
  getPotionUseTimeLeft(): number;
  getDrinkingPotion(): org$bukkit$inventory$ItemStack;
  setDrinkingPotion(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$entity$Witch implements $org$bukkit$entity$Witch {
  isDrinkingPotion(): boolean;
  getPotionUseTimeLeft(): number;
  getDrinkingPotion(): org$bukkit$inventory$ItemStack;
  setDrinkingPotion(arg0: org$bukkit$inventory$ItemStack): void;
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Raider extends $org$bukkit$entity$Monster {
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
}

declare class org$bukkit$entity$Raider implements $org$bukkit$entity$Raider {
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $com$destroystokyo$paper$event$entity$WitchReadyPotionEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Witch;
  getPotion(): org$bukkit$inventory$ItemStack;
  setPotion(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$WitchReadyPotionEvent
  implements $com$destroystokyo$paper$event$entity$WitchReadyPotionEvent {
  constructor(
    arg0: org$bukkit$entity$Witch,
    arg1: org$bukkit$inventory$ItemStack
  );
  static process(
    arg0: org$bukkit$entity$Witch,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  getEntity(): org$bukkit$entity$Witch;
  getPotion(): org$bukkit$inventory$ItemStack;
  setPotion(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$entity$WitchThrowPotionEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Witch;
  getTarget(): org$bukkit$entity$LivingEntity;
  getPotion(): org$bukkit$inventory$ItemStack;
  setPotion(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$entity$WitchThrowPotionEvent
  implements $com$destroystokyo$paper$event$entity$WitchThrowPotionEvent {
  constructor(
    arg0: org$bukkit$entity$Witch,
    arg1: org$bukkit$entity$LivingEntity,
    arg2: org$bukkit$inventory$ItemStack
  );
  getEntity(): org$bukkit$entity$Witch;
  getTarget(): org$bukkit$entity$LivingEntity;
  getPotion(): org$bukkit$inventory$ItemStack;
  setPotion(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$executor$asm$ASMEventExecutorGenerator {}

declare class com$destroystokyo$paper$event$executor$asm$ASMEventExecutorGenerator
  implements
    $com$destroystokyo$paper$event$executor$asm$ASMEventExecutorGenerator {
  static NEXT_ID: any; /* java.util.concurrent.atomic.AtomicInteger */
  constructor();
  static generateEventExecutor(
    arg0: any /* java.lang.reflect.Method */,
    arg1: string
  ): JavaArray<Buffer>;
  static generateName(): string;
}


declare interface $com$destroystokyo$paper$event$executor$asm$ClassDefiner {
  isBypassAccessChecks(): boolean;
  defineClass(
    arg0: any /* java.lang.ClassLoader */,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): any /* java.lang.Class */;
}

declare class com$destroystokyo$paper$event$executor$asm$ClassDefiner
  implements $com$destroystokyo$paper$event$executor$asm$ClassDefiner {
  isBypassAccessChecks(): boolean;
  defineClass(
    arg0: any /* java.lang.ClassLoader */,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): any /* java.lang.Class */;
  static getInstance(): com$destroystokyo$paper$event$executor$asm$ClassDefiner;
}


declare interface $com$destroystokyo$paper$event$executor$asm$SafeClassDefiner
  extends $com$destroystokyo$paper$event$executor$asm$ClassDefiner {
  defineClass(
    arg0: any /* java.lang.ClassLoader */,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): any /* java.lang.Class */;
}

declare class com$destroystokyo$paper$event$executor$asm$SafeClassDefiner
  implements $com$destroystokyo$paper$event$executor$asm$SafeClassDefiner {
  defineClass(
    arg0: any /* java.lang.ClassLoader */,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): any /* java.lang.Class */;
  isBypassAccessChecks(): boolean;
  static getInstance(): com$destroystokyo$paper$event$executor$asm$ClassDefiner;
}


declare interface $com$destroystokyo$paper$event$executor$asm$SafeClassDefiner$GeneratedClassLoader {
  getClassLoadingLock(arg0: string): any;
  hasClass(arg0: string): boolean;
}

declare class com$destroystokyo$paper$event$executor$asm$SafeClassDefiner$GeneratedClassLoader
  implements
    $com$destroystokyo$paper$event$executor$asm$SafeClassDefiner$GeneratedClassLoader {
  constructor(arg0: any /* java.lang.ClassLoader */);
  getClassLoadingLock(arg0: string): any;
  hasClass(arg0: string): boolean;
  static access$000(
    arg0: com$destroystokyo$paper$event$executor$asm$SafeClassDefiner$GeneratedClassLoader,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): any /* java.lang.Class */;
}


declare interface $com$destroystokyo$paper$event$executor$MethodHandleEventExecutor
  extends $org$bukkit$plugin$EventExecutor {
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
}

declare class com$destroystokyo$paper$event$executor$MethodHandleEventExecutor
  implements $com$destroystokyo$paper$event$executor$MethodHandleEventExecutor {
  constructor(
    arg0: any /* java.lang.Class */,
    arg1: any /* java.lang.invoke.MethodHandle */
  );
  constructor(
    arg0: any /* java.lang.Class */,
    arg1: any /* java.lang.reflect.Method */
  );
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
  static eventExecutorMap: any; /* java.util.concurrent.ConcurrentMap */
  static create(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.lang.Class */
  ): org$bukkit$plugin$EventExecutor;
}


declare interface $com$destroystokyo$paper$event$executor$StaticMethodHandleEventExecutor
  extends $org$bukkit$plugin$EventExecutor {
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
}

declare class com$destroystokyo$paper$event$executor$StaticMethodHandleEventExecutor
  implements
    $com$destroystokyo$paper$event$executor$StaticMethodHandleEventExecutor {
  constructor(
    arg0: any /* java.lang.Class */,
    arg1: any /* java.lang.reflect.Method */
  );
  execute(arg0: org$bukkit$event$Listener, arg1: org$bukkit$event$Event): void;
  static eventExecutorMap: any; /* java.util.concurrent.ConcurrentMap */
  static create(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.lang.Class */
  ): org$bukkit$plugin$EventExecutor;
}


declare interface $com$destroystokyo$paper$event$inventory$PrepareGrindstoneEvent {
  getInventory(): org$bukkit$inventory$GrindstoneInventory;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class com$destroystokyo$paper$event$inventory$PrepareGrindstoneEvent
  implements $com$destroystokyo$paper$event$inventory$PrepareGrindstoneEvent {
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$inventory$ItemStack
  );
  getInventory(): org$bukkit$inventory$GrindstoneInventory;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}


declare interface $org$bukkit$inventory$GrindstoneInventory
  extends $org$bukkit$inventory$Inventory {
  getUpperItem(): org$bukkit$inventory$ItemStack;
  setUpperItem(arg0: org$bukkit$inventory$ItemStack): void;
  getLowerItem(): org$bukkit$inventory$ItemStack;
  setLowerItem(arg0: org$bukkit$inventory$ItemStack): void;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$GrindstoneInventory
  implements $org$bukkit$inventory$GrindstoneInventory {
  getUpperItem(): org$bukkit$inventory$ItemStack;
  setUpperItem(arg0: org$bukkit$inventory$ItemStack): void;
  getLowerItem(): org$bukkit$inventory$ItemStack;
  setLowerItem(arg0: org$bukkit$inventory$ItemStack): void;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $com$destroystokyo$paper$event$player$IllegalPacketEvent {
  isShouldKick(): boolean;
  setShouldKick(arg0: boolean): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  getType(): string;
  getExceptionMessage(): string;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$IllegalPacketEvent
  implements $com$destroystokyo$paper$event$player$IllegalPacketEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: string,
    arg3: any /* java.lang.Exception */
  );
  isShouldKick(): boolean;
  setShouldKick(arg0: boolean): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  getType(): string;
  getExceptionMessage(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  static process(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: string,
    arg3: any /* java.lang.Exception */
  ): void;
}


declare interface $com$destroystokyo$paper$event$player$PlayerAdvancementCriterionGrantEvent
  extends $org$bukkit$event$Cancellable {
  getAdvancement(): org$bukkit$advancement$Advancement;
  getCriterion(): string;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerAdvancementCriterionGrantEvent
  implements
    $com$destroystokyo$paper$event$player$PlayerAdvancementCriterionGrantEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$advancement$Advancement,
    arg2: string
  );
  getAdvancement(): org$bukkit$advancement$Advancement;
  getCriterion(): string;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerArmorChangeEvent {
  getSlotType(): com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  getOldItem(): org$bukkit$inventory$ItemStack;
  getNewItem(): org$bukkit$inventory$ItemStack;
  toString(): string;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerArmorChangeEvent
  implements $com$destroystokyo$paper$event$player$PlayerArmorChangeEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$inventory$ItemStack
  );
  getSlotType(): com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  getOldItem(): org$bukkit$inventory$ItemStack;
  getNewItem(): org$bukkit$inventory$ItemStack;
  toString(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType {
  getTypes(): any /* java.util.Set */;
}

declare class com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType
  implements
    $com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType {
  static HEAD: com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  static CHEST: com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  static LEGS: com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  static FEET: com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  static values(): JavaArray<
    com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  getTypes(): any /* java.util.Set */;
  static getByMaterial(
    arg0: org$bukkit$Material
  ): com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  static isEquipable(arg0: org$bukkit$Material): boolean;
}


declare interface $com$destroystokyo$paper$event$player$PlayerAttackEntityCooldownResetEvent
  extends $org$bukkit$event$Cancellable {
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getCooledAttackStrength(): number;
  getAttackedEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$event$player$PlayerAttackEntityCooldownResetEvent
  implements
    $com$destroystokyo$paper$event$player$PlayerAttackEntityCooldownResetEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: number
  );
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getCooledAttackStrength(): number;
  getAttackedEntity(): org$bukkit$entity$Entity;
}


declare interface $com$destroystokyo$paper$event$player$PlayerClientOptionsChangeEvent {
  getLocale(): string;
  hasLocaleChanged(): boolean;
  getViewDistance(): number;
  hasViewDistanceChanged(): boolean;
  getChatVisibility(): com$destroystokyo$paper$ClientOption$ChatVisibility;
  hasChatVisibilityChanged(): boolean;
  hasChatColorsEnabled(): boolean;
  hasChatColorsEnabledChanged(): boolean;
  getSkinParts(): com$destroystokyo$paper$SkinParts;
  hasSkinPartsChanged(): boolean;
  getMainHand(): org$bukkit$inventory$MainHand;
  hasMainHandChanged(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerClientOptionsChangeEvent
  implements
    $com$destroystokyo$paper$event$player$PlayerClientOptionsChangeEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: number,
    arg3: com$destroystokyo$paper$ClientOption$ChatVisibility,
    arg4: boolean,
    arg5: com$destroystokyo$paper$SkinParts,
    arg6: org$bukkit$inventory$MainHand
  );
  getLocale(): string;
  hasLocaleChanged(): boolean;
  getViewDistance(): number;
  hasViewDistanceChanged(): boolean;
  getChatVisibility(): com$destroystokyo$paper$ClientOption$ChatVisibility;
  hasChatVisibilityChanged(): boolean;
  hasChatColorsEnabled(): boolean;
  hasChatColorsEnabledChanged(): boolean;
  getSkinParts(): com$destroystokyo$paper$SkinParts;
  hasSkinPartsChanged(): boolean;
  getMainHand(): org$bukkit$inventory$MainHand;
  hasMainHandChanged(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$SkinParts {
  hasCapeEnabled(): boolean;
  hasJacketEnabled(): boolean;
  hasLeftSleeveEnabled(): boolean;
  hasRightSleeveEnabled(): boolean;
  hasLeftPantsEnabled(): boolean;
  hasRightPantsEnabled(): boolean;
  hasHatsEnabled(): boolean;
  getRaw(): number;
}

declare class com$destroystokyo$paper$SkinParts
  implements $com$destroystokyo$paper$SkinParts {
  hasCapeEnabled(): boolean;
  hasJacketEnabled(): boolean;
  hasLeftSleeveEnabled(): boolean;
  hasRightSleeveEnabled(): boolean;
  hasLeftPantsEnabled(): boolean;
  hasRightPantsEnabled(): boolean;
  hasHatsEnabled(): boolean;
  getRaw(): number;
}


declare interface $com$destroystokyo$paper$event$player$PlayerConnectionCloseEvent {
  getPlayerUniqueId(): any /* java.util.UUID */;
  getPlayerName(): string;
  getIpAddress(): any /* java.net.InetAddress */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerConnectionCloseEvent
  implements $com$destroystokyo$paper$event$player$PlayerConnectionCloseEvent {
  constructor(
    arg0: any /* java.util.UUID */,
    arg1: string,
    arg2: any /* java.net.InetAddress */,
    arg3: boolean
  );
  getPlayerUniqueId(): any /* java.util.UUID */;
  getPlayerName(): string;
  getIpAddress(): any /* java.net.InetAddress */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerElytraBoostEvent
  extends $org$bukkit$event$Cancellable {
  getItemStack(): org$bukkit$inventory$ItemStack;
  getFirework(): org$bukkit$entity$Firework;
  shouldConsume(): boolean;
  setShouldConsume(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$player$PlayerElytraBoostEvent
  implements $com$destroystokyo$paper$event$player$PlayerElytraBoostEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$entity$Firework
  );
  getItemStack(): org$bukkit$inventory$ItemStack;
  getFirework(): org$bukkit$entity$Firework;
  shouldConsume(): boolean;
  setShouldConsume(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$entity$Firework
  extends $org$bukkit$entity$Entity {
  getFireworkMeta(): org$bukkit$inventory$meta$FireworkMeta;
  setFireworkMeta(arg0: org$bukkit$inventory$meta$FireworkMeta): void;
  detonate(): void;
  isShotAtAngle(): boolean;
  setShotAtAngle(arg0: boolean): void;
  getSpawningEntity(): any /* java.util.UUID */;
  getBoostedEntity(): org$bukkit$entity$LivingEntity;
}

declare class org$bukkit$entity$Firework
  implements $org$bukkit$entity$Firework {
  getFireworkMeta(): org$bukkit$inventory$meta$FireworkMeta;
  setFireworkMeta(arg0: org$bukkit$inventory$meta$FireworkMeta): void;
  detonate(): void;
  isShotAtAngle(): boolean;
  setShotAtAngle(arg0: boolean): void;
  getSpawningEntity(): any /* java.util.UUID */;
  getBoostedEntity(): org$bukkit$entity$LivingEntity;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$FireworkMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  addEffect(arg0: org$bukkit$FireworkEffect): void;
  addEffects(arg0: JavaArray<org$bukkit$FireworkEffect>): void;
  addEffects(arg0: any /* java.lang.Iterable */): void;
  getEffects(): any /* java.util.List */;
  getEffectsSize(): number;
  removeEffect(arg0: number): void;
  clearEffects(): void;
  hasEffects(): boolean;
  getPower(): number;
  setPower(arg0: number): void;
  clone(): org$bukkit$inventory$meta$FireworkMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$FireworkMeta
  implements $org$bukkit$inventory$meta$FireworkMeta {
  addEffect(arg0: org$bukkit$FireworkEffect): void;
  addEffects(arg0: JavaArray<org$bukkit$FireworkEffect>): void;
  addEffects(arg0: any /* java.lang.Iterable */): void;
  getEffects(): any /* java.util.List */;
  getEffectsSize(): number;
  removeEffect(arg0: number): void;
  clearEffects(): void;
  hasEffects(): boolean;
  getPower(): number;
  setPower(arg0: number): void;
  clone(): org$bukkit$inventory$meta$FireworkMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$FireworkEffect
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  hasFlicker(): boolean;
  hasTrail(): boolean;
  getColors(): any /* java.util.List */;
  getFadeColors(): any /* java.util.List */;
  getType(): org$bukkit$FireworkEffect$Type;
  serialize(): any /* java.util.Map */;
  toString(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
}

declare class org$bukkit$FireworkEffect implements $org$bukkit$FireworkEffect {
  static builder(): org$bukkit$FireworkEffect$Builder;
  constructor(
    arg0: boolean,
    arg1: boolean,
    arg2: com$google$common$collect$ImmutableList,
    arg3: com$google$common$collect$ImmutableList,
    arg4: org$bukkit$FireworkEffect$Type
  );
  hasFlicker(): boolean;
  hasTrail(): boolean;
  getColors(): any /* java.util.List */;
  getFadeColors(): any /* java.util.List */;
  getType(): org$bukkit$FireworkEffect$Type;
  static deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  serialize(): any /* java.util.Map */;
  toString(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
}


declare interface $org$bukkit$FireworkEffect$Builder {
  with(arg0: org$bukkit$FireworkEffect$Type): org$bukkit$FireworkEffect$Builder;
  withFlicker(): org$bukkit$FireworkEffect$Builder;
  flicker(arg0: boolean): org$bukkit$FireworkEffect$Builder;
  withTrail(): org$bukkit$FireworkEffect$Builder;
  trail(arg0: boolean): org$bukkit$FireworkEffect$Builder;
  withColor(arg0: org$bukkit$Color): org$bukkit$FireworkEffect$Builder;
  withColor(
    arg0: JavaArray<org$bukkit$Color>
  ): org$bukkit$FireworkEffect$Builder;
  withColor(
    arg0: any /* java.lang.Iterable */
  ): org$bukkit$FireworkEffect$Builder;
  withFade(arg0: org$bukkit$Color): org$bukkit$FireworkEffect$Builder;
  withFade(
    arg0: JavaArray<org$bukkit$Color>
  ): org$bukkit$FireworkEffect$Builder;
  withFade(
    arg0: any /* java.lang.Iterable */
  ): org$bukkit$FireworkEffect$Builder;
  build(): org$bukkit$FireworkEffect;
}

declare class org$bukkit$FireworkEffect$Builder
  implements $org$bukkit$FireworkEffect$Builder {
  constructor();
  with(arg0: org$bukkit$FireworkEffect$Type): org$bukkit$FireworkEffect$Builder;
  withFlicker(): org$bukkit$FireworkEffect$Builder;
  flicker(arg0: boolean): org$bukkit$FireworkEffect$Builder;
  withTrail(): org$bukkit$FireworkEffect$Builder;
  trail(arg0: boolean): org$bukkit$FireworkEffect$Builder;
  withColor(arg0: org$bukkit$Color): org$bukkit$FireworkEffect$Builder;
  withColor(
    arg0: JavaArray<org$bukkit$Color>
  ): org$bukkit$FireworkEffect$Builder;
  withColor(
    arg0: any /* java.lang.Iterable */
  ): org$bukkit$FireworkEffect$Builder;
  withFade(arg0: org$bukkit$Color): org$bukkit$FireworkEffect$Builder;
  withFade(
    arg0: JavaArray<org$bukkit$Color>
  ): org$bukkit$FireworkEffect$Builder;
  withFade(
    arg0: any /* java.lang.Iterable */
  ): org$bukkit$FireworkEffect$Builder;
  build(): org$bukkit$FireworkEffect;
}


declare interface $org$bukkit$FireworkEffect$Type {}

declare class org$bukkit$FireworkEffect$Type
  implements $org$bukkit$FireworkEffect$Type {
  static BALL: org$bukkit$FireworkEffect$Type;
  static BALL_LARGE: org$bukkit$FireworkEffect$Type;
  static STAR: org$bukkit$FireworkEffect$Type;
  static BURST: org$bukkit$FireworkEffect$Type;
  static CREEPER: org$bukkit$FireworkEffect$Type;
  static values(): JavaArray<org$bukkit$FireworkEffect$Type>;
  static valueOf(arg0: string): org$bukkit$FireworkEffect$Type;
}


declare interface $com$google$common$collect$ImmutableList$Builder {
  add(arg0: any): com$google$common$collect$ImmutableList$Builder;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableList$Builder;
  add(arg0: JavaArray<any>): com$google$common$collect$ImmutableList$Builder;
  addAll(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableList$Builder;
  build(): com$google$common$collect$ImmutableList;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(
    arg0: any
  ): com$google$common$collect$ImmutableCollection$ArrayBasedBuilder;
  build(): com$google$common$collect$ImmutableCollection;
  addAll(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(arg0: any): com$google$common$collect$ImmutableCollection$Builder;
}

declare class com$google$common$collect$ImmutableList$Builder
  implements $com$google$common$collect$ImmutableList$Builder {
  constructor();
  constructor(arg0: number);
  add(arg0: any): com$google$common$collect$ImmutableList$Builder;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableList$Builder;
  add(arg0: JavaArray<any>): com$google$common$collect$ImmutableList$Builder;
  addAll(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableList$Builder;
  build(): com$google$common$collect$ImmutableList;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(
    arg0: any
  ): com$google$common$collect$ImmutableCollection$ArrayBasedBuilder;
  build(): com$google$common$collect$ImmutableCollection;
  addAll(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(arg0: any): com$google$common$collect$ImmutableCollection$Builder;
}


declare interface $com$google$common$collect$ImmutableList {
  iterator(): com$google$common$collect$UnmodifiableIterator;
  listIterator(): com$google$common$collect$UnmodifiableListIterator;
  listIterator(
    arg0: number
  ): com$google$common$collect$UnmodifiableListIterator;
  indexOf(arg0: any): number;
  lastIndexOf(arg0: any): number;
  contains(arg0: any): boolean;
  subList(arg0: number, arg1: number): com$google$common$collect$ImmutableList;
  subListUnchecked(
    arg0: number,
    arg1: number
  ): com$google$common$collect$ImmutableList;
  addAll(arg0: number, arg1: java$util$Collection): boolean;
  set(arg0: number, arg1: any): any;
  add(arg0: number, arg1: any): void;
  remove(arg0: number): any;
  asList(): com$google$common$collect$ImmutableList;
  copyIntoArray(arg0: JavaArray<any>, arg1: number): number;
  reverse(): com$google$common$collect$ImmutableList;
  equals(arg0: any): boolean;
  hashCode(): number;
  writeReplace(): any;
  iterator(): any /* java.util.Iterator */;
  subList(arg0: number, arg1: number): any /* java.util.List */;
  listIterator(arg0: number): any /* java.util.ListIterator */;
  listIterator(): any /* java.util.ListIterator */;
}

declare class com$google$common$collect$ImmutableList
  implements $com$google$common$collect$ImmutableList {
  static of(): com$google$common$collect$ImmutableList;
  static of(arg0: any): com$google$common$collect$ImmutableList;
  static of(arg0: any, arg1: any): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any,
    arg6: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any,
    arg6: any,
    arg7: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any,
    arg6: any,
    arg7: any,
    arg8: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any,
    arg6: any,
    arg7: any,
    arg8: any,
    arg9: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any,
    arg6: any,
    arg7: any,
    arg8: any,
    arg9: any,
    arg10: any
  ): com$google$common$collect$ImmutableList;
  static of(
    arg0: any,
    arg1: any,
    arg2: any,
    arg3: any,
    arg4: any,
    arg5: any,
    arg6: any,
    arg7: any,
    arg8: any,
    arg9: any,
    arg10: any,
    arg11: any,
    arg12: JavaArray<any>
  ): com$google$common$collect$ImmutableList;
  static copyOf(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableList;
  static copyOf(
    arg0: java$util$Collection
  ): com$google$common$collect$ImmutableList;
  static copyOf(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableList;
  static copyOf(arg0: JavaArray<any>): com$google$common$collect$ImmutableList;
  static asImmutableList(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableList;
  static asImmutableList(
    arg0: JavaArray<any>,
    arg1: number
  ): com$google$common$collect$ImmutableList;
  constructor();
  iterator(): com$google$common$collect$UnmodifiableIterator;
  listIterator(): com$google$common$collect$UnmodifiableListIterator;
  listIterator(
    arg0: number
  ): com$google$common$collect$UnmodifiableListIterator;
  indexOf(arg0: any): number;
  lastIndexOf(arg0: any): number;
  contains(arg0: any): boolean;
  subList(arg0: number, arg1: number): com$google$common$collect$ImmutableList;
  subListUnchecked(
    arg0: number,
    arg1: number
  ): com$google$common$collect$ImmutableList;
  addAll(arg0: number, arg1: java$util$Collection): boolean;
  set(arg0: number, arg1: any): any;
  add(arg0: number, arg1: any): void;
  remove(arg0: number): any;
  asList(): com$google$common$collect$ImmutableList;
  copyIntoArray(arg0: JavaArray<any>, arg1: number): number;
  reverse(): com$google$common$collect$ImmutableList;
  equals(arg0: any): boolean;
  hashCode(): number;
  writeReplace(): any;
  static builder(): com$google$common$collect$ImmutableList$Builder;
  iterator(): any /* java.util.Iterator */;
  subList(arg0: number, arg1: number): any /* java.util.List */;
  listIterator(arg0: number): any /* java.util.ListIterator */;
  listIterator(): any /* java.util.ListIterator */;
  size(): number;
  isEmpty(): boolean;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  addAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}


declare interface $com$google$common$collect$UnmodifiableIterator {
  remove(): void;
}

declare class com$google$common$collect$UnmodifiableIterator
  implements $com$google$common$collect$UnmodifiableIterator {
  constructor();
  remove(): void;
}


declare interface $com$google$common$collect$UnmodifiableListIterator {
  add(arg0: any): void;
  set(arg0: any): void;
}

declare class com$google$common$collect$UnmodifiableListIterator
  implements $com$google$common$collect$UnmodifiableListIterator {
  constructor();
  add(arg0: any): void;
  set(arg0: any): void;
}


declare interface $com$google$common$collect$ImmutableCollection$Builder {
  add(arg0: any): com$google$common$collect$ImmutableCollection$Builder;
  add(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableCollection$Builder;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableCollection$Builder;
  addAll(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableCollection$Builder;
  build(): com$google$common$collect$ImmutableCollection;
}

declare class com$google$common$collect$ImmutableCollection$Builder
  implements $com$google$common$collect$ImmutableCollection$Builder {
  static expandedCapacity(arg0: number, arg1: number): number;
  constructor();
  add(arg0: any): com$google$common$collect$ImmutableCollection$Builder;
  add(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableCollection$Builder;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableCollection$Builder;
  addAll(
    arg0: any /* java.util.Iterator */
  ): com$google$common$collect$ImmutableCollection$Builder;
  build(): com$google$common$collect$ImmutableCollection;
}


declare interface $com$google$common$collect$ImmutableCollection {
  iterator(): com$google$common$collect$UnmodifiableIterator;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  contains(arg0: any): boolean;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  addAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  asList(): com$google$common$collect$ImmutableList;
  isPartialView(): boolean;
  copyIntoArray(arg0: JavaArray<any>, arg1: number): number;
  writeReplace(): any;
  iterator(): any /* java.util.Iterator */;
}

declare class com$google$common$collect$ImmutableCollection
  implements $com$google$common$collect$ImmutableCollection {
  constructor();
  iterator(): com$google$common$collect$UnmodifiableIterator;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  contains(arg0: any): boolean;
  add(arg0: any): boolean;
  remove(arg0: any): boolean;
  addAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  asList(): com$google$common$collect$ImmutableList;
  isPartialView(): boolean;
  copyIntoArray(arg0: JavaArray<any>, arg1: number): number;
  writeReplace(): any;
  iterator(): any /* java.util.Iterator */;
  size(): number;
  isEmpty(): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  equals(arg0: any): boolean;
  hashCode(): number;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}


declare interface $com$google$common$collect$ImmutableCollection$ArrayBasedBuilder {
  add(
    arg0: any
  ): com$google$common$collect$ImmutableCollection$ArrayBasedBuilder;
  add(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableCollection$Builder;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(arg0: any): com$google$common$collect$ImmutableCollection$Builder;
}

declare class com$google$common$collect$ImmutableCollection$ArrayBasedBuilder
  implements $com$google$common$collect$ImmutableCollection$ArrayBasedBuilder {
  constructor(arg0: number);
  add(
    arg0: any
  ): com$google$common$collect$ImmutableCollection$ArrayBasedBuilder;
  add(
    arg0: JavaArray<any>
  ): com$google$common$collect$ImmutableCollection$Builder;
  addAll(
    arg0: any /* java.lang.Iterable */
  ): com$google$common$collect$ImmutableCollection$Builder;
  add(arg0: any): com$google$common$collect$ImmutableCollection$Builder;
}


declare interface $com$destroystokyo$paper$event$player$PlayerHandshakeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getOriginalHandshake(): string;
  getServerHostname(): string;
  setServerHostname(arg0: string): void;
  getSocketAddressHostname(): string;
  setSocketAddressHostname(arg0: string): void;
  getUniqueId(): any /* java.util.UUID */;
  setUniqueId(arg0: any /* java.util.UUID */): void;
  getPropertiesJson(): string;
  isFailed(): boolean;
  setFailed(arg0: boolean): void;
  setPropertiesJson(arg0: string): void;
  getFailMessage(): string;
  setFailMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerHandshakeEvent
  implements $com$destroystokyo$paper$event$player$PlayerHandshakeEvent {
  constructor(arg0: string, arg1: boolean);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getOriginalHandshake(): string;
  getServerHostname(): string;
  setServerHostname(arg0: string): void;
  getSocketAddressHostname(): string;
  setSocketAddressHostname(arg0: string): void;
  getUniqueId(): any /* java.util.UUID */;
  setUniqueId(arg0: any /* java.util.UUID */): void;
  getPropertiesJson(): string;
  isFailed(): boolean;
  setFailed(arg0: boolean): void;
  setPropertiesJson(arg0: string): void;
  getFailMessage(): string;
  setFailMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerInitialSpawnEvent {}

declare class com$destroystokyo$paper$event$player$PlayerInitialSpawnEvent
  implements $com$destroystokyo$paper$event$player$PlayerInitialSpawnEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$Location);
}


declare interface $com$destroystokyo$paper$event$player$PlayerJumpEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getFrom(): org$bukkit$Location;
  setFrom(arg0: org$bukkit$Location): void;
  getTo(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerJumpEvent
  implements $com$destroystokyo$paper$event$player$PlayerJumpEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getFrom(): org$bukkit$Location;
  setFrom(arg0: org$bukkit$Location): void;
  getTo(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerLaunchProjectileEvent
  extends $org$bukkit$event$Cancellable {
  getProjectile(): org$bukkit$entity$Projectile;
  getItemStack(): org$bukkit$inventory$ItemStack;
  shouldConsume(): boolean;
  setShouldConsume(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerLaunchProjectileEvent
  implements $com$destroystokyo$paper$event$player$PlayerLaunchProjectileEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$entity$Projectile
  );
  getProjectile(): org$bukkit$entity$Projectile;
  getItemStack(): org$bukkit$inventory$ItemStack;
  shouldConsume(): boolean;
  setShouldConsume(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerLocaleChangeEvent {
  getOldLocale(): string;
  getNewLocale(): string;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerLocaleChangeEvent
  implements $com$destroystokyo$paper$event$player$PlayerLocaleChangeEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string, arg2: string);
  getOldLocale(): string;
  getNewLocale(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerPickupExperienceEvent
  extends $org$bukkit$event$Cancellable {
  getExperienceOrb(): org$bukkit$entity$ExperienceOrb;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$player$PlayerPickupExperienceEvent
  implements $com$destroystokyo$paper$event$player$PlayerPickupExperienceEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$ExperienceOrb
  );
  getExperienceOrb(): org$bukkit$entity$ExperienceOrb;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$player$PlayerPostRespawnEvent {
  getRespawnedLocation(): org$bukkit$Location;
  isBedSpawn(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerPostRespawnEvent
  implements $com$destroystokyo$paper$event$player$PlayerPostRespawnEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: boolean
  );
  getRespawnedLocation(): org$bukkit$Location;
  isBedSpawn(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerReadyArrowEvent
  extends $org$bukkit$event$Cancellable {
  getBow(): org$bukkit$inventory$ItemStack;
  getArrow(): org$bukkit$inventory$ItemStack;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$event$player$PlayerReadyArrowEvent
  implements $com$destroystokyo$paper$event$player$PlayerReadyArrowEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$ItemStack
  );
  getBow(): org$bukkit$inventory$ItemStack;
  getArrow(): org$bukkit$inventory$ItemStack;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$player$PlayerRecipeBookClickEvent
  extends $org$bukkit$event$Cancellable {
  getRecipe(): org$bukkit$NamespacedKey;
  setRecipe(arg0: org$bukkit$NamespacedKey): void;
  isMakeAll(): boolean;
  setMakeAll(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerRecipeBookClickEvent
  implements $com$destroystokyo$paper$event$player$PlayerRecipeBookClickEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$NamespacedKey,
    arg2: boolean
  );
  getRecipe(): org$bukkit$NamespacedKey;
  setRecipe(arg0: org$bukkit$NamespacedKey): void;
  isMakeAll(): boolean;
  setMakeAll(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerStartSpectatingEntityEvent
  extends $org$bukkit$event$Cancellable {
  getCurrentSpectatorTarget(): org$bukkit$entity$Entity;
  getNewSpectatorTarget(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerStartSpectatingEntityEvent
  implements
    $com$destroystokyo$paper$event$player$PlayerStartSpectatingEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$entity$Entity
  );
  getCurrentSpectatorTarget(): org$bukkit$entity$Entity;
  getNewSpectatorTarget(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerStopSpectatingEntityEvent
  extends $org$bukkit$event$Cancellable {
  getSpectatorTarget(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerStopSpectatingEntityEvent
  implements
    $com$destroystokyo$paper$event$player$PlayerStopSpectatingEntityEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$entity$Entity);
  getSpectatorTarget(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$player$PlayerTeleportEndGatewayEvent {
  getGateway(): org$bukkit$block$EndGateway;
}

declare class com$destroystokyo$paper$event$player$PlayerTeleportEndGatewayEvent
  implements
    $com$destroystokyo$paper$event$player$PlayerTeleportEndGatewayEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: org$bukkit$block$EndGateway
  );
  getGateway(): org$bukkit$block$EndGateway;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$event$player$PlayerUseUnknownEntityEvent {
  getEntityId(): number;
  isAttack(): boolean;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$player$PlayerUseUnknownEntityEvent
  implements $com$destroystokyo$paper$event$player$PlayerUseUnknownEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: number,
    arg2: boolean,
    arg3: org$bukkit$inventory$EquipmentSlot
  );
  getEntityId(): number;
  isAttack(): boolean;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$profile$FillProfileEvent {
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getProperties(): any /* java.util.Set */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$profile$FillProfileEvent
  implements $com$destroystokyo$paper$event$profile$FillProfileEvent {
  constructor(arg0: com$destroystokyo$paper$profile$PlayerProfile);
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getProperties(): any /* java.util.Set */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$profile$LookupProfileEvent {
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$profile$LookupProfileEvent
  implements $com$destroystokyo$paper$event$profile$LookupProfileEvent {
  constructor(arg0: com$destroystokyo$paper$profile$PlayerProfile);
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$profile$PreFillProfileEvent {
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  setProperties(arg0: java$util$Collection): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$profile$PreFillProfileEvent
  implements $com$destroystokyo$paper$event$profile$PreFillProfileEvent {
  constructor(arg0: com$destroystokyo$paper$profile$PlayerProfile);
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  setProperties(arg0: java$util$Collection): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$profile$PreLookupProfileEvent {
  getName(): string;
  getUUID(): any /* java.util.UUID */;
  setUUID(arg0: any /* java.util.UUID */): void;
  getProfileProperties(): any /* java.util.Set */;
  setProfileProperties(arg0: any /* java.util.Set */): void;
  addProfileProperties(arg0: any /* java.util.Set */): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$profile$PreLookupProfileEvent
  implements $com$destroystokyo$paper$event$profile$PreLookupProfileEvent {
  constructor(arg0: string);
  getName(): string;
  getUUID(): any /* java.util.UUID */;
  setUUID(arg0: any /* java.util.UUID */): void;
  getProfileProperties(): any /* java.util.Set */;
  setProfileProperties(arg0: any /* java.util.Set */): void;
  addProfileProperties(arg0: any /* java.util.Set */): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$profile$ProfileWhitelistVerifyEvent {
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  isWhitelisted(): boolean;
  setWhitelisted(arg0: boolean): void;
  isOp(): boolean;
  isWhitelistEnabled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$profile$ProfileWhitelistVerifyEvent
  implements
    $com$destroystokyo$paper$event$profile$ProfileWhitelistVerifyEvent {
  constructor(
    arg0: com$destroystokyo$paper$profile$PlayerProfile,
    arg1: boolean,
    arg2: boolean,
    arg3: boolean,
    arg4: string
  );
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  isWhitelisted(): boolean;
  setWhitelisted(arg0: boolean): void;
  isOp(): boolean;
  isWhitelistEnabled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$server$AsyncTabCompleteEvent
  extends $org$bukkit$event$Cancellable {
  getSender(): org$bukkit$command$CommandSender;
  getCompletions(): any /* java.util.List */;
  setCompletions(arg0: any /* java.util.List */): void;
  getBuffer(): string;
  isCommand(): boolean;
  getLocation(): org$bukkit$Location;
  isHandled(): boolean;
  setHandled(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$server$AsyncTabCompleteEvent
  implements $com$destroystokyo$paper$event$server$AsyncTabCompleteEvent {
  constructor(
    arg0: org$bukkit$command$CommandSender,
    arg1: any /* java.util.List */,
    arg2: string,
    arg3: boolean,
    arg4: org$bukkit$Location
  );
  getSender(): org$bukkit$command$CommandSender;
  getCompletions(): any /* java.util.List */;
  setCompletions(arg0: any /* java.util.List */): void;
  getBuffer(): string;
  isCommand(): boolean;
  getLocation(): org$bukkit$Location;
  isHandled(): boolean;
  setHandled(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$server$GS4QueryEvent {
  getQueryType(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType;
  getQuerierAddress(): any /* java.net.InetAddress */;
  getResponse(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse;
  setResponse(
    arg0: com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse
  ): void;
  toString(): string;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$server$GS4QueryEvent
  implements $com$destroystokyo$paper$event$server$GS4QueryEvent {
  constructor(
    arg0: com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType,
    arg1: any /* java.net.InetAddress */,
    arg2: com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse
  );
  getQueryType(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType;
  getQuerierAddress(): any /* java.net.InetAddress */;
  getResponse(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse;
  setResponse(
    arg0: com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse
  ): void;
  toString(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType {}

declare class com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType
  implements $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType {
  static BASIC: com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType;
  static FULL: com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType;
  static values(): JavaArray<
    com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType
  >;
  static valueOf(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType;
}


declare interface $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse {
  getMotd(): string;
  getGameVersion(): string;
  getMap(): string;
  getCurrentPlayers(): number;
  getMaxPlayers(): number;
  getHostname(): string;
  getPort(): number;
  getPlayers(): java$util$Collection;
  getServerVersion(): string;
  getPlugins(): java$util$Collection;
  toBuilder(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
}

declare class com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse
  implements $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse {
  getMotd(): string;
  getGameVersion(): string;
  getMap(): string;
  getCurrentPlayers(): number;
  getMaxPlayers(): number;
  getHostname(): string;
  getPort(): number;
  getPlayers(): java$util$Collection;
  getServerVersion(): string;
  getPlugins(): java$util$Collection;
  toBuilder(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  static builder(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  constructor(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: number,
    arg4: number,
    arg5: string,
    arg6: number,
    arg7: java$util$Collection,
    arg8: string,
    arg9: java$util$Collection,
    arg10: com$destroystokyo$paper$event$server$GS4QueryEvent$1
  );
}


declare interface $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder {
  motd(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  gameVersion(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  map(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  currentPlayers(
    arg0: number
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  maxPlayers(
    arg0: number
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  hostname(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  port(
    arg0: number
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  players(
    arg0: java$util$Collection
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  players(
    arg0: JavaArray<string>
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  clearPlayers(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  serverVersion(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  plugins(
    arg0: java$util$Collection
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  plugins(
    arg0: JavaArray<
      com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation
    >
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  clearPlugins(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  build(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse;
}

declare class com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder
  implements
    $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder {
  motd(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  gameVersion(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  map(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  currentPlayers(
    arg0: number
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  maxPlayers(
    arg0: number
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  hostname(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  port(
    arg0: number
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  players(
    arg0: java$util$Collection
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  players(
    arg0: JavaArray<string>
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  clearPlayers(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  serverVersion(
    arg0: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  plugins(
    arg0: java$util$Collection
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  plugins(
    arg0: JavaArray<
      com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation
    >
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  clearPlugins(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  build(): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse;
  constructor(arg0: com$destroystokyo$paper$event$server$GS4QueryEvent$1);
}


declare interface $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation {
  getName(): string;
  setName(arg0: string): void;
  setVersion(arg0: string): void;
  getVersion(): string;
}

declare class com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation
  implements
    $com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation {
  constructor(arg0: string, arg1: string);
  getName(): string;
  setName(arg0: string): void;
  setVersion(arg0: string): void;
  getVersion(): string;
  static of(
    arg0: string,
    arg1: string
  ): com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation;
}


declare interface $com$destroystokyo$paper$event$server$GS4QueryEvent$1 {}

declare class com$destroystokyo$paper$event$server$GS4QueryEvent$1
  implements $com$destroystokyo$paper$event$server$GS4QueryEvent$1 {}


declare interface $com$destroystokyo$paper$event$server$PaperServerListPingEvent
  extends $org$bukkit$event$Cancellable {
  getClient(): com$destroystokyo$paper$network$StatusClient;
  getNumPlayers(): number;
  setNumPlayers(arg0: number): void;
  getMaxPlayers(): number;
  shouldHidePlayers(): boolean;
  setHidePlayers(arg0: boolean): void;
  getPlayerSample(): any /* java.util.List */;
  getVersion(): string;
  setVersion(arg0: string): void;
  getProtocolVersion(): number;
  setProtocolVersion(arg0: number): void;
  getServerIcon(): org$bukkit$util$CachedServerIcon;
  setServerIcon(arg0: org$bukkit$util$CachedServerIcon): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  iterator(): any /* java.util.Iterator */;
  getOnlinePlayers(): JavaArray<any>;
  getBukkitPlayer(arg0: any): org$bukkit$entity$Player;
}

declare class com$destroystokyo$paper$event$server$PaperServerListPingEvent
  implements $com$destroystokyo$paper$event$server$PaperServerListPingEvent {
  constructor(
    arg0: com$destroystokyo$paper$network$StatusClient,
    arg1: string,
    arg2: number,
    arg3: number,
    arg4: string,
    arg5: number,
    arg6: org$bukkit$util$CachedServerIcon
  );
  getClient(): com$destroystokyo$paper$network$StatusClient;
  getNumPlayers(): number;
  setNumPlayers(arg0: number): void;
  getMaxPlayers(): number;
  shouldHidePlayers(): boolean;
  setHidePlayers(arg0: boolean): void;
  getPlayerSample(): any /* java.util.List */;
  getVersion(): string;
  setVersion(arg0: string): void;
  getProtocolVersion(): number;
  setProtocolVersion(arg0: number): void;
  getServerIcon(): org$bukkit$util$CachedServerIcon;
  setServerIcon(arg0: org$bukkit$util$CachedServerIcon): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  iterator(): any /* java.util.Iterator */;
  getOnlinePlayers(): JavaArray<any>;
  getBukkitPlayer(arg0: any): org$bukkit$entity$Player;
  static access$100(
    arg0: com$destroystokyo$paper$event$server$PaperServerListPingEvent
  ): JavaArray<any>;
  static access$200(
    arg0: com$destroystokyo$paper$event$server$PaperServerListPingEvent
  ): boolean;
  static access$310(
    arg0: com$destroystokyo$paper$event$server$PaperServerListPingEvent
  ): number;
}


declare interface $com$destroystokyo$paper$network$StatusClient
  extends $com$destroystokyo$paper$network$NetworkClient {
  isLegacy(): boolean;
}

declare class com$destroystokyo$paper$network$StatusClient
  implements $com$destroystokyo$paper$network$StatusClient {
  isLegacy(): boolean;
  getAddress(): any /* java.net.InetSocketAddress */;
  getProtocolVersion(): number;
  getVirtualHost(): any /* java.net.InetSocketAddress */;
}


declare interface $com$destroystokyo$paper$event$server$PaperServerListPingEvent$1 {}

declare class com$destroystokyo$paper$event$server$PaperServerListPingEvent$1
  implements $com$destroystokyo$paper$event$server$PaperServerListPingEvent$1 {}


declare interface $com$destroystokyo$paper$event$server$PaperServerListPingEvent$PlayerIterator {
  hasNext(): boolean;
  next(): org$bukkit$entity$Player;
  remove(): void;
  next(): any;
}

declare class com$destroystokyo$paper$event$server$PaperServerListPingEvent$PlayerIterator
  implements
    $com$destroystokyo$paper$event$server$PaperServerListPingEvent$PlayerIterator {
  hasNext(): boolean;
  next(): org$bukkit$entity$Player;
  remove(): void;
  next(): any;
  constructor(
    arg0: com$destroystokyo$paper$event$server$PaperServerListPingEvent,
    arg1: com$destroystokyo$paper$event$server$PaperServerListPingEvent$1
  );
}


declare interface $com$destroystokyo$paper$event$server$ServerExceptionEvent {
  getException(): com$destroystokyo$paper$exception$ServerException;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$server$ServerExceptionEvent
  implements $com$destroystokyo$paper$event$server$ServerExceptionEvent {
  constructor(arg0: com$destroystokyo$paper$exception$ServerException);
  getException(): com$destroystokyo$paper$exception$ServerException;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$exception$ServerException {}

declare class com$destroystokyo$paper$exception$ServerException
  implements $com$destroystokyo$paper$exception$ServerException {
  constructor(arg0: string);
  constructor(arg0: string, arg1: any /* java.lang.Throwable */);
  constructor(arg0: any /* java.lang.Throwable */);
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean
  );
}


declare interface $com$destroystokyo$paper$event$server$ServerTickEndEvent {
  getTickNumber(): number;
  getTickDuration(): number;
  getTimeRemaining(): number;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$server$ServerTickEndEvent
  implements $com$destroystokyo$paper$event$server$ServerTickEndEvent {
  constructor(arg0: number, arg1: number, arg2: number);
  getTickNumber(): number;
  getTickDuration(): number;
  getTimeRemaining(): number;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$server$ServerTickStartEvent {
  getTickNumber(): number;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$server$ServerTickStartEvent
  implements $com$destroystokyo$paper$event$server$ServerTickStartEvent {
  constructor(arg0: number);
  getTickNumber(): number;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$event$server$WhitelistToggleEvent {
  isEnabled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class com$destroystokyo$paper$event$server$WhitelistToggleEvent
  implements $com$destroystokyo$paper$event$server$WhitelistToggleEvent {
  constructor(arg0: boolean);
  isEnabled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $com$destroystokyo$paper$exception$ServerCommandException {
  getCommand(): org$bukkit$command$Command;
  getCommandSender(): org$bukkit$command$CommandSender;
  getArguments(): JavaArray<string>;
}

declare class com$destroystokyo$paper$exception$ServerCommandException
  implements $com$destroystokyo$paper$exception$ServerCommandException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$command$Command,
    arg3: org$bukkit$command$CommandSender,
    arg4: JavaArray<string>
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$command$Command,
    arg2: org$bukkit$command$CommandSender,
    arg3: JavaArray<string>
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$command$Command,
    arg5: org$bukkit$command$CommandSender,
    arg6: JavaArray<string>
  );
  getCommand(): org$bukkit$command$Command;
  getCommandSender(): org$bukkit$command$CommandSender;
  getArguments(): JavaArray<string>;
}


declare interface $com$destroystokyo$paper$exception$ServerEventException {
  getListener(): org$bukkit$event$Listener;
  getEvent(): org$bukkit$event$Event;
}

declare class com$destroystokyo$paper$exception$ServerEventException
  implements $com$destroystokyo$paper$exception$ServerEventException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$plugin$Plugin,
    arg3: org$bukkit$event$Listener,
    arg4: org$bukkit$event$Event
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$plugin$Plugin,
    arg2: org$bukkit$event$Listener,
    arg3: org$bukkit$event$Event
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$plugin$Plugin,
    arg5: org$bukkit$event$Listener,
    arg6: org$bukkit$event$Event
  );
  getListener(): org$bukkit$event$Listener;
  getEvent(): org$bukkit$event$Event;
}


declare interface $com$destroystokyo$paper$exception$ServerInternalException {}

declare class com$destroystokyo$paper$exception$ServerInternalException
  implements $com$destroystokyo$paper$exception$ServerInternalException {
  constructor(arg0: string);
  constructor(arg0: string, arg1: any /* java.lang.Throwable */);
  constructor(arg0: any /* java.lang.Throwable */);
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean
  );
  static reportInternalException(arg0: any /* java.lang.Throwable */): void;
}


declare interface $com$destroystokyo$paper$exception$ServerPluginEnableDisableException {}

declare class com$destroystokyo$paper$exception$ServerPluginEnableDisableException
  implements
    $com$destroystokyo$paper$exception$ServerPluginEnableDisableException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$plugin$Plugin
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$plugin$Plugin
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$plugin$Plugin
  );
}


declare interface $com$destroystokyo$paper$exception$ServerPluginException {
  getResponsiblePlugin(): org$bukkit$plugin$Plugin;
}

declare class com$destroystokyo$paper$exception$ServerPluginException
  implements $com$destroystokyo$paper$exception$ServerPluginException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$plugin$Plugin
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$plugin$Plugin
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$plugin$Plugin
  );
  getResponsiblePlugin(): org$bukkit$plugin$Plugin;
}


declare interface $com$destroystokyo$paper$exception$ServerPluginMessageException {
  getChannel(): string;
  getData(): JavaArray<Buffer>;
  getPlayer(): org$bukkit$entity$Player;
}

declare class com$destroystokyo$paper$exception$ServerPluginMessageException
  implements $com$destroystokyo$paper$exception$ServerPluginMessageException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$plugin$Plugin,
    arg3: org$bukkit$entity$Player,
    arg4: string,
    arg5: JavaArray<Buffer>
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$plugin$Plugin,
    arg2: org$bukkit$entity$Player,
    arg3: string,
    arg4: JavaArray<Buffer>
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$plugin$Plugin,
    arg5: org$bukkit$entity$Player,
    arg6: string,
    arg7: JavaArray<Buffer>
  );
  getChannel(): string;
  getData(): JavaArray<Buffer>;
  getPlayer(): org$bukkit$entity$Player;
}


declare interface $com$destroystokyo$paper$exception$ServerSchedulerException {
  getTask(): org$bukkit$scheduler$BukkitTask;
}

declare class com$destroystokyo$paper$exception$ServerSchedulerException
  implements $com$destroystokyo$paper$exception$ServerSchedulerException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$scheduler$BukkitTask
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$scheduler$BukkitTask
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$scheduler$BukkitTask
  );
  getTask(): org$bukkit$scheduler$BukkitTask;
}


declare interface $com$destroystokyo$paper$exception$ServerTabCompleteException {}

declare class com$destroystokyo$paper$exception$ServerTabCompleteException
  implements $com$destroystokyo$paper$exception$ServerTabCompleteException {
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: org$bukkit$command$Command,
    arg3: org$bukkit$command$CommandSender,
    arg4: JavaArray<string>
  );
  constructor(
    arg0: any /* java.lang.Throwable */,
    arg1: org$bukkit$command$Command,
    arg2: org$bukkit$command$CommandSender,
    arg3: JavaArray<string>
  );
  constructor(
    arg0: string,
    arg1: any /* java.lang.Throwable */,
    arg2: boolean,
    arg3: boolean,
    arg4: org$bukkit$command$Command,
    arg5: org$bukkit$command$CommandSender,
    arg6: JavaArray<string>
  );
}


declare interface $com$destroystokyo$paper$inventory$ItemStackRecipeChoice
  extends $org$bukkit$inventory$RecipeChoice {
  getItemStack(): org$bukkit$inventory$ItemStack;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  clone(): any;
  test(arg0: any): boolean;
}

declare class com$destroystokyo$paper$inventory$ItemStackRecipeChoice
  implements $com$destroystokyo$paper$inventory$ItemStackRecipeChoice {
  constructor(arg0: org$bukkit$inventory$ItemStack);
  constructor(arg0: any /* java.util.List */);
  getItemStack(): org$bukkit$inventory$ItemStack;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  clone(): any;
  test(arg0: any): boolean;
}


declare interface $org$bukkit$inventory$RecipeChoice {
  getItemStack(): org$bukkit$inventory$ItemStack;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  test(arg0: any): boolean;
}

declare class org$bukkit$inventory$RecipeChoice
  implements $org$bukkit$inventory$RecipeChoice {
  getItemStack(): org$bukkit$inventory$ItemStack;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  test(arg0: any): boolean;
}


declare interface $com$destroystokyo$paper$inventory$meta$ArmorStandMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  isInvisible(): boolean;
  hasNoBasePlate(): boolean;
  shouldShowArms(): boolean;
  isSmall(): boolean;
  isMarker(): boolean;
  setInvisible(arg0: boolean): void;
  setNoBasePlate(arg0: boolean): void;
  setShowArms(arg0: boolean): void;
  setSmall(arg0: boolean): void;
  setMarker(arg0: boolean): void;
}

declare class com$destroystokyo$paper$inventory$meta$ArmorStandMeta
  implements $com$destroystokyo$paper$inventory$meta$ArmorStandMeta {
  isInvisible(): boolean;
  hasNoBasePlate(): boolean;
  shouldShowArms(): boolean;
  isSmall(): boolean;
  isMarker(): boolean;
  setInvisible(arg0: boolean): void;
  setNoBasePlate(arg0: boolean): void;
  setShowArms(arg0: boolean): void;
  setSmall(arg0: boolean): void;
  setMarker(arg0: boolean): void;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $com$destroystokyo$paper$loottable$LootableBlockInventory
  extends $com$destroystokyo$paper$loottable$LootableInventory {
  getBlock(): org$bukkit$block$Block;
}

declare class com$destroystokyo$paper$loottable$LootableBlockInventory
  implements $com$destroystokyo$paper$loottable$LootableBlockInventory {
  getBlock(): org$bukkit$block$Block;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
}


declare interface $com$destroystokyo$paper$loottable$LootableInventory
  extends $org$bukkit$loot$Lootable {
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
}

declare class com$destroystokyo$paper$loottable$LootableInventory
  implements $com$destroystokyo$paper$loottable$LootableInventory {
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
}


declare interface $com$destroystokyo$paper$loottable$LootableEntityInventory
  extends $com$destroystokyo$paper$loottable$LootableInventory {
  getEntity(): org$bukkit$entity$Entity;
}

declare class com$destroystokyo$paper$loottable$LootableEntityInventory
  implements $com$destroystokyo$paper$loottable$LootableEntityInventory {
  getEntity(): org$bukkit$entity$Entity;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
}


declare interface $com$destroystokyo$paper$loottable$LootableInventoryReplenishEvent
  extends $org$bukkit$event$Cancellable {
  getInventory(): com$destroystokyo$paper$loottable$LootableInventory;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class com$destroystokyo$paper$loottable$LootableInventoryReplenishEvent
  implements
    $com$destroystokyo$paper$loottable$LootableInventoryReplenishEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: com$destroystokyo$paper$loottable$LootableInventory
  );
  getInventory(): com$destroystokyo$paper$loottable$LootableInventory;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $com$destroystokyo$paper$MaterialSetTag
  extends $org$bukkit$Tag {
  getKey(): org$bukkit$NamespacedKey;
  add(arg0: JavaArray<org$bukkit$Tag>): com$destroystokyo$paper$MaterialSetTag;
  add(
    arg0: JavaArray<com$destroystokyo$paper$MaterialSetTag>
  ): com$destroystokyo$paper$MaterialSetTag;
  add(
    arg0: JavaArray<org$bukkit$Material>
  ): com$destroystokyo$paper$MaterialSetTag;
  add(arg0: java$util$Collection): com$destroystokyo$paper$MaterialSetTag;
  contains(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  endsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  startsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  add(
    arg0: any /* java.util.function.Predicate */
  ): com$destroystokyo$paper$MaterialSetTag;
  not(
    arg0: com$destroystokyo$paper$MaterialSetTag
  ): com$destroystokyo$paper$MaterialSetTag;
  not(
    arg0: JavaArray<org$bukkit$Material>
  ): com$destroystokyo$paper$MaterialSetTag;
  not(arg0: java$util$Collection): com$destroystokyo$paper$MaterialSetTag;
  not(
    arg0: any /* java.util.function.Predicate */
  ): com$destroystokyo$paper$MaterialSetTag;
  notEndsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  notStartsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  getValues(): any /* java.util.Set */;
  isTagged(arg0: org$bukkit$block$data$BlockData): boolean;
  isTagged(arg0: org$bukkit$block$BlockState): boolean;
  isTagged(arg0: org$bukkit$block$Block): boolean;
  isTagged(arg0: org$bukkit$inventory$ItemStack): boolean;
  isTagged(arg0: org$bukkit$Material): boolean;
  ensureSize(
    arg0: string,
    arg1: number
  ): com$destroystokyo$paper$MaterialSetTag;
  isTagged(arg0: org$bukkit$Keyed): boolean;
}

declare class com$destroystokyo$paper$MaterialSetTag
  implements $com$destroystokyo$paper$MaterialSetTag {
  constructor(arg0: any /* java.util.function.Predicate */);
  constructor(arg0: java$util$Collection);
  constructor(arg0: JavaArray<org$bukkit$Material>);
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: any /* java.util.function.Predicate */
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: JavaArray<org$bukkit$Material>
  );
  constructor(arg0: org$bukkit$NamespacedKey, arg1: java$util$Collection);
  getKey(): org$bukkit$NamespacedKey;
  add(arg0: JavaArray<org$bukkit$Tag>): com$destroystokyo$paper$MaterialSetTag;
  add(
    arg0: JavaArray<com$destroystokyo$paper$MaterialSetTag>
  ): com$destroystokyo$paper$MaterialSetTag;
  add(
    arg0: JavaArray<org$bukkit$Material>
  ): com$destroystokyo$paper$MaterialSetTag;
  add(arg0: java$util$Collection): com$destroystokyo$paper$MaterialSetTag;
  contains(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  endsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  startsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  add(
    arg0: any /* java.util.function.Predicate */
  ): com$destroystokyo$paper$MaterialSetTag;
  not(
    arg0: com$destroystokyo$paper$MaterialSetTag
  ): com$destroystokyo$paper$MaterialSetTag;
  not(
    arg0: JavaArray<org$bukkit$Material>
  ): com$destroystokyo$paper$MaterialSetTag;
  not(arg0: java$util$Collection): com$destroystokyo$paper$MaterialSetTag;
  not(
    arg0: any /* java.util.function.Predicate */
  ): com$destroystokyo$paper$MaterialSetTag;
  notEndsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  notStartsWith(arg0: string): com$destroystokyo$paper$MaterialSetTag;
  getValues(): any /* java.util.Set */;
  isTagged(arg0: org$bukkit$block$data$BlockData): boolean;
  isTagged(arg0: org$bukkit$block$BlockState): boolean;
  isTagged(arg0: org$bukkit$block$Block): boolean;
  isTagged(arg0: org$bukkit$inventory$ItemStack): boolean;
  isTagged(arg0: org$bukkit$Material): boolean;
  ensureSize(
    arg0: string,
    arg1: number
  ): com$destroystokyo$paper$MaterialSetTag;
  isTagged(arg0: org$bukkit$Keyed): boolean;
  static REGISTRY_BLOCKS: string;
  static WOOL: org$bukkit$Tag;
  static PLANKS: org$bukkit$Tag;
  static STONE_BRICKS: org$bukkit$Tag;
  static WOODEN_BUTTONS: org$bukkit$Tag;
  static BUTTONS: org$bukkit$Tag;
  static CARPETS: org$bukkit$Tag;
  static WOODEN_DOORS: org$bukkit$Tag;
  static WOODEN_STAIRS: org$bukkit$Tag;
  static WOODEN_SLABS: org$bukkit$Tag;
  static WOODEN_FENCES: org$bukkit$Tag;
  static WOODEN_PRESSURE_PLATES: org$bukkit$Tag;
  static WOODEN_TRAPDOORS: org$bukkit$Tag;
  static DOORS: org$bukkit$Tag;
  static SAPLINGS: org$bukkit$Tag;
  static LOGS: org$bukkit$Tag;
  static DARK_OAK_LOGS: org$bukkit$Tag;
  static OAK_LOGS: org$bukkit$Tag;
  static BIRCH_LOGS: org$bukkit$Tag;
  static ACACIA_LOGS: org$bukkit$Tag;
  static JUNGLE_LOGS: org$bukkit$Tag;
  static SPRUCE_LOGS: org$bukkit$Tag;
  static BANNERS: org$bukkit$Tag;
  static SAND: org$bukkit$Tag;
  static STAIRS: org$bukkit$Tag;
  static SLABS: org$bukkit$Tag;
  static WALLS: org$bukkit$Tag;
  static ANVIL: org$bukkit$Tag;
  static RAILS: org$bukkit$Tag;
  static LEAVES: org$bukkit$Tag;
  static TRAPDOORS: org$bukkit$Tag;
  static FLOWER_POTS: org$bukkit$Tag;
  static SMALL_FLOWERS: org$bukkit$Tag;
  static BEDS: org$bukkit$Tag;
  static FENCES: org$bukkit$Tag;
  static TALL_FLOWERS: org$bukkit$Tag;
  static FLOWERS: org$bukkit$Tag;
  static SHULKER_BOXES: org$bukkit$Tag;
  static ENDERMAN_HOLDABLE: org$bukkit$Tag;
  static ICE: org$bukkit$Tag;
  static VALID_SPAWN: org$bukkit$Tag;
  static IMPERMEABLE: org$bukkit$Tag;
  static UNDERWATER_BONEMEALS: org$bukkit$Tag;
  static CORAL_BLOCKS: org$bukkit$Tag;
  static WALL_CORALS: org$bukkit$Tag;
  static CORAL_PLANTS: org$bukkit$Tag;
  static CORALS: org$bukkit$Tag;
  static BAMBOO_PLANTABLE_ON: org$bukkit$Tag;
  static STANDING_SIGNS: org$bukkit$Tag;
  static WALL_SIGNS: org$bukkit$Tag;
  static SIGNS: org$bukkit$Tag;
  static DRAGON_IMMUNE: org$bukkit$Tag;
  static WITHER_IMMUNE: org$bukkit$Tag;
  static BEEHIVES: org$bukkit$Tag;
  static CROPS: org$bukkit$Tag;
  static BEE_GROWABLES: org$bukkit$Tag;
  static PORTALS: org$bukkit$Tag;
  static REGISTRY_ITEMS: string;
  static ITEMS_BANNERS: org$bukkit$Tag;
  static ITEMS_BOATS: org$bukkit$Tag;
  static ITEMS_FISHES: org$bukkit$Tag;
  static ITEMS_MUSIC_DISCS: org$bukkit$Tag;
  static ITEMS_COALS: org$bukkit$Tag;
  static ITEMS_ARROWS: org$bukkit$Tag;
  static ITEMS_LECTERN_BOOKS: org$bukkit$Tag;
}


declare interface $com$destroystokyo$paper$MaterialTags {}

declare class com$destroystokyo$paper$MaterialTags
  implements $com$destroystokyo$paper$MaterialTags {
  static ARROWS: com$destroystokyo$paper$MaterialSetTag;
  static BEDS: com$destroystokyo$paper$MaterialSetTag;
  static BUCKETS: com$destroystokyo$paper$MaterialSetTag;
  static COALS: com$destroystokyo$paper$MaterialSetTag;
  static COBBLESTONE_WALLS: com$destroystokyo$paper$MaterialSetTag;
  static COBBLESTONES: com$destroystokyo$paper$MaterialSetTag;
  static CONCRETES: com$destroystokyo$paper$MaterialSetTag;
  static CONCRETE_POWDER: com$destroystokyo$paper$MaterialSetTag;
  static COOKED_FISH: com$destroystokyo$paper$MaterialSetTag;
  static DYES: com$destroystokyo$paper$MaterialSetTag;
  static FENCE_GATES: com$destroystokyo$paper$MaterialSetTag;
  static FENCES: com$destroystokyo$paper$MaterialSetTag;
  static FISH_BUCKETS: com$destroystokyo$paper$MaterialSetTag;
  static GLASS: com$destroystokyo$paper$MaterialSetTag;
  static GLASS_PANES: com$destroystokyo$paper$MaterialSetTag;
  static GLAZED_TERRACOTTA: com$destroystokyo$paper$MaterialSetTag;
  static STAINED_TERRACOTTA: com$destroystokyo$paper$MaterialSetTag;
  static TERRACOTTA: com$destroystokyo$paper$MaterialSetTag;
  static GOLDEN_APPLES: com$destroystokyo$paper$MaterialSetTag;
  static HORSE_ARMORS: com$destroystokyo$paper$MaterialSetTag;
  static INFESTED_BLOCKS: com$destroystokyo$paper$MaterialSetTag;
  static MUSHROOM_BLOCKS: com$destroystokyo$paper$MaterialSetTag;
  static MUSHROOMS: com$destroystokyo$paper$MaterialSetTag;
  static MUSIC_DISCS: com$destroystokyo$paper$MaterialSetTag;
  static ORES: com$destroystokyo$paper$MaterialSetTag;
  static PISTONS: com$destroystokyo$paper$MaterialSetTag;
  static POTATOES: com$destroystokyo$paper$MaterialSetTag;
  static PRESSURE_PLATES: com$destroystokyo$paper$MaterialSetTag;
  static PRISMARINE: com$destroystokyo$paper$MaterialSetTag;
  static PRISMARINE_SLABS: com$destroystokyo$paper$MaterialSetTag;
  static PRISMARINE_STAIRS: com$destroystokyo$paper$MaterialSetTag;
  static PUMPKINS: com$destroystokyo$paper$MaterialSetTag;
  static QUARTZ_BLOCKS: com$destroystokyo$paper$MaterialSetTag;
  static RAW_FISH: com$destroystokyo$paper$MaterialSetTag;
  static RED_SANDSTONES: com$destroystokyo$paper$MaterialSetTag;
  static SANDSTONES: com$destroystokyo$paper$MaterialSetTag;
  static SPONGES: com$destroystokyo$paper$MaterialSetTag;
  static SHULKER_BOXES: com$destroystokyo$paper$MaterialSetTag;
  static SKULLS: com$destroystokyo$paper$MaterialSetTag;
  static SPAWN_EGGS: com$destroystokyo$paper$MaterialSetTag;
  static STAINED_GLASS: com$destroystokyo$paper$MaterialSetTag;
  static STAINED_GLASS_PANES: com$destroystokyo$paper$MaterialSetTag;
  static TRAPDOORS: com$destroystokyo$paper$MaterialSetTag;
  static WOODEN_FENCES: com$destroystokyo$paper$MaterialSetTag;
  static WOODEN_TRAPDOORS: com$destroystokyo$paper$MaterialSetTag;
  static WOODEN_GATES: com$destroystokyo$paper$MaterialSetTag;
  static PURPUR: com$destroystokyo$paper$MaterialSetTag;
  static SIGNS: com$destroystokyo$paper$MaterialSetTag;
  static TORCH: com$destroystokyo$paper$MaterialSetTag;
  static REDSTONE_TORCH: com$destroystokyo$paper$MaterialSetTag;
  static COLORABLE: com$destroystokyo$paper$MaterialSetTag;
  constructor();
}


declare interface $com$destroystokyo$paper$NamespacedTag
  extends $com$destroystokyo$paper$Namespaced {
  getNamespace(): string;
  getKey(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
}

declare class com$destroystokyo$paper$NamespacedTag
  implements $com$destroystokyo$paper$NamespacedTag {
  static MINECRAFT: string;
  static BUKKIT: string;
  constructor(arg0: string, arg1: string);
  constructor(arg0: org$bukkit$plugin$Plugin, arg1: string);
  getNamespace(): string;
  getKey(): string;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  static randomKey(): com$destroystokyo$paper$NamespacedTag;
  static minecraft(arg0: string): com$destroystokyo$paper$NamespacedTag;
}


declare interface $com$destroystokyo$paper$util$SneakyThrow {}

declare class com$destroystokyo$paper$util$SneakyThrow
  implements $com$destroystokyo$paper$util$SneakyThrow {
  constructor();
  static sneaky(arg0: any /* java.lang.Throwable */): void;
}


declare interface $com$destroystokyo$paper$util$VersionFetcher$DummyVersionFetcher
  extends $com$destroystokyo$paper$util$VersionFetcher {
  getCacheTime(): number;
  getVersionMessage(arg0: string): string;
}

declare class com$destroystokyo$paper$util$VersionFetcher$DummyVersionFetcher
  implements $com$destroystokyo$paper$util$VersionFetcher$DummyVersionFetcher {
  constructor();
  getCacheTime(): number;
  getVersionMessage(arg0: string): string;
}


declare interface $com$destroystokyo$paper$utils$CachedSizeConcurrentLinkedQueue {
  add(arg0: any): boolean;
  poll(): any;
  size(): number;
}

declare class com$destroystokyo$paper$utils$CachedSizeConcurrentLinkedQueue
  implements $com$destroystokyo$paper$utils$CachedSizeConcurrentLinkedQueue {
  constructor();
  add(arg0: any): boolean;
  poll(): any;
  size(): number;
  isEmpty(): boolean;
  contains(arg0: any): boolean;
  iterator(): any /* java.util.Iterator */;
  toArray(): JavaArray<any>;
  toArray(arg0: JavaArray<any>): JavaArray<any>;
  remove(arg0: any): boolean;
  containsAll(arg0: java$util$Collection): boolean;
  addAll(arg0: java$util$Collection): boolean;
  removeAll(arg0: java$util$Collection): boolean;
  removeIf(arg0: any /* java.util.function.Predicate */): boolean;
  retainAll(arg0: java$util$Collection): boolean;
  clear(): void;
  equals(arg0: any): boolean;
  hashCode(): number;
  spliterator(): any /* java.util.Spliterator */;
  stream(): any /* java.util.stream.Stream */;
  parallelStream(): any /* java.util.stream.Stream */;
}


declare interface $com$destroystokyo$paper$utils$PaperPluginLogger {
  setParent(arg0: any /* java.util.logging.Logger */): void;
}

declare class com$destroystokyo$paper$utils$PaperPluginLogger
  implements $com$destroystokyo$paper$utils$PaperPluginLogger {
  static getLogger(
    arg0: org$bukkit$plugin$PluginDescriptionFile
  ): any /* java.util.logging.Logger */;
  setParent(arg0: any /* java.util.logging.Logger */): void;
}


declare interface $com$destroystokyo$paper$utils$UnsafeUtils {}

declare class com$destroystokyo$paper$utils$UnsafeUtils
  implements $com$destroystokyo$paper$utils$UnsafeUtils {
  static isUnsafeSupported(): boolean;
  static getUnsafe(): sun$misc$Unsafe;
}


declare interface $sun$misc$Unsafe {
  getInt(arg0: any, arg1: number): number;
  putInt(arg0: any, arg1: number, arg2: number): void;
  getObject(arg0: any, arg1: number): any;
  putObject(arg0: any, arg1: number, arg2: any): void;
  getBoolean(arg0: any, arg1: number): boolean;
  putBoolean(arg0: any, arg1: number, arg2: boolean): void;
  getByte(arg0: any, arg1: number): Buffer;
  putByte(arg0: any, arg1: number, arg2: Buffer): void;
  getShort(arg0: any, arg1: number): unknown;
  putShort(arg0: any, arg1: number, arg2: unknown): void;
  getChar(arg0: any, arg1: number): string;
  putChar(arg0: any, arg1: number, arg2: string): void;
  getLong(arg0: any, arg1: number): number;
  putLong(arg0: any, arg1: number, arg2: number): void;
  getFloat(arg0: any, arg1: number): number;
  putFloat(arg0: any, arg1: number, arg2: number): void;
  getDouble(arg0: any, arg1: number): number;
  putDouble(arg0: any, arg1: number, arg2: number): void;
  getInt(arg0: any, arg1: number): number;
  putInt(arg0: any, arg1: number, arg2: number): void;
  getObject(arg0: any, arg1: number): any;
  putObject(arg0: any, arg1: number, arg2: any): void;
  getBoolean(arg0: any, arg1: number): boolean;
  putBoolean(arg0: any, arg1: number, arg2: boolean): void;
  getByte(arg0: any, arg1: number): Buffer;
  putByte(arg0: any, arg1: number, arg2: Buffer): void;
  getShort(arg0: any, arg1: number): unknown;
  putShort(arg0: any, arg1: number, arg2: unknown): void;
  getChar(arg0: any, arg1: number): string;
  putChar(arg0: any, arg1: number, arg2: string): void;
  getLong(arg0: any, arg1: number): number;
  putLong(arg0: any, arg1: number, arg2: number): void;
  getFloat(arg0: any, arg1: number): number;
  putFloat(arg0: any, arg1: number, arg2: number): void;
  getDouble(arg0: any, arg1: number): number;
  putDouble(arg0: any, arg1: number, arg2: number): void;
  getByte(arg0: number): Buffer;
  putByte(arg0: number, arg1: Buffer): void;
  getShort(arg0: number): unknown;
  putShort(arg0: number, arg1: unknown): void;
  getChar(arg0: number): string;
  putChar(arg0: number, arg1: string): void;
  getInt(arg0: number): number;
  putInt(arg0: number, arg1: number): void;
  getLong(arg0: number): number;
  putLong(arg0: number, arg1: number): void;
  getFloat(arg0: number): number;
  putFloat(arg0: number, arg1: number): void;
  getDouble(arg0: number): number;
  putDouble(arg0: number, arg1: number): void;
  getAddress(arg0: number): number;
  putAddress(arg0: number, arg1: number): void;
  allocateMemory(arg0: number): number;
  reallocateMemory(arg0: number, arg1: number): number;
  setMemory(arg0: any, arg1: number, arg2: number, arg3: Buffer): void;
  setMemory(arg0: number, arg1: number, arg2: Buffer): void;
  copyMemory(
    arg0: any,
    arg1: number,
    arg2: any,
    arg3: number,
    arg4: number
  ): void;
  copyMemory(arg0: number, arg1: number, arg2: number): void;
  freeMemory(arg0: number): void;
  fieldOffset(arg0: any /* java.lang.reflect.Field */): number;
  staticFieldBase(arg0: any /* java.lang.Class */): any;
  staticFieldOffset(arg0: any /* java.lang.reflect.Field */): number;
  objectFieldOffset(arg0: any /* java.lang.reflect.Field */): number;
  staticFieldBase(arg0: any /* java.lang.reflect.Field */): any;
  shouldBeInitialized(arg0: any /* java.lang.Class */): boolean;
  ensureClassInitialized(arg0: any /* java.lang.Class */): void;
  arrayBaseOffset(arg0: any /* java.lang.Class */): number;
  arrayIndexScale(arg0: any /* java.lang.Class */): number;
  addressSize(): number;
  pageSize(): number;
  defineClass(
    arg0: string,
    arg1: JavaArray<Buffer>,
    arg2: number,
    arg3: number,
    arg4: any /* java.lang.ClassLoader */,
    arg5: any /* java.security.ProtectionDomain */
  ): any /* java.lang.Class */;
  defineAnonymousClass(
    arg0: any /* java.lang.Class */,
    arg1: JavaArray<Buffer>,
    arg2: JavaArray<any>
  ): any /* java.lang.Class */;
  allocateInstance(arg0: any /* java.lang.Class */): any;
  monitorEnter(arg0: any): void;
  monitorExit(arg0: any): void;
  tryMonitorEnter(arg0: any): boolean;
  throwException(arg0: any /* java.lang.Throwable */): void;
  compareAndSwapObject(arg0: any, arg1: number, arg2: any, arg3: any): boolean;
  compareAndSwapInt(
    arg0: any,
    arg1: number,
    arg2: number,
    arg3: number
  ): boolean;
  compareAndSwapLong(
    arg0: any,
    arg1: number,
    arg2: number,
    arg3: number
  ): boolean;
  getObjectVolatile(arg0: any, arg1: number): any;
  putObjectVolatile(arg0: any, arg1: number, arg2: any): void;
  getIntVolatile(arg0: any, arg1: number): number;
  putIntVolatile(arg0: any, arg1: number, arg2: number): void;
  getBooleanVolatile(arg0: any, arg1: number): boolean;
  putBooleanVolatile(arg0: any, arg1: number, arg2: boolean): void;
  getByteVolatile(arg0: any, arg1: number): Buffer;
  putByteVolatile(arg0: any, arg1: number, arg2: Buffer): void;
  getShortVolatile(arg0: any, arg1: number): unknown;
  putShortVolatile(arg0: any, arg1: number, arg2: unknown): void;
  getCharVolatile(arg0: any, arg1: number): string;
  putCharVolatile(arg0: any, arg1: number, arg2: string): void;
  getLongVolatile(arg0: any, arg1: number): number;
  putLongVolatile(arg0: any, arg1: number, arg2: number): void;
  getFloatVolatile(arg0: any, arg1: number): number;
  putFloatVolatile(arg0: any, arg1: number, arg2: number): void;
  getDoubleVolatile(arg0: any, arg1: number): number;
  putDoubleVolatile(arg0: any, arg1: number, arg2: number): void;
  putOrderedObject(arg0: any, arg1: number, arg2: any): void;
  putOrderedInt(arg0: any, arg1: number, arg2: number): void;
  putOrderedLong(arg0: any, arg1: number, arg2: number): void;
  unpark(arg0: any): void;
  park(arg0: boolean, arg1: number): void;
  getLoadAverage(arg0: JavaArray<number>, arg1: number): number;
  getAndAddInt(arg0: any, arg1: number, arg2: number): number;
  getAndAddLong(arg0: any, arg1: number, arg2: number): number;
  getAndSetInt(arg0: any, arg1: number, arg2: number): number;
  getAndSetLong(arg0: any, arg1: number, arg2: number): number;
  getAndSetObject(arg0: any, arg1: number, arg2: any): any;
  loadFence(): void;
  storeFence(): void;
  fullFence(): void;
}

declare class sun$misc$Unsafe implements $sun$misc$Unsafe {
  static INVALID_FIELD_OFFSET: number;
  static ARRAY_BOOLEAN_BASE_OFFSET: number;
  static ARRAY_BYTE_BASE_OFFSET: number;
  static ARRAY_SHORT_BASE_OFFSET: number;
  static ARRAY_CHAR_BASE_OFFSET: number;
  static ARRAY_INT_BASE_OFFSET: number;
  static ARRAY_LONG_BASE_OFFSET: number;
  static ARRAY_FLOAT_BASE_OFFSET: number;
  static ARRAY_DOUBLE_BASE_OFFSET: number;
  static ARRAY_OBJECT_BASE_OFFSET: number;
  static ARRAY_BOOLEAN_INDEX_SCALE: number;
  static ARRAY_BYTE_INDEX_SCALE: number;
  static ARRAY_SHORT_INDEX_SCALE: number;
  static ARRAY_CHAR_INDEX_SCALE: number;
  static ARRAY_INT_INDEX_SCALE: number;
  static ARRAY_LONG_INDEX_SCALE: number;
  static ARRAY_FLOAT_INDEX_SCALE: number;
  static ARRAY_DOUBLE_INDEX_SCALE: number;
  static ARRAY_OBJECT_INDEX_SCALE: number;
  static ADDRESS_SIZE: number;
  static getUnsafe(): sun$misc$Unsafe;
  getInt(arg0: any, arg1: number): number;
  putInt(arg0: any, arg1: number, arg2: number): void;
  getObject(arg0: any, arg1: number): any;
  putObject(arg0: any, arg1: number, arg2: any): void;
  getBoolean(arg0: any, arg1: number): boolean;
  putBoolean(arg0: any, arg1: number, arg2: boolean): void;
  getByte(arg0: any, arg1: number): Buffer;
  putByte(arg0: any, arg1: number, arg2: Buffer): void;
  getShort(arg0: any, arg1: number): unknown;
  putShort(arg0: any, arg1: number, arg2: unknown): void;
  getChar(arg0: any, arg1: number): string;
  putChar(arg0: any, arg1: number, arg2: string): void;
  getLong(arg0: any, arg1: number): number;
  putLong(arg0: any, arg1: number, arg2: number): void;
  getFloat(arg0: any, arg1: number): number;
  putFloat(arg0: any, arg1: number, arg2: number): void;
  getDouble(arg0: any, arg1: number): number;
  putDouble(arg0: any, arg1: number, arg2: number): void;
  getByte(arg0: number): Buffer;
  putByte(arg0: number, arg1: Buffer): void;
  getShort(arg0: number): unknown;
  putShort(arg0: number, arg1: unknown): void;
  getChar(arg0: number): string;
  putChar(arg0: number, arg1: string): void;
  getInt(arg0: number): number;
  putInt(arg0: number, arg1: number): void;
  getLong(arg0: number): number;
  putLong(arg0: number, arg1: number): void;
  getFloat(arg0: number): number;
  putFloat(arg0: number, arg1: number): void;
  getDouble(arg0: number): number;
  putDouble(arg0: number, arg1: number): void;
  getAddress(arg0: number): number;
  putAddress(arg0: number, arg1: number): void;
  allocateMemory(arg0: number): number;
  reallocateMemory(arg0: number, arg1: number): number;
  setMemory(arg0: any, arg1: number, arg2: number, arg3: Buffer): void;
  setMemory(arg0: number, arg1: number, arg2: Buffer): void;
  copyMemory(
    arg0: any,
    arg1: number,
    arg2: any,
    arg3: number,
    arg4: number
  ): void;
  copyMemory(arg0: number, arg1: number, arg2: number): void;
  freeMemory(arg0: number): void;
  fieldOffset(arg0: any /* java.lang.reflect.Field */): number;
  staticFieldBase(arg0: any /* java.lang.Class */): any;
  staticFieldOffset(arg0: any /* java.lang.reflect.Field */): number;
  objectFieldOffset(arg0: any /* java.lang.reflect.Field */): number;
  staticFieldBase(arg0: any /* java.lang.reflect.Field */): any;
  shouldBeInitialized(arg0: any /* java.lang.Class */): boolean;
  ensureClassInitialized(arg0: any /* java.lang.Class */): void;
  arrayBaseOffset(arg0: any /* java.lang.Class */): number;
  arrayIndexScale(arg0: any /* java.lang.Class */): number;
  addressSize(): number;
  pageSize(): number;
  defineClass(
    arg0: string,
    arg1: JavaArray<Buffer>,
    arg2: number,
    arg3: number,
    arg4: any /* java.lang.ClassLoader */,
    arg5: any /* java.security.ProtectionDomain */
  ): any /* java.lang.Class */;
  defineAnonymousClass(
    arg0: any /* java.lang.Class */,
    arg1: JavaArray<Buffer>,
    arg2: JavaArray<any>
  ): any /* java.lang.Class */;
  allocateInstance(arg0: any /* java.lang.Class */): any;
  monitorEnter(arg0: any): void;
  monitorExit(arg0: any): void;
  tryMonitorEnter(arg0: any): boolean;
  throwException(arg0: any /* java.lang.Throwable */): void;
  compareAndSwapObject(arg0: any, arg1: number, arg2: any, arg3: any): boolean;
  compareAndSwapInt(
    arg0: any,
    arg1: number,
    arg2: number,
    arg3: number
  ): boolean;
  compareAndSwapLong(
    arg0: any,
    arg1: number,
    arg2: number,
    arg3: number
  ): boolean;
  getObjectVolatile(arg0: any, arg1: number): any;
  putObjectVolatile(arg0: any, arg1: number, arg2: any): void;
  getIntVolatile(arg0: any, arg1: number): number;
  putIntVolatile(arg0: any, arg1: number, arg2: number): void;
  getBooleanVolatile(arg0: any, arg1: number): boolean;
  putBooleanVolatile(arg0: any, arg1: number, arg2: boolean): void;
  getByteVolatile(arg0: any, arg1: number): Buffer;
  putByteVolatile(arg0: any, arg1: number, arg2: Buffer): void;
  getShortVolatile(arg0: any, arg1: number): unknown;
  putShortVolatile(arg0: any, arg1: number, arg2: unknown): void;
  getCharVolatile(arg0: any, arg1: number): string;
  putCharVolatile(arg0: any, arg1: number, arg2: string): void;
  getLongVolatile(arg0: any, arg1: number): number;
  putLongVolatile(arg0: any, arg1: number, arg2: number): void;
  getFloatVolatile(arg0: any, arg1: number): number;
  putFloatVolatile(arg0: any, arg1: number, arg2: number): void;
  getDoubleVolatile(arg0: any, arg1: number): number;
  putDoubleVolatile(arg0: any, arg1: number, arg2: number): void;
  putOrderedObject(arg0: any, arg1: number, arg2: any): void;
  putOrderedInt(arg0: any, arg1: number, arg2: number): void;
  putOrderedLong(arg0: any, arg1: number, arg2: number): void;
  unpark(arg0: any): void;
  park(arg0: boolean, arg1: number): void;
  getLoadAverage(arg0: JavaArray<number>, arg1: number): number;
  getAndAddInt(arg0: any, arg1: number, arg2: number): number;
  getAndAddLong(arg0: any, arg1: number, arg2: number): number;
  getAndSetInt(arg0: any, arg1: number, arg2: number): number;
  getAndSetLong(arg0: any, arg1: number, arg2: number): number;
  getAndSetObject(arg0: any, arg1: number, arg2: any): any;
  loadFence(): void;
  storeFence(): void;
  fullFence(): void;
}


declare interface $org$bukkit$Art extends $org$bukkit$Keyed {
  getBlockWidth(): number;
  getBlockHeight(): number;
  getId(): number;
  getKey(): org$bukkit$NamespacedKey;
}

declare class org$bukkit$Art implements $org$bukkit$Art {
  static KEBAB: org$bukkit$Art;
  static AZTEC: org$bukkit$Art;
  static ALBAN: org$bukkit$Art;
  static AZTEC2: org$bukkit$Art;
  static BOMB: org$bukkit$Art;
  static PLANT: org$bukkit$Art;
  static WASTELAND: org$bukkit$Art;
  static POOL: org$bukkit$Art;
  static COURBET: org$bukkit$Art;
  static SEA: org$bukkit$Art;
  static SUNSET: org$bukkit$Art;
  static CREEBET: org$bukkit$Art;
  static WANDERER: org$bukkit$Art;
  static GRAHAM: org$bukkit$Art;
  static MATCH: org$bukkit$Art;
  static BUST: org$bukkit$Art;
  static STAGE: org$bukkit$Art;
  static VOID: org$bukkit$Art;
  static SKULL_AND_ROSES: org$bukkit$Art;
  static WITHER: org$bukkit$Art;
  static FIGHTERS: org$bukkit$Art;
  static POINTER: org$bukkit$Art;
  static PIGSCENE: org$bukkit$Art;
  static BURNING_SKULL: org$bukkit$Art;
  static SKELETON: org$bukkit$Art;
  static DONKEY_KONG: org$bukkit$Art;
  static values(): JavaArray<org$bukkit$Art>;
  static valueOf(arg0: string): org$bukkit$Art;
  getBlockWidth(): number;
  getBlockHeight(): number;
  getId(): number;
  getKey(): org$bukkit$NamespacedKey;
  static getById(arg0: number): org$bukkit$Art;
  static getByName(arg0: string): org$bukkit$Art;
}


declare interface $org$bukkit$Axis {}

declare class org$bukkit$Axis implements $org$bukkit$Axis {
  static X: org$bukkit$Axis;
  static Y: org$bukkit$Axis;
  static Z: org$bukkit$Axis;
  static values(): JavaArray<org$bukkit$Axis>;
  static valueOf(arg0: string): org$bukkit$Axis;
}


declare interface $org$bukkit$block$Banner extends $org$bukkit$block$TileState {
  getBaseColor(): org$bukkit$DyeColor;
  setBaseColor(arg0: org$bukkit$DyeColor): void;
  getPatterns(): any /* java.util.List */;
  setPatterns(arg0: any /* java.util.List */): void;
  addPattern(arg0: org$bukkit$block$banner$Pattern): void;
  getPattern(arg0: number): org$bukkit$block$banner$Pattern;
  removePattern(arg0: number): org$bukkit$block$banner$Pattern;
  setPattern(arg0: number, arg1: org$bukkit$block$banner$Pattern): void;
  numberOfPatterns(): number;
}

declare class org$bukkit$block$Banner implements $org$bukkit$block$Banner {
  getBaseColor(): org$bukkit$DyeColor;
  setBaseColor(arg0: org$bukkit$DyeColor): void;
  getPatterns(): any /* java.util.List */;
  setPatterns(arg0: any /* java.util.List */): void;
  addPattern(arg0: org$bukkit$block$banner$Pattern): void;
  getPattern(arg0: number): org$bukkit$block$banner$Pattern;
  removePattern(arg0: number): org$bukkit$block$banner$Pattern;
  setPattern(arg0: number, arg1: org$bukkit$block$banner$Pattern): void;
  numberOfPatterns(): number;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$banner$Pattern
  extends $org$bukkit$configuration$serialization$ConfigurationSerializable {
  serialize(): any /* java.util.Map */;
  getColor(): org$bukkit$DyeColor;
  getPattern(): org$bukkit$block$banner$PatternType;
  hashCode(): number;
  equals(arg0: any): boolean;
}

declare class org$bukkit$block$banner$Pattern
  implements $org$bukkit$block$banner$Pattern {
  constructor(
    arg0: org$bukkit$DyeColor,
    arg1: org$bukkit$block$banner$PatternType
  );
  constructor(arg0: any /* java.util.Map */);
  serialize(): any /* java.util.Map */;
  getColor(): org$bukkit$DyeColor;
  getPattern(): org$bukkit$block$banner$PatternType;
  hashCode(): number;
  equals(arg0: any): boolean;
}


declare interface $org$bukkit$block$banner$PatternType {
  getIdentifier(): string;
}

declare class org$bukkit$block$banner$PatternType
  implements $org$bukkit$block$banner$PatternType {
  static BASE: org$bukkit$block$banner$PatternType;
  static SQUARE_BOTTOM_LEFT: org$bukkit$block$banner$PatternType;
  static SQUARE_BOTTOM_RIGHT: org$bukkit$block$banner$PatternType;
  static SQUARE_TOP_LEFT: org$bukkit$block$banner$PatternType;
  static SQUARE_TOP_RIGHT: org$bukkit$block$banner$PatternType;
  static STRIPE_BOTTOM: org$bukkit$block$banner$PatternType;
  static STRIPE_TOP: org$bukkit$block$banner$PatternType;
  static STRIPE_LEFT: org$bukkit$block$banner$PatternType;
  static STRIPE_RIGHT: org$bukkit$block$banner$PatternType;
  static STRIPE_CENTER: org$bukkit$block$banner$PatternType;
  static STRIPE_MIDDLE: org$bukkit$block$banner$PatternType;
  static STRIPE_DOWNRIGHT: org$bukkit$block$banner$PatternType;
  static STRIPE_DOWNLEFT: org$bukkit$block$banner$PatternType;
  static STRIPE_SMALL: org$bukkit$block$banner$PatternType;
  static CROSS: org$bukkit$block$banner$PatternType;
  static STRAIGHT_CROSS: org$bukkit$block$banner$PatternType;
  static TRIANGLE_BOTTOM: org$bukkit$block$banner$PatternType;
  static TRIANGLE_TOP: org$bukkit$block$banner$PatternType;
  static TRIANGLES_BOTTOM: org$bukkit$block$banner$PatternType;
  static TRIANGLES_TOP: org$bukkit$block$banner$PatternType;
  static DIAGONAL_LEFT: org$bukkit$block$banner$PatternType;
  static DIAGONAL_RIGHT: org$bukkit$block$banner$PatternType;
  static DIAGONAL_LEFT_MIRROR: org$bukkit$block$banner$PatternType;
  static DIAGONAL_RIGHT_MIRROR: org$bukkit$block$banner$PatternType;
  static CIRCLE_MIDDLE: org$bukkit$block$banner$PatternType;
  static RHOMBUS_MIDDLE: org$bukkit$block$banner$PatternType;
  static HALF_VERTICAL: org$bukkit$block$banner$PatternType;
  static HALF_HORIZONTAL: org$bukkit$block$banner$PatternType;
  static HALF_VERTICAL_MIRROR: org$bukkit$block$banner$PatternType;
  static HALF_HORIZONTAL_MIRROR: org$bukkit$block$banner$PatternType;
  static BORDER: org$bukkit$block$banner$PatternType;
  static CURLY_BORDER: org$bukkit$block$banner$PatternType;
  static CREEPER: org$bukkit$block$banner$PatternType;
  static GRADIENT: org$bukkit$block$banner$PatternType;
  static GRADIENT_UP: org$bukkit$block$banner$PatternType;
  static BRICKS: org$bukkit$block$banner$PatternType;
  static SKULL: org$bukkit$block$banner$PatternType;
  static FLOWER: org$bukkit$block$banner$PatternType;
  static MOJANG: org$bukkit$block$banner$PatternType;
  static GLOBE: org$bukkit$block$banner$PatternType;
  static values(): JavaArray<org$bukkit$block$banner$PatternType>;
  static valueOf(arg0: string): org$bukkit$block$banner$PatternType;
  getIdentifier(): string;
  static getByIdentifier(arg0: string): org$bukkit$block$banner$PatternType;
}


declare interface $org$bukkit$block$Barrel
  extends $org$bukkit$block$Container,
    $org$bukkit$loot$Lootable {}

declare class org$bukkit$block$Barrel implements $org$bukkit$block$Barrel {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Container
  extends $org$bukkit$block$TileState,
    $org$bukkit$inventory$BlockInventoryHolder,
    $org$bukkit$block$Lockable,
    $org$bukkit$Nameable {
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$block$Container
  implements $org$bukkit$block$Container {
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Lockable {
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
}

declare class org$bukkit$block$Lockable implements $org$bukkit$block$Lockable {
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
}


declare interface $org$bukkit$inventory$BlockInventoryHolder
  extends $org$bukkit$inventory$InventoryHolder {
  getBlock(): org$bukkit$block$Block;
}

declare class org$bukkit$inventory$BlockInventoryHolder
  implements $org$bukkit$inventory$BlockInventoryHolder {
  getBlock(): org$bukkit$block$Block;
  getInventory(): org$bukkit$inventory$Inventory;
}


declare interface $org$bukkit$block$Beacon
  extends $org$bukkit$block$TileState,
    $org$bukkit$block$Lockable,
    $org$bukkit$Nameable {
  getEntitiesInRange(): java$util$Collection;
  getTier(): number;
  getPrimaryEffect(): org$bukkit$potion$PotionEffect;
  setPrimaryEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getSecondaryEffect(): org$bukkit$potion$PotionEffect;
  setSecondaryEffect(arg0: org$bukkit$potion$PotionEffectType): void;
}

declare class org$bukkit$block$Beacon implements $org$bukkit$block$Beacon {
  getEntitiesInRange(): java$util$Collection;
  getTier(): number;
  getPrimaryEffect(): org$bukkit$potion$PotionEffect;
  setPrimaryEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getSecondaryEffect(): org$bukkit$potion$PotionEffect;
  setSecondaryEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Bed
  extends $org$bukkit$block$TileState,
    $org$bukkit$material$Colorable {}

declare class org$bukkit$block$Bed implements $org$bukkit$block$Bed {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Beehive
  extends $org$bukkit$block$EntityBlockStorage {
  getFlower(): org$bukkit$Location;
  setFlower(arg0: org$bukkit$Location): void;
  isSedated(): boolean;
}

declare class org$bukkit$block$Beehive implements $org$bukkit$block$Beehive {
  getFlower(): org$bukkit$Location;
  setFlower(arg0: org$bukkit$Location): void;
  isSedated(): boolean;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  isFull(): boolean;
  getEntityCount(): number;
  getMaxEntities(): number;
  setMaxEntities(arg0: number): void;
  releaseEntities(): any /* java.util.List */;
  addEntity(arg0: org$bukkit$entity$Entity): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$EntityBlockStorage
  extends $org$bukkit$block$TileState {
  isFull(): boolean;
  getEntityCount(): number;
  getMaxEntities(): number;
  setMaxEntities(arg0: number): void;
  releaseEntities(): any /* java.util.List */;
  addEntity(arg0: org$bukkit$entity$Entity): void;
}

declare class org$bukkit$block$EntityBlockStorage
  implements $org$bukkit$block$EntityBlockStorage {
  isFull(): boolean;
  getEntityCount(): number;
  getMaxEntities(): number;
  setMaxEntities(arg0: number): void;
  releaseEntities(): any /* java.util.List */;
  addEntity(arg0: org$bukkit$entity$Entity): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Bell extends $org$bukkit$block$TileState {}

declare class org$bukkit$block$Bell implements $org$bukkit$block$Bell {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$BlastFurnace
  extends $org$bukkit$block$Furnace {}

declare class org$bukkit$block$BlastFurnace
  implements $org$bukkit$block$BlastFurnace {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getBurnTime(): unknown;
  setBurnTime(arg0: unknown): void;
  getCookTime(): unknown;
  setCookTime(arg0: unknown): void;
  getCookTimeTotal(): number;
  setCookTimeTotal(arg0: number): void;
  getCookSpeedMultiplier(): number;
  setCookSpeedMultiplier(arg0: number): void;
  getInventory(): org$bukkit$inventory$FurnaceInventory;
  getSnapshotInventory(): org$bukkit$inventory$FurnaceInventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Furnace
  extends $org$bukkit$block$Container {
  getBurnTime(): unknown;
  setBurnTime(arg0: unknown): void;
  getCookTime(): unknown;
  setCookTime(arg0: unknown): void;
  getCookTimeTotal(): number;
  setCookTimeTotal(arg0: number): void;
  getCookSpeedMultiplier(): number;
  setCookSpeedMultiplier(arg0: number): void;
  getInventory(): org$bukkit$inventory$FurnaceInventory;
  getSnapshotInventory(): org$bukkit$inventory$FurnaceInventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$block$Furnace implements $org$bukkit$block$Furnace {
  getBurnTime(): unknown;
  setBurnTime(arg0: unknown): void;
  getCookTime(): unknown;
  setCookTime(arg0: unknown): void;
  getCookTimeTotal(): number;
  setCookTimeTotal(arg0: number): void;
  getCookSpeedMultiplier(): number;
  setCookSpeedMultiplier(arg0: number): void;
  getInventory(): org$bukkit$inventory$FurnaceInventory;
  getSnapshotInventory(): org$bukkit$inventory$FurnaceInventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$inventory$FurnaceInventory
  extends $org$bukkit$inventory$Inventory {
  getResult(): org$bukkit$inventory$ItemStack;
  getFuel(): org$bukkit$inventory$ItemStack;
  getSmelting(): org$bukkit$inventory$ItemStack;
  setFuel(arg0: org$bukkit$inventory$ItemStack): void;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  setSmelting(arg0: org$bukkit$inventory$ItemStack): void;
  getHolder(): org$bukkit$block$Furnace;
  getHolder(): org$bukkit$inventory$InventoryHolder;
}

declare class org$bukkit$inventory$FurnaceInventory
  implements $org$bukkit$inventory$FurnaceInventory {
  getResult(): org$bukkit$inventory$ItemStack;
  getFuel(): org$bukkit$inventory$ItemStack;
  getSmelting(): org$bukkit$inventory$ItemStack;
  setFuel(arg0: org$bukkit$inventory$ItemStack): void;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  setSmelting(arg0: org$bukkit$inventory$ItemStack): void;
  getHolder(): org$bukkit$block$Furnace;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$block$BlockFace$1 {}

declare class org$bukkit$block$BlockFace$1
  implements $org$bukkit$block$BlockFace$1 {}


declare interface $org$bukkit$block$BrewingStand
  extends $org$bukkit$block$Container {
  getBrewingTime(): number;
  setBrewingTime(arg0: number): void;
  getFuelLevel(): number;
  setFuelLevel(arg0: number): void;
  getInventory(): org$bukkit$inventory$BrewerInventory;
  getSnapshotInventory(): org$bukkit$inventory$BrewerInventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$block$BrewingStand
  implements $org$bukkit$block$BrewingStand {
  getBrewingTime(): number;
  setBrewingTime(arg0: number): void;
  getFuelLevel(): number;
  setFuelLevel(arg0: number): void;
  getInventory(): org$bukkit$inventory$BrewerInventory;
  getSnapshotInventory(): org$bukkit$inventory$BrewerInventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$inventory$BrewerInventory
  extends $org$bukkit$inventory$Inventory {
  getIngredient(): org$bukkit$inventory$ItemStack;
  setIngredient(arg0: org$bukkit$inventory$ItemStack): void;
  getFuel(): org$bukkit$inventory$ItemStack;
  setFuel(arg0: org$bukkit$inventory$ItemStack): void;
  getHolder(): org$bukkit$block$BrewingStand;
  getHolder(): org$bukkit$inventory$InventoryHolder;
}

declare class org$bukkit$inventory$BrewerInventory
  implements $org$bukkit$inventory$BrewerInventory {
  getIngredient(): org$bukkit$inventory$ItemStack;
  setIngredient(arg0: org$bukkit$inventory$ItemStack): void;
  getFuel(): org$bukkit$inventory$ItemStack;
  setFuel(arg0: org$bukkit$inventory$ItemStack): void;
  getHolder(): org$bukkit$block$BrewingStand;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$block$Campfire
  extends $org$bukkit$block$TileState {
  getSize(): number;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  getCookTime(arg0: number): number;
  setCookTime(arg0: number, arg1: number): void;
  getCookTimeTotal(arg0: number): number;
  setCookTimeTotal(arg0: number, arg1: number): void;
}

declare class org$bukkit$block$Campfire implements $org$bukkit$block$Campfire {
  getSize(): number;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  getCookTime(arg0: number): number;
  setCookTime(arg0: number, arg1: number): void;
  getCookTimeTotal(arg0: number): number;
  setCookTimeTotal(arg0: number, arg1: number): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Chest
  extends $org$bukkit$block$Container,
    $com$destroystokyo$paper$loottable$LootableBlockInventory {
  getBlockInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$block$Chest implements $org$bukkit$block$Chest {
  getBlockInventory(): org$bukkit$inventory$Inventory;
  getBlock(): org$bukkit$block$Block;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$CommandBlock
  extends $org$bukkit$block$TileState {
  getCommand(): string;
  setCommand(arg0: string): void;
  getName(): string;
  setName(arg0: string): void;
}

declare class org$bukkit$block$CommandBlock
  implements $org$bukkit$block$CommandBlock {
  getCommand(): string;
  setCommand(arg0: string): void;
  getName(): string;
  setName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Comparator
  extends $org$bukkit$block$TileState {}

declare class org$bukkit$block$Comparator
  implements $org$bukkit$block$Comparator {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Conduit
  extends $org$bukkit$block$TileState {}

declare class org$bukkit$block$Conduit implements $org$bukkit$block$Conduit {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$CreatureSpawner
  extends $org$bukkit$block$TileState {
  getSpawnedType(): org$bukkit$entity$EntityType;
  setSpawnedType(arg0: org$bukkit$entity$EntityType): void;
  setCreatureTypeByName(arg0: string): void;
  getCreatureTypeName(): string;
  getDelay(): number;
  setDelay(arg0: number): void;
  getMinSpawnDelay(): number;
  setMinSpawnDelay(arg0: number): void;
  getMaxSpawnDelay(): number;
  setMaxSpawnDelay(arg0: number): void;
  getSpawnCount(): number;
  setSpawnCount(arg0: number): void;
  getMaxNearbyEntities(): number;
  setMaxNearbyEntities(arg0: number): void;
  getRequiredPlayerRange(): number;
  setRequiredPlayerRange(arg0: number): void;
  getSpawnRange(): number;
  setSpawnRange(arg0: number): void;
  isActivated(): boolean;
  resetTimer(): void;
}

declare class org$bukkit$block$CreatureSpawner
  implements $org$bukkit$block$CreatureSpawner {
  getSpawnedType(): org$bukkit$entity$EntityType;
  setSpawnedType(arg0: org$bukkit$entity$EntityType): void;
  setCreatureTypeByName(arg0: string): void;
  getCreatureTypeName(): string;
  getDelay(): number;
  setDelay(arg0: number): void;
  getMinSpawnDelay(): number;
  setMinSpawnDelay(arg0: number): void;
  getMaxSpawnDelay(): number;
  setMaxSpawnDelay(arg0: number): void;
  getSpawnCount(): number;
  setSpawnCount(arg0: number): void;
  getMaxNearbyEntities(): number;
  setMaxNearbyEntities(arg0: number): void;
  getRequiredPlayerRange(): number;
  setRequiredPlayerRange(arg0: number): void;
  getSpawnRange(): number;
  setSpawnRange(arg0: number): void;
  isActivated(): boolean;
  resetTimer(): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$data$Ageable
  extends $org$bukkit$block$data$BlockData {
  getAge(): number;
  setAge(arg0: number): void;
  getMaximumAge(): number;
}

declare class org$bukkit$block$data$Ageable
  implements $org$bukkit$block$data$Ageable {
  getAge(): number;
  setAge(arg0: number): void;
  getMaximumAge(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$AnaloguePowerable
  extends $org$bukkit$block$data$BlockData {
  getPower(): number;
  setPower(arg0: number): void;
  getMaximumPower(): number;
}

declare class org$bukkit$block$data$AnaloguePowerable
  implements $org$bukkit$block$data$AnaloguePowerable {
  getPower(): number;
  setPower(arg0: number): void;
  getMaximumPower(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Attachable
  extends $org$bukkit$block$data$BlockData {
  isAttached(): boolean;
  setAttached(arg0: boolean): void;
}

declare class org$bukkit$block$data$Attachable
  implements $org$bukkit$block$data$Attachable {
  isAttached(): boolean;
  setAttached(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Bisected
  extends $org$bukkit$block$data$BlockData {
  getHalf(): org$bukkit$block$data$Bisected$Half;
  setHalf(arg0: org$bukkit$block$data$Bisected$Half): void;
}

declare class org$bukkit$block$data$Bisected
  implements $org$bukkit$block$data$Bisected {
  getHalf(): org$bukkit$block$data$Bisected$Half;
  setHalf(arg0: org$bukkit$block$data$Bisected$Half): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Bisected$Half {}

declare class org$bukkit$block$data$Bisected$Half
  implements $org$bukkit$block$data$Bisected$Half {
  static TOP: org$bukkit$block$data$Bisected$Half;
  static BOTTOM: org$bukkit$block$data$Bisected$Half;
  static values(): JavaArray<org$bukkit$block$data$Bisected$Half>;
  static valueOf(arg0: string): org$bukkit$block$data$Bisected$Half;
}


declare interface $org$bukkit$block$data$Directional
  extends $org$bukkit$block$data$BlockData {
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}

declare class org$bukkit$block$data$Directional
  implements $org$bukkit$block$data$Directional {
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$FaceAttachable
  extends $org$bukkit$block$data$BlockData {
  getAttachedFace(): org$bukkit$block$data$FaceAttachable$AttachedFace;
  setAttachedFace(
    arg0: org$bukkit$block$data$FaceAttachable$AttachedFace
  ): void;
}

declare class org$bukkit$block$data$FaceAttachable
  implements $org$bukkit$block$data$FaceAttachable {
  getAttachedFace(): org$bukkit$block$data$FaceAttachable$AttachedFace;
  setAttachedFace(
    arg0: org$bukkit$block$data$FaceAttachable$AttachedFace
  ): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$FaceAttachable$AttachedFace {}

declare class org$bukkit$block$data$FaceAttachable$AttachedFace
  implements $org$bukkit$block$data$FaceAttachable$AttachedFace {
  static FLOOR: org$bukkit$block$data$FaceAttachable$AttachedFace;
  static WALL: org$bukkit$block$data$FaceAttachable$AttachedFace;
  static CEILING: org$bukkit$block$data$FaceAttachable$AttachedFace;
  static values(): JavaArray<org$bukkit$block$data$FaceAttachable$AttachedFace>;
  static valueOf(
    arg0: string
  ): org$bukkit$block$data$FaceAttachable$AttachedFace;
}


declare interface $org$bukkit$block$data$Levelled
  extends $org$bukkit$block$data$BlockData {
  getLevel(): number;
  setLevel(arg0: number): void;
  getMaximumLevel(): number;
}

declare class org$bukkit$block$data$Levelled
  implements $org$bukkit$block$data$Levelled {
  getLevel(): number;
  setLevel(arg0: number): void;
  getMaximumLevel(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Lightable
  extends $org$bukkit$block$data$BlockData {
  isLit(): boolean;
  setLit(arg0: boolean): void;
}

declare class org$bukkit$block$data$Lightable
  implements $org$bukkit$block$data$Lightable {
  isLit(): boolean;
  setLit(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$MultipleFacing
  extends $org$bukkit$block$data$BlockData {
  hasFace(arg0: org$bukkit$block$BlockFace): boolean;
  setFace(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getFaces(): any /* java.util.Set */;
  getAllowedFaces(): any /* java.util.Set */;
}

declare class org$bukkit$block$data$MultipleFacing
  implements $org$bukkit$block$data$MultipleFacing {
  hasFace(arg0: org$bukkit$block$BlockFace): boolean;
  setFace(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getFaces(): any /* java.util.Set */;
  getAllowedFaces(): any /* java.util.Set */;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Openable
  extends $org$bukkit$block$data$BlockData {
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
}

declare class org$bukkit$block$data$Openable
  implements $org$bukkit$block$data$Openable {
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Orientable
  extends $org$bukkit$block$data$BlockData {
  getAxis(): org$bukkit$Axis;
  setAxis(arg0: org$bukkit$Axis): void;
  getAxes(): any /* java.util.Set */;
}

declare class org$bukkit$block$data$Orientable
  implements $org$bukkit$block$data$Orientable {
  getAxis(): org$bukkit$Axis;
  setAxis(arg0: org$bukkit$Axis): void;
  getAxes(): any /* java.util.Set */;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Powerable
  extends $org$bukkit$block$data$BlockData {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}

declare class org$bukkit$block$data$Powerable
  implements $org$bukkit$block$data$Powerable {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Rail
  extends $org$bukkit$block$data$BlockData {
  getShape(): org$bukkit$block$data$Rail$Shape;
  setShape(arg0: org$bukkit$block$data$Rail$Shape): void;
  getShapes(): any /* java.util.Set */;
}

declare class org$bukkit$block$data$Rail
  implements $org$bukkit$block$data$Rail {
  getShape(): org$bukkit$block$data$Rail$Shape;
  setShape(arg0: org$bukkit$block$data$Rail$Shape): void;
  getShapes(): any /* java.util.Set */;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Rail$Shape {}

declare class org$bukkit$block$data$Rail$Shape
  implements $org$bukkit$block$data$Rail$Shape {
  static NORTH_SOUTH: org$bukkit$block$data$Rail$Shape;
  static EAST_WEST: org$bukkit$block$data$Rail$Shape;
  static ASCENDING_EAST: org$bukkit$block$data$Rail$Shape;
  static ASCENDING_WEST: org$bukkit$block$data$Rail$Shape;
  static ASCENDING_NORTH: org$bukkit$block$data$Rail$Shape;
  static ASCENDING_SOUTH: org$bukkit$block$data$Rail$Shape;
  static SOUTH_EAST: org$bukkit$block$data$Rail$Shape;
  static SOUTH_WEST: org$bukkit$block$data$Rail$Shape;
  static NORTH_WEST: org$bukkit$block$data$Rail$Shape;
  static NORTH_EAST: org$bukkit$block$data$Rail$Shape;
  static values(): JavaArray<org$bukkit$block$data$Rail$Shape>;
  static valueOf(arg0: string): org$bukkit$block$data$Rail$Shape;
}


declare interface $org$bukkit$block$data$Rotatable
  extends $org$bukkit$block$data$BlockData {
  getRotation(): org$bukkit$block$BlockFace;
  setRotation(arg0: org$bukkit$block$BlockFace): void;
}

declare class org$bukkit$block$data$Rotatable
  implements $org$bukkit$block$data$Rotatable {
  getRotation(): org$bukkit$block$BlockFace;
  setRotation(arg0: org$bukkit$block$BlockFace): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$Snowable
  extends $org$bukkit$block$data$BlockData {
  isSnowy(): boolean;
  setSnowy(arg0: boolean): void;
}

declare class org$bukkit$block$data$Snowable
  implements $org$bukkit$block$data$Snowable {
  isSnowy(): boolean;
  setSnowy(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Bamboo
  extends $org$bukkit$block$data$Ageable,
    $org$bukkit$block$data$type$Sapling {
  getLeaves(): org$bukkit$block$data$type$Bamboo$Leaves;
  setLeaves(arg0: org$bukkit$block$data$type$Bamboo$Leaves): void;
}

declare class org$bukkit$block$data$type$Bamboo
  implements $org$bukkit$block$data$type$Bamboo {
  getLeaves(): org$bukkit$block$data$type$Bamboo$Leaves;
  setLeaves(arg0: org$bukkit$block$data$type$Bamboo$Leaves): void;
  getAge(): number;
  setAge(arg0: number): void;
  getMaximumAge(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getStage(): number;
  setStage(arg0: number): void;
  getMaximumStage(): number;
}


declare interface $org$bukkit$block$data$type$Sapling
  extends $org$bukkit$block$data$BlockData {
  getStage(): number;
  setStage(arg0: number): void;
  getMaximumStage(): number;
}

declare class org$bukkit$block$data$type$Sapling
  implements $org$bukkit$block$data$type$Sapling {
  getStage(): number;
  setStage(arg0: number): void;
  getMaximumStage(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Bamboo$Leaves {}

declare class org$bukkit$block$data$type$Bamboo$Leaves
  implements $org$bukkit$block$data$type$Bamboo$Leaves {
  static NONE: org$bukkit$block$data$type$Bamboo$Leaves;
  static SMALL: org$bukkit$block$data$type$Bamboo$Leaves;
  static LARGE: org$bukkit$block$data$type$Bamboo$Leaves;
  static values(): JavaArray<org$bukkit$block$data$type$Bamboo$Leaves>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Bamboo$Leaves;
}


declare interface $org$bukkit$block$data$type$Bed
  extends $org$bukkit$block$data$Directional {
  getPart(): org$bukkit$block$data$type$Bed$Part;
  setPart(arg0: org$bukkit$block$data$type$Bed$Part): void;
  isOccupied(): boolean;
}

declare class org$bukkit$block$data$type$Bed
  implements $org$bukkit$block$data$type$Bed {
  getPart(): org$bukkit$block$data$type$Bed$Part;
  setPart(arg0: org$bukkit$block$data$type$Bed$Part): void;
  isOccupied(): boolean;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Bed$Part {}

declare class org$bukkit$block$data$type$Bed$Part
  implements $org$bukkit$block$data$type$Bed$Part {
  static HEAD: org$bukkit$block$data$type$Bed$Part;
  static FOOT: org$bukkit$block$data$type$Bed$Part;
  static values(): JavaArray<org$bukkit$block$data$type$Bed$Part>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Bed$Part;
}


declare interface $org$bukkit$block$data$type$Beehive
  extends $org$bukkit$block$data$Directional {
  getHoneyLevel(): number;
  setHoneyLevel(arg0: number): void;
  getMaximumHoneyLevel(): number;
}

declare class org$bukkit$block$data$type$Beehive
  implements $org$bukkit$block$data$type$Beehive {
  getHoneyLevel(): number;
  setHoneyLevel(arg0: number): void;
  getMaximumHoneyLevel(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Bell
  extends $org$bukkit$block$data$Directional {
  getAttachment(): org$bukkit$block$data$type$Bell$Attachment;
  setAttachment(arg0: org$bukkit$block$data$type$Bell$Attachment): void;
}

declare class org$bukkit$block$data$type$Bell
  implements $org$bukkit$block$data$type$Bell {
  getAttachment(): org$bukkit$block$data$type$Bell$Attachment;
  setAttachment(arg0: org$bukkit$block$data$type$Bell$Attachment): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Bell$Attachment {}

declare class org$bukkit$block$data$type$Bell$Attachment
  implements $org$bukkit$block$data$type$Bell$Attachment {
  static FLOOR: org$bukkit$block$data$type$Bell$Attachment;
  static CEILING: org$bukkit$block$data$type$Bell$Attachment;
  static SINGLE_WALL: org$bukkit$block$data$type$Bell$Attachment;
  static DOUBLE_WALL: org$bukkit$block$data$type$Bell$Attachment;
  static values(): JavaArray<org$bukkit$block$data$type$Bell$Attachment>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Bell$Attachment;
}


declare interface $org$bukkit$block$data$type$BrewingStand
  extends $org$bukkit$block$data$BlockData {
  hasBottle(arg0: number): boolean;
  setBottle(arg0: number, arg1: boolean): void;
  getBottles(): any /* java.util.Set */;
  getMaximumBottles(): number;
}

declare class org$bukkit$block$data$type$BrewingStand
  implements $org$bukkit$block$data$type$BrewingStand {
  hasBottle(arg0: number): boolean;
  setBottle(arg0: number, arg1: boolean): void;
  getBottles(): any /* java.util.Set */;
  getMaximumBottles(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$BubbleColumn
  extends $org$bukkit$block$data$BlockData {
  isDrag(): boolean;
  setDrag(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$BubbleColumn
  implements $org$bukkit$block$data$type$BubbleColumn {
  isDrag(): boolean;
  setDrag(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Cake
  extends $org$bukkit$block$data$BlockData {
  getBites(): number;
  setBites(arg0: number): void;
  getMaximumBites(): number;
}

declare class org$bukkit$block$data$type$Cake
  implements $org$bukkit$block$data$type$Cake {
  getBites(): number;
  setBites(arg0: number): void;
  getMaximumBites(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Campfire
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Lightable,
    $org$bukkit$block$data$Waterlogged {
  isSignalFire(): boolean;
  setSignalFire(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Campfire
  implements $org$bukkit$block$data$type$Campfire {
  isSignalFire(): boolean;
  setSignalFire(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isLit(): boolean;
  setLit(arg0: boolean): void;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$Waterlogged
  extends $org$bukkit$block$data$BlockData {
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}

declare class org$bukkit$block$data$Waterlogged
  implements $org$bukkit$block$data$Waterlogged {
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Chest
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Waterlogged {
  getType(): org$bukkit$block$data$type$Chest$Type;
  setType(arg0: org$bukkit$block$data$type$Chest$Type): void;
}

declare class org$bukkit$block$data$type$Chest
  implements $org$bukkit$block$data$type$Chest {
  getType(): org$bukkit$block$data$type$Chest$Type;
  setType(arg0: org$bukkit$block$data$type$Chest$Type): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Chest$Type {}

declare class org$bukkit$block$data$type$Chest$Type
  implements $org$bukkit$block$data$type$Chest$Type {
  static SINGLE: org$bukkit$block$data$type$Chest$Type;
  static LEFT: org$bukkit$block$data$type$Chest$Type;
  static RIGHT: org$bukkit$block$data$type$Chest$Type;
  static values(): JavaArray<org$bukkit$block$data$type$Chest$Type>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Chest$Type;
}


declare interface $org$bukkit$block$data$type$Cocoa
  extends $org$bukkit$block$data$Ageable,
    $org$bukkit$block$data$Directional {}

declare class org$bukkit$block$data$type$Cocoa
  implements $org$bukkit$block$data$type$Cocoa {
  getAge(): number;
  setAge(arg0: number): void;
  getMaximumAge(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$CommandBlock
  extends $org$bukkit$block$data$Directional {
  isConditional(): boolean;
  setConditional(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$CommandBlock
  implements $org$bukkit$block$data$type$CommandBlock {
  isConditional(): boolean;
  setConditional(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Comparator
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Powerable {
  getMode(): org$bukkit$block$data$type$Comparator$Mode;
  setMode(arg0: org$bukkit$block$data$type$Comparator$Mode): void;
}

declare class org$bukkit$block$data$type$Comparator
  implements $org$bukkit$block$data$type$Comparator {
  getMode(): org$bukkit$block$data$type$Comparator$Mode;
  setMode(arg0: org$bukkit$block$data$type$Comparator$Mode): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Comparator$Mode {}

declare class org$bukkit$block$data$type$Comparator$Mode
  implements $org$bukkit$block$data$type$Comparator$Mode {
  static COMPARE: org$bukkit$block$data$type$Comparator$Mode;
  static SUBTRACT: org$bukkit$block$data$type$Comparator$Mode;
  static values(): JavaArray<org$bukkit$block$data$type$Comparator$Mode>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Comparator$Mode;
}


declare interface $org$bukkit$block$data$type$CoralWallFan
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$CoralWallFan
  implements $org$bukkit$block$data$type$CoralWallFan {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$DaylightDetector
  extends $org$bukkit$block$data$AnaloguePowerable {
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$DaylightDetector
  implements $org$bukkit$block$data$type$DaylightDetector {
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  getPower(): number;
  setPower(arg0: number): void;
  getMaximumPower(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Dispenser
  extends $org$bukkit$block$data$Directional {
  isTriggered(): boolean;
  setTriggered(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Dispenser
  implements $org$bukkit$block$data$type$Dispenser {
  isTriggered(): boolean;
  setTriggered(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Door
  extends $org$bukkit$block$data$Bisected,
    $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Openable,
    $org$bukkit$block$data$Powerable {
  getHinge(): org$bukkit$block$data$type$Door$Hinge;
  setHinge(arg0: org$bukkit$block$data$type$Door$Hinge): void;
}

declare class org$bukkit$block$data$type$Door
  implements $org$bukkit$block$data$type$Door {
  getHinge(): org$bukkit$block$data$type$Door$Hinge;
  setHinge(arg0: org$bukkit$block$data$type$Door$Hinge): void;
  getHalf(): org$bukkit$block$data$Bisected$Half;
  setHalf(arg0: org$bukkit$block$data$Bisected$Half): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Door$Hinge {}

declare class org$bukkit$block$data$type$Door$Hinge
  implements $org$bukkit$block$data$type$Door$Hinge {
  static LEFT: org$bukkit$block$data$type$Door$Hinge;
  static RIGHT: org$bukkit$block$data$type$Door$Hinge;
  static values(): JavaArray<org$bukkit$block$data$type$Door$Hinge>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Door$Hinge;
}


declare interface $org$bukkit$block$data$type$EnderChest
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$EnderChest
  implements $org$bukkit$block$data$type$EnderChest {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$EndPortalFrame
  extends $org$bukkit$block$data$Directional {
  hasEye(): boolean;
  setEye(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$EndPortalFrame
  implements $org$bukkit$block$data$type$EndPortalFrame {
  hasEye(): boolean;
  setEye(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Farmland
  extends $org$bukkit$block$data$BlockData {
  getMoisture(): number;
  setMoisture(arg0: number): void;
  getMaximumMoisture(): number;
}

declare class org$bukkit$block$data$type$Farmland
  implements $org$bukkit$block$data$type$Farmland {
  getMoisture(): number;
  setMoisture(arg0: number): void;
  getMaximumMoisture(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Fence
  extends $org$bukkit$block$data$MultipleFacing,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$Fence
  implements $org$bukkit$block$data$type$Fence {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  hasFace(arg0: org$bukkit$block$BlockFace): boolean;
  setFace(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getFaces(): any /* java.util.Set */;
  getAllowedFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Fire
  extends $org$bukkit$block$data$Ageable,
    $org$bukkit$block$data$MultipleFacing {}

declare class org$bukkit$block$data$type$Fire
  implements $org$bukkit$block$data$type$Fire {
  getAge(): number;
  setAge(arg0: number): void;
  getMaximumAge(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  hasFace(arg0: org$bukkit$block$BlockFace): boolean;
  setFace(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getFaces(): any /* java.util.Set */;
  getAllowedFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Furnace
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Lightable {}

declare class org$bukkit$block$data$type$Furnace
  implements $org$bukkit$block$data$type$Furnace {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isLit(): boolean;
  setLit(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Gate
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Openable,
    $org$bukkit$block$data$Powerable {
  isInWall(): boolean;
  setInWall(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Gate
  implements $org$bukkit$block$data$type$Gate {
  isInWall(): boolean;
  setInWall(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$GlassPane
  extends $org$bukkit$block$data$MultipleFacing,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$GlassPane
  implements $org$bukkit$block$data$type$GlassPane {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  hasFace(arg0: org$bukkit$block$BlockFace): boolean;
  setFace(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getFaces(): any /* java.util.Set */;
  getAllowedFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Grindstone
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$FaceAttachable {}

declare class org$bukkit$block$data$type$Grindstone
  implements $org$bukkit$block$data$type$Grindstone {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  getAttachedFace(): org$bukkit$block$data$FaceAttachable$AttachedFace;
  setAttachedFace(
    arg0: org$bukkit$block$data$FaceAttachable$AttachedFace
  ): void;
}


declare interface $org$bukkit$block$data$type$Hopper
  extends $org$bukkit$block$data$Directional {
  isEnabled(): boolean;
  setEnabled(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Hopper
  implements $org$bukkit$block$data$type$Hopper {
  isEnabled(): boolean;
  setEnabled(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$Jukebox
  extends $org$bukkit$block$data$BlockData {
  hasRecord(): boolean;
}

declare class org$bukkit$block$data$type$Jukebox
  implements $org$bukkit$block$data$type$Jukebox {
  hasRecord(): boolean;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Ladder
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$Ladder
  implements $org$bukkit$block$data$type$Ladder {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Lantern
  extends $org$bukkit$block$data$BlockData {
  isHanging(): boolean;
  setHanging(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Lantern
  implements $org$bukkit$block$data$type$Lantern {
  isHanging(): boolean;
  setHanging(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Leaves
  extends $org$bukkit$block$data$BlockData {
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getDistance(): number;
  setDistance(arg0: number): void;
}

declare class org$bukkit$block$data$type$Leaves
  implements $org$bukkit$block$data$type$Leaves {
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getDistance(): number;
  setDistance(arg0: number): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Lectern
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Powerable {
  hasBook(): boolean;
}

declare class org$bukkit$block$data$type$Lectern
  implements $org$bukkit$block$data$type$Lectern {
  hasBook(): boolean;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$NoteBlock
  extends $org$bukkit$block$data$Powerable {
  getInstrument(): org$bukkit$Instrument;
  setInstrument(arg0: org$bukkit$Instrument): void;
  getNote(): org$bukkit$Note;
  setNote(arg0: org$bukkit$Note): void;
}

declare class org$bukkit$block$data$type$NoteBlock
  implements $org$bukkit$block$data$type$NoteBlock {
  getInstrument(): org$bukkit$Instrument;
  setInstrument(arg0: org$bukkit$Instrument): void;
  getNote(): org$bukkit$Note;
  setNote(arg0: org$bukkit$Note): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Observer
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Powerable {}

declare class org$bukkit$block$data$type$Observer
  implements $org$bukkit$block$data$type$Observer {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Piston
  extends $org$bukkit$block$data$Directional {
  isExtended(): boolean;
  setExtended(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Piston
  implements $org$bukkit$block$data$type$Piston {
  isExtended(): boolean;
  setExtended(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$PistonHead
  extends $org$bukkit$block$data$type$TechnicalPiston {
  isShort(): boolean;
  setShort(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$PistonHead
  implements $org$bukkit$block$data$type$PistonHead {
  isShort(): boolean;
  setShort(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  getType(): org$bukkit$block$data$type$TechnicalPiston$Type;
  setType(arg0: org$bukkit$block$data$type$TechnicalPiston$Type): void;
}


declare interface $org$bukkit$block$data$type$TechnicalPiston
  extends $org$bukkit$block$data$Directional {
  getType(): org$bukkit$block$data$type$TechnicalPiston$Type;
  setType(arg0: org$bukkit$block$data$type$TechnicalPiston$Type): void;
}

declare class org$bukkit$block$data$type$TechnicalPiston
  implements $org$bukkit$block$data$type$TechnicalPiston {
  getType(): org$bukkit$block$data$type$TechnicalPiston$Type;
  setType(arg0: org$bukkit$block$data$type$TechnicalPiston$Type): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$TechnicalPiston$Type {}

declare class org$bukkit$block$data$type$TechnicalPiston$Type
  implements $org$bukkit$block$data$type$TechnicalPiston$Type {
  static NORMAL: org$bukkit$block$data$type$TechnicalPiston$Type;
  static STICKY: org$bukkit$block$data$type$TechnicalPiston$Type;
  static values(): JavaArray<org$bukkit$block$data$type$TechnicalPiston$Type>;
  static valueOf(arg0: string): org$bukkit$block$data$type$TechnicalPiston$Type;
}


declare interface $org$bukkit$block$data$type$RedstoneRail
  extends $org$bukkit$block$data$Powerable,
    $org$bukkit$block$data$Rail {}

declare class org$bukkit$block$data$type$RedstoneRail
  implements $org$bukkit$block$data$type$RedstoneRail {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  getShape(): org$bukkit$block$data$Rail$Shape;
  setShape(arg0: org$bukkit$block$data$Rail$Shape): void;
  getShapes(): any /* java.util.Set */;
}


declare interface $org$bukkit$block$data$type$RedstoneWallTorch
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Lightable {}

declare class org$bukkit$block$data$type$RedstoneWallTorch
  implements $org$bukkit$block$data$type$RedstoneWallTorch {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isLit(): boolean;
  setLit(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$RedstoneWire
  extends $org$bukkit$block$data$AnaloguePowerable {
  getFace(
    arg0: org$bukkit$block$BlockFace
  ): org$bukkit$block$data$type$RedstoneWire$Connection;
  setFace(
    arg0: org$bukkit$block$BlockFace,
    arg1: org$bukkit$block$data$type$RedstoneWire$Connection
  ): void;
  getAllowedFaces(): any /* java.util.Set */;
}

declare class org$bukkit$block$data$type$RedstoneWire
  implements $org$bukkit$block$data$type$RedstoneWire {
  getFace(
    arg0: org$bukkit$block$BlockFace
  ): org$bukkit$block$data$type$RedstoneWire$Connection;
  setFace(
    arg0: org$bukkit$block$BlockFace,
    arg1: org$bukkit$block$data$type$RedstoneWire$Connection
  ): void;
  getAllowedFaces(): any /* java.util.Set */;
  getPower(): number;
  setPower(arg0: number): void;
  getMaximumPower(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$RedstoneWire$Connection {}

declare class org$bukkit$block$data$type$RedstoneWire$Connection
  implements $org$bukkit$block$data$type$RedstoneWire$Connection {
  static UP: org$bukkit$block$data$type$RedstoneWire$Connection;
  static SIDE: org$bukkit$block$data$type$RedstoneWire$Connection;
  static NONE: org$bukkit$block$data$type$RedstoneWire$Connection;
  static values(): JavaArray<
    org$bukkit$block$data$type$RedstoneWire$Connection
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$block$data$type$RedstoneWire$Connection;
}


declare interface $org$bukkit$block$data$type$Repeater
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Powerable {
  getDelay(): number;
  setDelay(arg0: number): void;
  getMinimumDelay(): number;
  getMaximumDelay(): number;
  isLocked(): boolean;
  setLocked(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Repeater
  implements $org$bukkit$block$data$type$Repeater {
  getDelay(): number;
  setDelay(arg0: number): void;
  getMinimumDelay(): number;
  getMaximumDelay(): number;
  isLocked(): boolean;
  setLocked(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Scaffolding
  extends $org$bukkit$block$data$Waterlogged {
  isBottom(): boolean;
  setBottom(arg0: boolean): void;
  getDistance(): number;
  setDistance(arg0: number): void;
  getMaximumDistance(): number;
}

declare class org$bukkit$block$data$type$Scaffolding
  implements $org$bukkit$block$data$type$Scaffolding {
  isBottom(): boolean;
  setBottom(arg0: boolean): void;
  getDistance(): number;
  setDistance(arg0: number): void;
  getMaximumDistance(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$SeaPickle
  extends $org$bukkit$block$data$Waterlogged {
  getPickles(): number;
  setPickles(arg0: number): void;
  getMinimumPickles(): number;
  getMaximumPickles(): number;
}

declare class org$bukkit$block$data$type$SeaPickle
  implements $org$bukkit$block$data$type$SeaPickle {
  getPickles(): number;
  setPickles(arg0: number): void;
  getMinimumPickles(): number;
  getMaximumPickles(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Sign
  extends $org$bukkit$block$data$Rotatable,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$Sign
  implements $org$bukkit$block$data$type$Sign {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getRotation(): org$bukkit$block$BlockFace;
  setRotation(arg0: org$bukkit$block$BlockFace): void;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Slab
  extends $org$bukkit$block$data$Waterlogged {
  getType(): org$bukkit$block$data$type$Slab$Type;
  setType(arg0: org$bukkit$block$data$type$Slab$Type): void;
}

declare class org$bukkit$block$data$type$Slab
  implements $org$bukkit$block$data$type$Slab {
  getType(): org$bukkit$block$data$type$Slab$Type;
  setType(arg0: org$bukkit$block$data$type$Slab$Type): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Slab$Type {}

declare class org$bukkit$block$data$type$Slab$Type
  implements $org$bukkit$block$data$type$Slab$Type {
  static TOP: org$bukkit$block$data$type$Slab$Type;
  static BOTTOM: org$bukkit$block$data$type$Slab$Type;
  static DOUBLE: org$bukkit$block$data$type$Slab$Type;
  static values(): JavaArray<org$bukkit$block$data$type$Slab$Type>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Slab$Type;
}


declare interface $org$bukkit$block$data$type$Snow
  extends $org$bukkit$block$data$BlockData {
  getLayers(): number;
  setLayers(arg0: number): void;
  getMinimumLayers(): number;
  getMaximumLayers(): number;
}

declare class org$bukkit$block$data$type$Snow
  implements $org$bukkit$block$data$type$Snow {
  getLayers(): number;
  setLayers(arg0: number): void;
  getMinimumLayers(): number;
  getMaximumLayers(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$Stairs
  extends $org$bukkit$block$data$Bisected,
    $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Waterlogged {
  getShape(): org$bukkit$block$data$type$Stairs$Shape;
  setShape(arg0: org$bukkit$block$data$type$Stairs$Shape): void;
}

declare class org$bukkit$block$data$type$Stairs
  implements $org$bukkit$block$data$type$Stairs {
  getShape(): org$bukkit$block$data$type$Stairs$Shape;
  setShape(arg0: org$bukkit$block$data$type$Stairs$Shape): void;
  getHalf(): org$bukkit$block$data$Bisected$Half;
  setHalf(arg0: org$bukkit$block$data$Bisected$Half): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Stairs$Shape {}

declare class org$bukkit$block$data$type$Stairs$Shape
  implements $org$bukkit$block$data$type$Stairs$Shape {
  static STRAIGHT: org$bukkit$block$data$type$Stairs$Shape;
  static INNER_LEFT: org$bukkit$block$data$type$Stairs$Shape;
  static INNER_RIGHT: org$bukkit$block$data$type$Stairs$Shape;
  static OUTER_LEFT: org$bukkit$block$data$type$Stairs$Shape;
  static OUTER_RIGHT: org$bukkit$block$data$type$Stairs$Shape;
  static values(): JavaArray<org$bukkit$block$data$type$Stairs$Shape>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Stairs$Shape;
}


declare interface $org$bukkit$block$data$type$StructureBlock
  extends $org$bukkit$block$data$BlockData {
  getMode(): org$bukkit$block$data$type$StructureBlock$Mode;
  setMode(arg0: org$bukkit$block$data$type$StructureBlock$Mode): void;
}

declare class org$bukkit$block$data$type$StructureBlock
  implements $org$bukkit$block$data$type$StructureBlock {
  getMode(): org$bukkit$block$data$type$StructureBlock$Mode;
  setMode(arg0: org$bukkit$block$data$type$StructureBlock$Mode): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$StructureBlock$Mode {}

declare class org$bukkit$block$data$type$StructureBlock$Mode
  implements $org$bukkit$block$data$type$StructureBlock$Mode {
  static SAVE: org$bukkit$block$data$type$StructureBlock$Mode;
  static LOAD: org$bukkit$block$data$type$StructureBlock$Mode;
  static CORNER: org$bukkit$block$data$type$StructureBlock$Mode;
  static DATA: org$bukkit$block$data$type$StructureBlock$Mode;
  static values(): JavaArray<org$bukkit$block$data$type$StructureBlock$Mode>;
  static valueOf(arg0: string): org$bukkit$block$data$type$StructureBlock$Mode;
}


declare interface $org$bukkit$block$data$type$Switch
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$FaceAttachable,
    $org$bukkit$block$data$Powerable {
  getFace(): org$bukkit$block$data$type$Switch$Face;
  setFace(arg0: org$bukkit$block$data$type$Switch$Face): void;
}

declare class org$bukkit$block$data$type$Switch
  implements $org$bukkit$block$data$type$Switch {
  getFace(): org$bukkit$block$data$type$Switch$Face;
  setFace(arg0: org$bukkit$block$data$type$Switch$Face): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  getAttachedFace(): org$bukkit$block$data$FaceAttachable$AttachedFace;
  setAttachedFace(
    arg0: org$bukkit$block$data$FaceAttachable$AttachedFace
  ): void;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Switch$Face {}

declare class org$bukkit$block$data$type$Switch$Face
  implements $org$bukkit$block$data$type$Switch$Face {
  static FLOOR: org$bukkit$block$data$type$Switch$Face;
  static WALL: org$bukkit$block$data$type$Switch$Face;
  static CEILING: org$bukkit$block$data$type$Switch$Face;
  static values(): JavaArray<org$bukkit$block$data$type$Switch$Face>;
  static valueOf(arg0: string): org$bukkit$block$data$type$Switch$Face;
}


declare interface $org$bukkit$block$data$type$TNT
  extends $org$bukkit$block$data$BlockData {
  isUnstable(): boolean;
  setUnstable(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$TNT
  implements $org$bukkit$block$data$type$TNT {
  isUnstable(): boolean;
  setUnstable(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$TrapDoor
  extends $org$bukkit$block$data$Bisected,
    $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Openable,
    $org$bukkit$block$data$Powerable,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$TrapDoor
  implements $org$bukkit$block$data$type$TrapDoor {
  getHalf(): org$bukkit$block$data$Bisected$Half;
  setHalf(arg0: org$bukkit$block$data$Bisected$Half): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$Tripwire
  extends $org$bukkit$block$data$Attachable,
    $org$bukkit$block$data$MultipleFacing,
    $org$bukkit$block$data$Powerable {
  isDisarmed(): boolean;
  setDisarmed(arg0: boolean): void;
}

declare class org$bukkit$block$data$type$Tripwire
  implements $org$bukkit$block$data$type$Tripwire {
  isDisarmed(): boolean;
  setDisarmed(arg0: boolean): void;
  isAttached(): boolean;
  setAttached(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  hasFace(arg0: org$bukkit$block$BlockFace): boolean;
  setFace(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getFaces(): any /* java.util.Set */;
  getAllowedFaces(): any /* java.util.Set */;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$TripwireHook
  extends $org$bukkit$block$data$Attachable,
    $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Powerable {}

declare class org$bukkit$block$data$type$TripwireHook
  implements $org$bukkit$block$data$type$TripwireHook {
  isAttached(): boolean;
  setAttached(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
}


declare interface $org$bukkit$block$data$type$TurtleEgg
  extends $org$bukkit$block$data$BlockData {
  getEggs(): number;
  setEggs(arg0: number): void;
  getMinimumEggs(): number;
  getMaximumEggs(): number;
  getHatch(): number;
  setHatch(arg0: number): void;
  getMaximumHatch(): number;
}

declare class org$bukkit$block$data$type$TurtleEgg
  implements $org$bukkit$block$data$type$TurtleEgg {
  getEggs(): number;
  setEggs(arg0: number): void;
  getMinimumEggs(): number;
  getMaximumEggs(): number;
  getHatch(): number;
  setHatch(arg0: number): void;
  getMaximumHatch(): number;
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
}


declare interface $org$bukkit$block$data$type$WallSign
  extends $org$bukkit$block$data$Directional,
    $org$bukkit$block$data$Waterlogged {}

declare class org$bukkit$block$data$type$WallSign
  implements $org$bukkit$block$data$type$WallSign {
  getMaterial(): org$bukkit$Material;
  getAsString(): string;
  getAsString(arg0: boolean): string;
  merge(arg0: org$bukkit$block$data$BlockData): org$bukkit$block$data$BlockData;
  matches(arg0: org$bukkit$block$data$BlockData): boolean;
  clone(): org$bukkit$block$data$BlockData;
  getFacing(): org$bukkit$block$BlockFace;
  setFacing(arg0: org$bukkit$block$BlockFace): void;
  getFaces(): any /* java.util.Set */;
  isWaterlogged(): boolean;
  setWaterlogged(arg0: boolean): void;
}


declare interface $org$bukkit$block$DaylightDetector
  extends $org$bukkit$block$TileState {}

declare class org$bukkit$block$DaylightDetector
  implements $org$bukkit$block$DaylightDetector {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Dispenser
  extends $org$bukkit$block$Container,
    $org$bukkit$Nameable,
    $com$destroystokyo$paper$loottable$LootableBlockInventory {
  getBlockProjectileSource(): org$bukkit$projectiles$BlockProjectileSource;
  dispense(): boolean;
}

declare class org$bukkit$block$Dispenser
  implements $org$bukkit$block$Dispenser {
  getBlockProjectileSource(): org$bukkit$projectiles$BlockProjectileSource;
  dispense(): boolean;
  getBlock(): org$bukkit$block$Block;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$projectiles$BlockProjectileSource
  extends $org$bukkit$projectiles$ProjectileSource {
  getBlock(): org$bukkit$block$Block;
}

declare class org$bukkit$projectiles$BlockProjectileSource
  implements $org$bukkit$projectiles$BlockProjectileSource {
  getBlock(): org$bukkit$block$Block;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$block$DoubleChest
  extends $org$bukkit$inventory$InventoryHolder {
  getInventory(): org$bukkit$inventory$Inventory;
  getLeftSide(): org$bukkit$inventory$InventoryHolder;
  getRightSide(): org$bukkit$inventory$InventoryHolder;
  getLeftSide(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  getRightSide(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  getLocation(): org$bukkit$Location;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
}

declare class org$bukkit$block$DoubleChest
  implements $org$bukkit$block$DoubleChest {
  constructor(arg0: org$bukkit$inventory$DoubleChestInventory);
  getInventory(): org$bukkit$inventory$Inventory;
  getLeftSide(): org$bukkit$inventory$InventoryHolder;
  getRightSide(): org$bukkit$inventory$InventoryHolder;
  getLeftSide(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  getRightSide(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  getLocation(): org$bukkit$Location;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
}


declare interface $org$bukkit$inventory$DoubleChestInventory
  extends $org$bukkit$inventory$Inventory {
  getLeftSide(): org$bukkit$inventory$Inventory;
  getRightSide(): org$bukkit$inventory$Inventory;
  getHolder(): org$bukkit$block$DoubleChest;
  getHolder(): org$bukkit$inventory$InventoryHolder;
}

declare class org$bukkit$inventory$DoubleChestInventory
  implements $org$bukkit$inventory$DoubleChestInventory {
  getLeftSide(): org$bukkit$inventory$Inventory;
  getRightSide(): org$bukkit$inventory$Inventory;
  getHolder(): org$bukkit$block$DoubleChest;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$block$Dropper
  extends $org$bukkit$block$Container,
    $com$destroystokyo$paper$loottable$LootableBlockInventory {
  drop(): void;
}

declare class org$bukkit$block$Dropper implements $org$bukkit$block$Dropper {
  drop(): void;
  getBlock(): org$bukkit$block$Block;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$EnchantingTable
  extends $org$bukkit$block$TileState,
    $org$bukkit$Nameable {}

declare class org$bukkit$block$EnchantingTable
  implements $org$bukkit$block$EnchantingTable {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$EnderChest
  extends $org$bukkit$block$TileState {}

declare class org$bukkit$block$EnderChest
  implements $org$bukkit$block$EnderChest {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Hopper
  extends $org$bukkit$block$Container,
    $com$destroystokyo$paper$loottable$LootableBlockInventory {}

declare class org$bukkit$block$Hopper implements $org$bukkit$block$Hopper {
  getBlock(): org$bukkit$block$Block;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Jigsaw
  extends $org$bukkit$block$TileState {}

declare class org$bukkit$block$Jigsaw implements $org$bukkit$block$Jigsaw {
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Jukebox
  extends $org$bukkit$block$TileState {
  getPlaying(): org$bukkit$Material;
  setPlaying(arg0: org$bukkit$Material): void;
  getRecord(): org$bukkit$inventory$ItemStack;
  setRecord(arg0: org$bukkit$inventory$ItemStack): void;
  isPlaying(): boolean;
  eject(): boolean;
}

declare class org$bukkit$block$Jukebox implements $org$bukkit$block$Jukebox {
  getPlaying(): org$bukkit$Material;
  setPlaying(arg0: org$bukkit$Material): void;
  getRecord(): org$bukkit$inventory$ItemStack;
  setRecord(arg0: org$bukkit$inventory$ItemStack): void;
  isPlaying(): boolean;
  eject(): boolean;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Lectern
  extends $org$bukkit$block$TileState,
    $org$bukkit$inventory$BlockInventoryHolder {
  getPage(): number;
  setPage(arg0: number): void;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$block$Lectern implements $org$bukkit$block$Lectern {
  getPage(): number;
  setPage(arg0: number): void;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$ShulkerBox
  extends $org$bukkit$block$Container,
    $com$destroystokyo$paper$loottable$LootableBlockInventory {
  getColor(): org$bukkit$DyeColor;
}

declare class org$bukkit$block$ShulkerBox
  implements $org$bukkit$block$ShulkerBox {
  getColor(): org$bukkit$DyeColor;
  getBlock(): org$bukkit$block$Block;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Skull extends $org$bukkit$block$TileState {
  hasOwner(): boolean;
  getOwner(): string;
  setOwner(arg0: string): boolean;
  getOwningPlayer(): org$bukkit$OfflinePlayer;
  setOwningPlayer(arg0: org$bukkit$OfflinePlayer): void;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getRotation(): org$bukkit$block$BlockFace;
  setRotation(arg0: org$bukkit$block$BlockFace): void;
  getSkullType(): org$bukkit$SkullType;
  setSkullType(arg0: org$bukkit$SkullType): void;
}

declare class org$bukkit$block$Skull implements $org$bukkit$block$Skull {
  hasOwner(): boolean;
  getOwner(): string;
  setOwner(arg0: string): boolean;
  getOwningPlayer(): org$bukkit$OfflinePlayer;
  setOwningPlayer(arg0: org$bukkit$OfflinePlayer): void;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getRotation(): org$bukkit$block$BlockFace;
  setRotation(arg0: org$bukkit$block$BlockFace): void;
  getSkullType(): org$bukkit$SkullType;
  setSkullType(arg0: org$bukkit$SkullType): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$SkullType {}

declare class org$bukkit$SkullType implements $org$bukkit$SkullType {
  static SKELETON: org$bukkit$SkullType;
  static WITHER: org$bukkit$SkullType;
  static ZOMBIE: org$bukkit$SkullType;
  static PLAYER: org$bukkit$SkullType;
  static CREEPER: org$bukkit$SkullType;
  static DRAGON: org$bukkit$SkullType;
  static values(): JavaArray<org$bukkit$SkullType>;
  static valueOf(arg0: string): org$bukkit$SkullType;
}


declare interface $org$bukkit$block$Smoker extends $org$bukkit$block$Furnace {}

declare class org$bukkit$block$Smoker implements $org$bukkit$block$Smoker {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getInventory(): org$bukkit$inventory$Inventory;
  getSnapshotInventory(): org$bukkit$inventory$Inventory;
  getBurnTime(): unknown;
  setBurnTime(arg0: unknown): void;
  getCookTime(): unknown;
  setCookTime(arg0: unknown): void;
  getCookTimeTotal(): number;
  setCookTimeTotal(arg0: number): void;
  getCookSpeedMultiplier(): number;
  setCookSpeedMultiplier(arg0: number): void;
  getInventory(): org$bukkit$inventory$FurnaceInventory;
  getSnapshotInventory(): org$bukkit$inventory$FurnaceInventory;
  isLocked(): boolean;
  getLock(): string;
  setLock(arg0: string): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$Structure
  extends $org$bukkit$block$TileState {
  getStructureName(): string;
  setStructureName(arg0: string): void;
  getAuthor(): string;
  setAuthor(arg0: string): void;
  setAuthor(arg0: org$bukkit$entity$LivingEntity): void;
  getRelativePosition(): org$bukkit$util$BlockVector;
  setRelativePosition(arg0: org$bukkit$util$BlockVector): void;
  getStructureSize(): org$bukkit$util$BlockVector;
  setStructureSize(arg0: org$bukkit$util$BlockVector): void;
  setMirror(arg0: org$bukkit$block$structure$Mirror): void;
  getMirror(): org$bukkit$block$structure$Mirror;
  setRotation(arg0: org$bukkit$block$structure$StructureRotation): void;
  getRotation(): org$bukkit$block$structure$StructureRotation;
  setUsageMode(arg0: org$bukkit$block$structure$UsageMode): void;
  getUsageMode(): org$bukkit$block$structure$UsageMode;
  setIgnoreEntities(arg0: boolean): void;
  isIgnoreEntities(): boolean;
  setShowAir(arg0: boolean): void;
  isShowAir(): boolean;
  setBoundingBoxVisible(arg0: boolean): void;
  isBoundingBoxVisible(): boolean;
  setIntegrity(arg0: number): void;
  getIntegrity(): number;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string): void;
  getMetadata(): string;
}

declare class org$bukkit$block$Structure
  implements $org$bukkit$block$Structure {
  getStructureName(): string;
  setStructureName(arg0: string): void;
  getAuthor(): string;
  setAuthor(arg0: string): void;
  setAuthor(arg0: org$bukkit$entity$LivingEntity): void;
  getRelativePosition(): org$bukkit$util$BlockVector;
  setRelativePosition(arg0: org$bukkit$util$BlockVector): void;
  getStructureSize(): org$bukkit$util$BlockVector;
  setStructureSize(arg0: org$bukkit$util$BlockVector): void;
  setMirror(arg0: org$bukkit$block$structure$Mirror): void;
  getMirror(): org$bukkit$block$structure$Mirror;
  setRotation(arg0: org$bukkit$block$structure$StructureRotation): void;
  getRotation(): org$bukkit$block$structure$StructureRotation;
  setUsageMode(arg0: org$bukkit$block$structure$UsageMode): void;
  getUsageMode(): org$bukkit$block$structure$UsageMode;
  setIgnoreEntities(arg0: boolean): void;
  isIgnoreEntities(): boolean;
  setShowAir(arg0: boolean): void;
  isShowAir(): boolean;
  setBoundingBoxVisible(arg0: boolean): void;
  isBoundingBoxVisible(): boolean;
  setIntegrity(arg0: number): void;
  getIntegrity(): number;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string): void;
  getMetadata(): string;
  getBlock(): org$bukkit$block$Block;
  getData(): org$bukkit$material$MaterialData;
  getBlockData(): org$bukkit$block$data$BlockData;
  getType(): org$bukkit$Material;
  getLightLevel(): Buffer;
  getWorld(): org$bukkit$World;
  getX(): number;
  getY(): number;
  getZ(): number;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  getChunk(): org$bukkit$Chunk;
  setData(arg0: org$bukkit$material$MaterialData): void;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  setType(arg0: org$bukkit$Material): void;
  update(): boolean;
  update(arg0: boolean): boolean;
  update(arg0: boolean, arg1: boolean): boolean;
  getRawData(): Buffer;
  setRawData(arg0: Buffer): void;
  isPlaced(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$block$structure$Mirror {}

declare class org$bukkit$block$structure$Mirror
  implements $org$bukkit$block$structure$Mirror {
  static NONE: org$bukkit$block$structure$Mirror;
  static LEFT_RIGHT: org$bukkit$block$structure$Mirror;
  static FRONT_BACK: org$bukkit$block$structure$Mirror;
  static values(): JavaArray<org$bukkit$block$structure$Mirror>;
  static valueOf(arg0: string): org$bukkit$block$structure$Mirror;
}


declare interface $org$bukkit$block$structure$StructureRotation {}

declare class org$bukkit$block$structure$StructureRotation
  implements $org$bukkit$block$structure$StructureRotation {
  static NONE: org$bukkit$block$structure$StructureRotation;
  static CLOCKWISE_90: org$bukkit$block$structure$StructureRotation;
  static CLOCKWISE_180: org$bukkit$block$structure$StructureRotation;
  static COUNTERCLOCKWISE_90: org$bukkit$block$structure$StructureRotation;
  static values(): JavaArray<org$bukkit$block$structure$StructureRotation>;
  static valueOf(arg0: string): org$bukkit$block$structure$StructureRotation;
}


declare interface $org$bukkit$block$structure$UsageMode {}

declare class org$bukkit$block$structure$UsageMode
  implements $org$bukkit$block$structure$UsageMode {
  static SAVE: org$bukkit$block$structure$UsageMode;
  static LOAD: org$bukkit$block$structure$UsageMode;
  static CORNER: org$bukkit$block$structure$UsageMode;
  static DATA: org$bukkit$block$structure$UsageMode;
  static values(): JavaArray<org$bukkit$block$structure$UsageMode>;
  static valueOf(arg0: string): org$bukkit$block$structure$UsageMode;
}


declare interface $org$bukkit$Bukkit {}

declare class org$bukkit$Bukkit implements $org$bukkit$Bukkit {
  static getServer(): org$bukkit$Server;
  static setServer(arg0: org$bukkit$Server): void;
  static getName(): string;
  static getVersion(): string;
  static getBukkitVersion(): string;
  static getMinecraftVersion(): string;
  static getOnlinePlayers(): java$util$Collection;
  static getMaxPlayers(): number;
  static getPort(): number;
  static getViewDistance(): number;
  static getIp(): string;
  static getWorldType(): string;
  static getGenerateStructures(): boolean;
  static getAllowEnd(): boolean;
  static getAllowNether(): boolean;
  static hasWhitelist(): boolean;
  static setWhitelist(arg0: boolean): void;
  static getWhitelistedPlayers(): any /* java.util.Set */;
  static reloadWhitelist(): void;
  static broadcastMessage(arg0: string): number;
  static broadcast(arg0: unknown): void;
  static broadcast(arg0: JavaArray<unknown>): void;
  static getUpdateFolder(): string;
  static getUpdateFolderFile(): any /* java.io.File */;
  static getConnectionThrottle(): number;
  static getTicksPerAnimalSpawns(): number;
  static getTicksPerMonsterSpawns(): number;
  static getTicksPerWaterSpawns(): number;
  static getTicksPerAmbientSpawns(): number;
  static getPlayer(arg0: string): org$bukkit$entity$Player;
  static getPlayerExact(arg0: string): org$bukkit$entity$Player;
  static matchPlayer(arg0: string): any /* java.util.List */;
  static getPlayer(arg0: any /* java.util.UUID */): org$bukkit$entity$Player;
  static getPlayerUniqueId(arg0: string): any /* java.util.UUID */;
  static getPluginManager(): org$bukkit$plugin$PluginManager;
  static getScheduler(): org$bukkit$scheduler$BukkitScheduler;
  static getServicesManager(): org$bukkit$plugin$ServicesManager;
  static getWorlds(): any /* java.util.List */;
  static createWorld(arg0: org$bukkit$WorldCreator): org$bukkit$World;
  static unloadWorld(arg0: string, arg1: boolean): boolean;
  static unloadWorld(arg0: org$bukkit$World, arg1: boolean): boolean;
  static getWorld(arg0: string): org$bukkit$World;
  static getWorld(arg0: any /* java.util.UUID */): org$bukkit$World;
  static getMap(arg0: number): org$bukkit$map$MapView;
  static createMap(arg0: org$bukkit$World): org$bukkit$map$MapView;
  static createExplorerMap(
    arg0: org$bukkit$World,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$StructureType
  ): org$bukkit$inventory$ItemStack;
  static createExplorerMap(
    arg0: org$bukkit$World,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$StructureType,
    arg3: number,
    arg4: boolean
  ): org$bukkit$inventory$ItemStack;
  static reload(): void;
  static reloadData(): void;
  static getLogger(): any /* java.util.logging.Logger */;
  static getPluginCommand(arg0: string): org$bukkit$command$PluginCommand;
  static savePlayers(): void;
  static dispatchCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): boolean;
  static addRecipe(arg0: org$bukkit$inventory$Recipe): boolean;
  static getRecipesFor(
    arg0: org$bukkit$inventory$ItemStack
  ): any /* java.util.List */;
  static recipeIterator(): any /* java.util.Iterator */;
  static clearRecipes(): void;
  static resetRecipes(): void;
  static removeRecipe(arg0: org$bukkit$NamespacedKey): boolean;
  static getCommandAliases(): any /* java.util.Map */;
  static getSpawnRadius(): number;
  static setSpawnRadius(arg0: number): void;
  static getOnlineMode(): boolean;
  static getAllowFlight(): boolean;
  static isHardcore(): boolean;
  static shutdown(): void;
  static broadcast(arg0: string, arg1: string): number;
  static getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  static getOfflinePlayer(
    arg0: any /* java.util.UUID */
  ): org$bukkit$OfflinePlayer;
  static getIPBans(): any /* java.util.Set */;
  static banIP(arg0: string): void;
  static unbanIP(arg0: string): void;
  static getBannedPlayers(): any /* java.util.Set */;
  static getBanList(arg0: org$bukkit$BanList$Type): org$bukkit$BanList;
  static getOperators(): any /* java.util.Set */;
  static getDefaultGameMode(): org$bukkit$GameMode;
  static setDefaultGameMode(arg0: org$bukkit$GameMode): void;
  static getConsoleSender(): org$bukkit$command$ConsoleCommandSender;
  static getWorldContainer(): any /* java.io.File */;
  static getOfflinePlayers(): JavaArray<org$bukkit$OfflinePlayer>;
  static getMessenger(): org$bukkit$plugin$messaging$Messenger;
  static getHelpMap(): org$bukkit$help$HelpMap;
  static createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: org$bukkit$event$inventory$InventoryType
  ): org$bukkit$inventory$Inventory;
  static createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: org$bukkit$event$inventory$InventoryType,
    arg2: string
  ): org$bukkit$inventory$Inventory;
  static createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: number
  ): org$bukkit$inventory$Inventory;
  static createInventory(
    arg0: org$bukkit$inventory$InventoryHolder,
    arg1: number,
    arg2: string
  ): org$bukkit$inventory$Inventory;
  static createMerchant(arg0: string): org$bukkit$inventory$Merchant;
  static getMonsterSpawnLimit(): number;
  static getAnimalSpawnLimit(): number;
  static getWaterAnimalSpawnLimit(): number;
  static getAmbientSpawnLimit(): number;
  static isPrimaryThread(): boolean;
  static getMotd(): string;
  static getShutdownMessage(): string;
  static getWarningState(): org$bukkit$Warning$WarningState;
  static getItemFactory(): org$bukkit$inventory$ItemFactory;
  static getScoreboardManager(): org$bukkit$scoreboard$ScoreboardManager;
  static getServerIcon(): org$bukkit$util$CachedServerIcon;
  static loadServerIcon(
    arg0: any /* java.io.File */
  ): org$bukkit$util$CachedServerIcon;
  static loadServerIcon(
    arg0: any /* java.awt.image.BufferedImage */
  ): org$bukkit$util$CachedServerIcon;
  static setIdleTimeout(arg0: number): void;
  static getIdleTimeout(): number;
  static createChunkData(
    arg0: org$bukkit$World
  ): org$bukkit$generator$ChunkGenerator$ChunkData;
  static createBossBar(
    arg0: string,
    arg1: org$bukkit$boss$BarColor,
    arg2: org$bukkit$boss$BarStyle,
    arg3: JavaArray<org$bukkit$boss$BarFlag>
  ): org$bukkit$boss$BossBar;
  static createBossBar(
    arg0: org$bukkit$NamespacedKey,
    arg1: string,
    arg2: org$bukkit$boss$BarColor,
    arg3: org$bukkit$boss$BarStyle,
    arg4: JavaArray<org$bukkit$boss$BarFlag>
  ): org$bukkit$boss$KeyedBossBar;
  static getBossBars(): any /* java.util.Iterator */;
  static getBossBar(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$boss$KeyedBossBar;
  static removeBossBar(arg0: org$bukkit$NamespacedKey): boolean;
  static getEntity(arg0: any /* java.util.UUID */): org$bukkit$entity$Entity;
  static getTPS(): JavaArray<number>;
  static getTickTimes(): JavaArray<number>;
  static getAverageTickTime(): number;
  static getAdvancement(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$advancement$Advancement;
  static advancementIterator(): any /* java.util.Iterator */;
  static createBlockData(
    arg0: org$bukkit$Material
  ): org$bukkit$block$data$BlockData;
  static createBlockData(
    arg0: org$bukkit$Material,
    arg1: any /* java.util.function.Consumer */
  ): org$bukkit$block$data$BlockData;
  static createBlockData(arg0: string): org$bukkit$block$data$BlockData;
  static createBlockData(
    arg0: org$bukkit$Material,
    arg1: string
  ): org$bukkit$block$data$BlockData;
  static getTag(
    arg0: string,
    arg1: org$bukkit$NamespacedKey,
    arg2: any /* java.lang.Class */
  ): org$bukkit$Tag;
  static getTags(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): any /* java.lang.Iterable */;
  static getLootTable(
    arg0: org$bukkit$NamespacedKey
  ): org$bukkit$loot$LootTable;
  static selectEntities(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  static getUnsafe(): org$bukkit$UnsafeValues;
  static getCommandMap(): org$bukkit$command$CommandMap;
  static reloadPermissions(): void;
  static reloadCommandAliases(): boolean;
  static suggestPlayerNamesWhenNullTabCompletions(): boolean;
  static getPermissionMessage(): string;
  static createProfile(
    arg0: any /* java.util.UUID */
  ): com$destroystokyo$paper$profile$PlayerProfile;
  static createProfile(
    arg0: string
  ): com$destroystokyo$paper$profile$PlayerProfile;
  static createProfile(
    arg0: any /* java.util.UUID */,
    arg1: string
  ): com$destroystokyo$paper$profile$PlayerProfile;
  static getCurrentTick(): number;
  static isStopping(): boolean;
  static getMobGoals(): com$destroystokyo$paper$entity$ai$MobGoals;
  static spigot(): org$bukkit$Server$Spigot;
}


declare interface $org$bukkit$ChatColor$10 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$10 implements $org$bukkit$ChatColor$10 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$11 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$11 implements $org$bukkit$ChatColor$11 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$12 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$12 implements $org$bukkit$ChatColor$12 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$13 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$13 implements $org$bukkit$ChatColor$13 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$14 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$14 implements $org$bukkit$ChatColor$14 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$15 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$15 implements $org$bukkit$ChatColor$15 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$16 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$16 implements $org$bukkit$ChatColor$16 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$17 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$17 implements $org$bukkit$ChatColor$17 {
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: boolean
  );
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$18 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$18 implements $org$bukkit$ChatColor$18 {
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: boolean
  );
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$19 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$19 implements $org$bukkit$ChatColor$19 {
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: boolean
  );
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$2 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$2 implements $org$bukkit$ChatColor$2 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$20 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$20 implements $org$bukkit$ChatColor$20 {
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: boolean
  );
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$21 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$21 implements $org$bukkit$ChatColor$21 {
  constructor(
    arg0: string,
    arg1: number,
    arg2: string,
    arg3: number,
    arg4: boolean
  );
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$22 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$22 implements $org$bukkit$ChatColor$22 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$3 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$3 implements $org$bukkit$ChatColor$3 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$4 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$4 implements $org$bukkit$ChatColor$4 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$5 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$5 implements $org$bukkit$ChatColor$5 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$6 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$6 implements $org$bukkit$ChatColor$6 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$7 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$7 implements $org$bukkit$ChatColor$7 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$8 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$8 implements $org$bukkit$ChatColor$8 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$ChatColor$9 {
  asBungee(): unknown;
}

declare class org$bukkit$ChatColor$9 implements $org$bukkit$ChatColor$9 {
  constructor(arg0: string, arg1: number, arg2: string, arg3: number);
  asBungee(): unknown;
}


declare interface $org$bukkit$CoalType {
  getData(): Buffer;
}

declare class org$bukkit$CoalType implements $org$bukkit$CoalType {
  static COAL: org$bukkit$CoalType;
  static CHARCOAL: org$bukkit$CoalType;
  static values(): JavaArray<org$bukkit$CoalType>;
  static valueOf(arg0: string): org$bukkit$CoalType;
  getData(): Buffer;
  static getByData(arg0: Buffer): org$bukkit$CoalType;
}


declare interface $org$bukkit$command$BlockCommandSender
  extends $org$bukkit$command$CommandSender {
  getBlock(): org$bukkit$block$Block;
}

declare class org$bukkit$command$BlockCommandSender
  implements $org$bukkit$command$BlockCommandSender {
  getBlock(): org$bukkit$block$Block;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$command$BufferedCommandSender
  extends $org$bukkit$command$MessageCommandSender {
  sendMessage(arg0: string): void;
  getBuffer(): string;
  reset(): void;
}

declare class org$bukkit$command$BufferedCommandSender
  implements $org$bukkit$command$BufferedCommandSender {
  constructor();
  sendMessage(arg0: string): void;
  getBuffer(): string;
  reset(): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
}


declare interface $org$bukkit$command$CommandException {}

declare class org$bukkit$command$CommandException
  implements $org$bukkit$command$CommandException {
  constructor();
  constructor(arg0: string);
  constructor(arg0: string, arg1: any /* java.lang.Throwable */);
}


declare interface $org$bukkit$command$defaults$BukkitCommand {}

declare class org$bukkit$command$defaults$BukkitCommand
  implements $org$bukkit$command$defaults$BukkitCommand {
  constructor(arg0: string);
  constructor(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: any /* java.util.List */
  );
}


declare interface $org$bukkit$command$defaults$HelpCommand {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  findPossibleMatches(arg0: string): org$bukkit$help$HelpTopic;
}

declare class org$bukkit$command$defaults$HelpCommand
  implements $org$bukkit$command$defaults$HelpCommand {
  constructor();
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  findPossibleMatches(arg0: string): org$bukkit$help$HelpTopic;
  static damerauLevenshteinDistance(arg0: string, arg1: string): number;
}


declare interface $org$bukkit$command$defaults$PluginsCommand {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}

declare class org$bukkit$command$defaults$PluginsCommand
  implements $org$bukkit$command$defaults$PluginsCommand {
  constructor(arg0: string);
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}


declare interface $org$bukkit$command$defaults$ReloadCommand {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}

declare class org$bukkit$command$defaults$ReloadCommand
  implements $org$bukkit$command$defaults$ReloadCommand {
  constructor(arg0: string);
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}


declare interface $org$bukkit$command$defaults$VersionCommand {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
}

declare class org$bukkit$command$defaults$VersionCommand
  implements $org$bukkit$command$defaults$VersionCommand {
  constructor(arg0: string);
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): any /* java.util.List */;
  static access$000(arg0: org$bukkit$command$defaults$VersionCommand): void;
}


declare interface $org$bukkit$command$defaults$VersionCommand$1 {
  run(): void;
}

declare class org$bukkit$command$defaults$VersionCommand$1
  implements $org$bukkit$command$defaults$VersionCommand$1 {
  constructor(arg0: org$bukkit$command$defaults$VersionCommand);
  run(): void;
}


declare interface $org$bukkit$command$FormattedCommandAlias {
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  getTimingName(): string;
}

declare class org$bukkit$command$FormattedCommandAlias
  implements $org$bukkit$command$FormattedCommandAlias {
  constructor(arg0: string, arg1: JavaArray<string>);
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
  getTimingName(): string;
}


declare interface $org$bukkit$command$MultipleCommandAlias {
  getCommands(): JavaArray<org$bukkit$command$Command>;
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
}

declare class org$bukkit$command$MultipleCommandAlias
  implements $org$bukkit$command$MultipleCommandAlias {
  constructor(arg0: string, arg1: JavaArray<org$bukkit$command$Command>);
  getCommands(): JavaArray<org$bukkit$command$Command>;
  execute(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: JavaArray<string>
  ): boolean;
}


declare interface $org$bukkit$command$PluginCommandYamlParser {}

declare class org$bukkit$command$PluginCommandYamlParser
  implements $org$bukkit$command$PluginCommandYamlParser {
  constructor();
  static parse(arg0: org$bukkit$plugin$Plugin): any /* java.util.List */;
}


declare interface $org$bukkit$command$ProxiedCommandSender
  extends $org$bukkit$command$CommandSender {
  getCaller(): org$bukkit$command$CommandSender;
  getCallee(): org$bukkit$command$CommandSender;
}

declare class org$bukkit$command$ProxiedCommandSender
  implements $org$bukkit$command$ProxiedCommandSender {
  getCaller(): org$bukkit$command$CommandSender;
  getCallee(): org$bukkit$command$CommandSender;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$command$RemoteConsoleCommandSender
  extends $org$bukkit$command$CommandSender {}

declare class org$bukkit$command$RemoteConsoleCommandSender
  implements $org$bukkit$command$RemoteConsoleCommandSender {
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
}


declare interface $org$bukkit$command$SimpleCommandMap
  extends $org$bukkit$command$CommandMap {
  setFallbackCommands(): void;
  registerAll(arg0: string, arg1: any /* java.util.List */): void;
  register(arg0: string, arg1: org$bukkit$command$Command): boolean;
  register(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$command$Command
  ): boolean;
  dispatch(arg0: org$bukkit$command$CommandSender, arg1: string): boolean;
  clearCommands(): void;
  getCommand(arg0: string): org$bukkit$command$Command;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: org$bukkit$Location
  ): any /* java.util.List */;
  getCommands(): java$util$Collection;
  registerServerAliases(): void;
  getKnownCommands(): any /* java.util.Map */;
}

declare class org$bukkit$command$SimpleCommandMap
  implements $org$bukkit$command$SimpleCommandMap {
  constructor(arg0: org$bukkit$Server);
  setFallbackCommands(): void;
  registerAll(arg0: string, arg1: any /* java.util.List */): void;
  register(arg0: string, arg1: org$bukkit$command$Command): boolean;
  register(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$command$Command
  ): boolean;
  dispatch(arg0: org$bukkit$command$CommandSender, arg1: string): boolean;
  clearCommands(): void;
  getCommand(arg0: string): org$bukkit$command$Command;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string
  ): any /* java.util.List */;
  tabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: org$bukkit$Location
  ): any /* java.util.List */;
  getCommands(): java$util$Collection;
  registerServerAliases(): void;
  getKnownCommands(): any /* java.util.Map */;
}


declare interface $org$bukkit$configuration$file$YamlConstructor {}

declare class org$bukkit$configuration$file$YamlConstructor
  implements $org$bukkit$configuration$file$YamlConstructor {
  constructor();
}


declare interface $org$bukkit$configuration$file$YamlConstructor$1 {}

declare class org$bukkit$configuration$file$YamlConstructor$1
  implements $org$bukkit$configuration$file$YamlConstructor$1 {}


declare interface $org$bukkit$configuration$file$YamlConstructor$ConstructCustomObject {
  construct(arg0: unknown): any;
  construct2ndStep(arg0: unknown, arg1: any): void;
}

declare class org$bukkit$configuration$file$YamlConstructor$ConstructCustomObject
  implements
    $org$bukkit$configuration$file$YamlConstructor$ConstructCustomObject {
  construct(arg0: unknown): any;
  construct2ndStep(arg0: unknown, arg1: any): void;
  constructor(
    arg0: org$bukkit$configuration$file$YamlConstructor,
    arg1: org$bukkit$configuration$file$YamlConstructor$1
  );
}


declare interface $org$bukkit$configuration$file$YamlRepresenter {}

declare class org$bukkit$configuration$file$YamlRepresenter
  implements $org$bukkit$configuration$file$YamlRepresenter {
  constructor();
}


declare interface $org$bukkit$configuration$file$YamlRepresenter$1 {}

declare class org$bukkit$configuration$file$YamlRepresenter$1
  implements $org$bukkit$configuration$file$YamlRepresenter$1 {}


declare interface $org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSection {
  representData(arg0: any): unknown;
}

declare class org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSection
  implements
    $org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSection {
  representData(arg0: any): unknown;
  constructor(
    arg0: org$bukkit$configuration$file$YamlRepresenter,
    arg1: org$bukkit$configuration$file$YamlRepresenter$1
  );
}


declare interface $org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSerializable {
  representData(arg0: any): unknown;
}

declare class org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSerializable
  implements
    $org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSerializable {
  representData(arg0: any): unknown;
  constructor(
    arg0: org$bukkit$configuration$file$YamlRepresenter,
    arg1: org$bukkit$configuration$file$YamlRepresenter$1
  );
}


declare interface $org$bukkit$configuration$InvalidConfigurationException {}

declare class org$bukkit$configuration$InvalidConfigurationException
  implements $org$bukkit$configuration$InvalidConfigurationException {
  constructor();
  constructor(arg0: string);
  constructor(arg0: any /* java.lang.Throwable */);
  constructor(arg0: string, arg1: any /* java.lang.Throwable */);
}


declare interface $org$bukkit$configuration$MemorySection
  extends $org$bukkit$configuration$ConfigurationSection {
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  addDefault(arg0: string, arg1: any): void;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
  set(arg0: string, arg1: any): void;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  isPrimitiveWrapper(arg0: any): boolean;
  getDefault(arg0: string): any;
  mapChildrenKeys(
    arg0: any /* java.util.Set */,
    arg1: org$bukkit$configuration$ConfigurationSection,
    arg2: boolean
  ): void;
  mapChildrenValues(
    arg0: any /* java.util.Map */,
    arg1: org$bukkit$configuration$ConfigurationSection,
    arg2: boolean
  ): void;
  toString(): string;
}

declare class org$bukkit$configuration$MemorySection
  implements $org$bukkit$configuration$MemorySection {
  constructor();
  constructor(
    arg0: org$bukkit$configuration$ConfigurationSection,
    arg1: string
  );
  getKeys(arg0: boolean): any /* java.util.Set */;
  getValues(arg0: boolean): any /* java.util.Map */;
  contains(arg0: string): boolean;
  contains(arg0: string, arg1: boolean): boolean;
  isSet(arg0: string): boolean;
  getCurrentPath(): string;
  getName(): string;
  getRoot(): org$bukkit$configuration$Configuration;
  getParent(): org$bukkit$configuration$ConfigurationSection;
  addDefault(arg0: string, arg1: any): void;
  getDefaultSection(): org$bukkit$configuration$ConfigurationSection;
  set(arg0: string, arg1: any): void;
  get(arg0: string): any;
  get(arg0: string, arg1: any): any;
  createSection(arg0: string): org$bukkit$configuration$ConfigurationSection;
  createSection(
    arg0: string,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$ConfigurationSection;
  getString(arg0: string): string;
  getString(arg0: string, arg1: string): string;
  isString(arg0: string): boolean;
  getInt(arg0: string): number;
  getInt(arg0: string, arg1: number): number;
  isInt(arg0: string): boolean;
  getBoolean(arg0: string): boolean;
  getBoolean(arg0: string, arg1: boolean): boolean;
  isBoolean(arg0: string): boolean;
  getDouble(arg0: string): number;
  getDouble(arg0: string, arg1: number): number;
  isDouble(arg0: string): boolean;
  getLong(arg0: string): number;
  getLong(arg0: string, arg1: number): number;
  isLong(arg0: string): boolean;
  getList(arg0: string): any /* java.util.List */;
  getList(
    arg0: string,
    arg1: any /* java.util.List */
  ): any /* java.util.List */;
  isList(arg0: string): boolean;
  getStringList(arg0: string): any /* java.util.List */;
  getIntegerList(arg0: string): any /* java.util.List */;
  getBooleanList(arg0: string): any /* java.util.List */;
  getDoubleList(arg0: string): any /* java.util.List */;
  getFloatList(arg0: string): any /* java.util.List */;
  getLongList(arg0: string): any /* java.util.List */;
  getByteList(arg0: string): any /* java.util.List */;
  getCharacterList(arg0: string): any /* java.util.List */;
  getShortList(arg0: string): any /* java.util.List */;
  getMapList(arg0: string): any /* java.util.List */;
  getObject(arg0: string, arg1: any /* java.lang.Class */): any;
  getObject(arg0: string, arg1: any /* java.lang.Class */, arg2: any): any;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getSerializable(
    arg0: string,
    arg1: any /* java.lang.Class */,
    arg2: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  getVector(arg0: string): org$bukkit$util$Vector;
  getVector(arg0: string, arg1: org$bukkit$util$Vector): org$bukkit$util$Vector;
  isVector(arg0: string): boolean;
  getOfflinePlayer(arg0: string): org$bukkit$OfflinePlayer;
  getOfflinePlayer(
    arg0: string,
    arg1: org$bukkit$OfflinePlayer
  ): org$bukkit$OfflinePlayer;
  isOfflinePlayer(arg0: string): boolean;
  getItemStack(arg0: string): org$bukkit$inventory$ItemStack;
  getItemStack(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ItemStack;
  isItemStack(arg0: string): boolean;
  getColor(arg0: string): org$bukkit$Color;
  getColor(arg0: string, arg1: org$bukkit$Color): org$bukkit$Color;
  isColor(arg0: string): boolean;
  getLocation(arg0: string): org$bukkit$Location;
  getLocation(arg0: string, arg1: org$bukkit$Location): org$bukkit$Location;
  isLocation(arg0: string): boolean;
  getConfigurationSection(
    arg0: string
  ): org$bukkit$configuration$ConfigurationSection;
  isConfigurationSection(arg0: string): boolean;
  isPrimitiveWrapper(arg0: any): boolean;
  getDefault(arg0: string): any;
  mapChildrenKeys(
    arg0: any /* java.util.Set */,
    arg1: org$bukkit$configuration$ConfigurationSection,
    arg2: boolean
  ): void;
  mapChildrenValues(
    arg0: any /* java.util.Map */,
    arg1: org$bukkit$configuration$ConfigurationSection,
    arg2: boolean
  ): void;
  static createPath(
    arg0: org$bukkit$configuration$ConfigurationSection,
    arg1: string
  ): string;
  static createPath(
    arg0: org$bukkit$configuration$ConfigurationSection,
    arg1: string,
    arg2: org$bukkit$configuration$ConfigurationSection
  ): string;
  toString(): string;
}


declare interface $org$bukkit$configuration$serialization$ConfigurationSerialization {
  getMethod(arg0: string, arg1: boolean): any /* java.lang.reflect.Method */;
  getConstructor(): any /* java.lang.reflect.Constructor */;
  deserializeViaMethod(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  deserializeViaCtor(
    arg0: any /* java.lang.reflect.Constructor */,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
}

declare class org$bukkit$configuration$serialization$ConfigurationSerialization
  implements
    $org$bukkit$configuration$serialization$ConfigurationSerialization {
  static SERIALIZED_TYPE_KEY: string;
  constructor(arg0: any /* java.lang.Class */);
  getMethod(arg0: string, arg1: boolean): any /* java.lang.reflect.Method */;
  getConstructor(): any /* java.lang.reflect.Constructor */;
  deserializeViaMethod(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  deserializeViaCtor(
    arg0: any /* java.lang.reflect.Constructor */,
    arg1: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  deserialize(
    arg0: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  static deserializeObject(
    arg0: any /* java.util.Map */,
    arg1: any /* java.lang.Class */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  static deserializeObject(
    arg0: any /* java.util.Map */
  ): org$bukkit$configuration$serialization$ConfigurationSerializable;
  static registerClass(arg0: any /* java.lang.Class */): void;
  static registerClass(arg0: any /* java.lang.Class */, arg1: string): void;
  static unregisterClass(arg0: string): void;
  static unregisterClass(arg0: any /* java.lang.Class */): void;
  static getClassByAlias(arg0: string): any /* java.lang.Class */;
  static getAlias(arg0: any /* java.lang.Class */): string;
}


declare interface $org$bukkit$configuration$serialization$DelegateDeserialization {
  value(): any /* java.lang.Class */;
}

declare class org$bukkit$configuration$serialization$DelegateDeserialization
  implements $org$bukkit$configuration$serialization$DelegateDeserialization {
  value(): any /* java.lang.Class */;
}


declare interface $org$bukkit$configuration$serialization$SerializableAs {
  value(): string;
}

declare class org$bukkit$configuration$serialization$SerializableAs
  implements $org$bukkit$configuration$serialization$SerializableAs {
  value(): string;
}


declare interface $org$bukkit$conversations$BooleanPrompt {
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: boolean
  ): org$bukkit$conversations$Prompt;
}

declare class org$bukkit$conversations$BooleanPrompt
  implements $org$bukkit$conversations$BooleanPrompt {
  constructor();
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: boolean
  ): org$bukkit$conversations$Prompt;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$ConversationFactory {
  withModality(arg0: boolean): org$bukkit$conversations$ConversationFactory;
  withLocalEcho(arg0: boolean): org$bukkit$conversations$ConversationFactory;
  withPrefix(
    arg0: org$bukkit$conversations$ConversationPrefix
  ): org$bukkit$conversations$ConversationFactory;
  withTimeout(arg0: number): org$bukkit$conversations$ConversationFactory;
  withFirstPrompt(
    arg0: org$bukkit$conversations$Prompt
  ): org$bukkit$conversations$ConversationFactory;
  withInitialSessionData(
    arg0: any /* java.util.Map */
  ): org$bukkit$conversations$ConversationFactory;
  withEscapeSequence(
    arg0: string
  ): org$bukkit$conversations$ConversationFactory;
  withConversationCanceller(
    arg0: org$bukkit$conversations$ConversationCanceller
  ): org$bukkit$conversations$ConversationFactory;
  thatExcludesNonPlayersWithMessage(
    arg0: string
  ): org$bukkit$conversations$ConversationFactory;
  addConversationAbandonedListener(
    arg0: org$bukkit$conversations$ConversationAbandonedListener
  ): org$bukkit$conversations$ConversationFactory;
  buildConversation(
    arg0: org$bukkit$conversations$Conversable
  ): org$bukkit$conversations$Conversation;
}

declare class org$bukkit$conversations$ConversationFactory
  implements $org$bukkit$conversations$ConversationFactory {
  constructor(arg0: org$bukkit$plugin$Plugin);
  withModality(arg0: boolean): org$bukkit$conversations$ConversationFactory;
  withLocalEcho(arg0: boolean): org$bukkit$conversations$ConversationFactory;
  withPrefix(
    arg0: org$bukkit$conversations$ConversationPrefix
  ): org$bukkit$conversations$ConversationFactory;
  withTimeout(arg0: number): org$bukkit$conversations$ConversationFactory;
  withFirstPrompt(
    arg0: org$bukkit$conversations$Prompt
  ): org$bukkit$conversations$ConversationFactory;
  withInitialSessionData(
    arg0: any /* java.util.Map */
  ): org$bukkit$conversations$ConversationFactory;
  withEscapeSequence(
    arg0: string
  ): org$bukkit$conversations$ConversationFactory;
  withConversationCanceller(
    arg0: org$bukkit$conversations$ConversationCanceller
  ): org$bukkit$conversations$ConversationFactory;
  thatExcludesNonPlayersWithMessage(
    arg0: string
  ): org$bukkit$conversations$ConversationFactory;
  addConversationAbandonedListener(
    arg0: org$bukkit$conversations$ConversationAbandonedListener
  ): org$bukkit$conversations$ConversationFactory;
  buildConversation(
    arg0: org$bukkit$conversations$Conversable
  ): org$bukkit$conversations$Conversation;
}


declare interface $org$bukkit$conversations$ConversationFactory$1 {}

declare class org$bukkit$conversations$ConversationFactory$1
  implements $org$bukkit$conversations$ConversationFactory$1 {}


declare interface $org$bukkit$conversations$ConversationFactory$NotPlayerMessagePrompt {
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  getNextPrompt(
    arg0: org$bukkit$conversations$ConversationContext
  ): org$bukkit$conversations$Prompt;
}

declare class org$bukkit$conversations$ConversationFactory$NotPlayerMessagePrompt
  implements
    $org$bukkit$conversations$ConversationFactory$NotPlayerMessagePrompt {
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  getNextPrompt(
    arg0: org$bukkit$conversations$ConversationContext
  ): org$bukkit$conversations$Prompt;
  constructor(
    arg0: org$bukkit$conversations$ConversationFactory,
    arg1: org$bukkit$conversations$ConversationFactory$1
  );
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$ExactMatchConversationCanceller
  extends $org$bukkit$conversations$ConversationCanceller {
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
  clone(): any;
}

declare class org$bukkit$conversations$ExactMatchConversationCanceller
  implements $org$bukkit$conversations$ExactMatchConversationCanceller {
  constructor(arg0: string);
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
  clone(): any;
}


declare interface $org$bukkit$conversations$FixedSetPrompt {
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  formatFixedSet(): string;
}

declare class org$bukkit$conversations$FixedSetPrompt
  implements $org$bukkit$conversations$FixedSetPrompt {
  constructor(arg0: JavaArray<string>);
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  formatFixedSet(): string;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$InactivityConversationCanceller
  extends $org$bukkit$conversations$ConversationCanceller {
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
  cancelling(arg0: org$bukkit$conversations$Conversation): void;
  clone(): any;
}

declare class org$bukkit$conversations$InactivityConversationCanceller
  implements $org$bukkit$conversations$InactivityConversationCanceller {
  constructor(arg0: org$bukkit$plugin$Plugin, arg1: number);
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
  cancelling(arg0: org$bukkit$conversations$Conversation): void;
  clone(): any;
  static access$000(
    arg0: org$bukkit$conversations$InactivityConversationCanceller
  ): void;
}


declare interface $org$bukkit$conversations$InactivityConversationCanceller$1 {
  run(): void;
}

declare class org$bukkit$conversations$InactivityConversationCanceller$1
  implements $org$bukkit$conversations$InactivityConversationCanceller$1 {
  constructor(arg0: org$bukkit$conversations$InactivityConversationCanceller);
  run(): void;
}


declare interface $org$bukkit$conversations$ManuallyAbandonedConversationCanceller
  extends $org$bukkit$conversations$ConversationCanceller {
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
  clone(): any;
}

declare class org$bukkit$conversations$ManuallyAbandonedConversationCanceller
  implements $org$bukkit$conversations$ManuallyAbandonedConversationCanceller {
  constructor();
  setConversation(arg0: org$bukkit$conversations$Conversation): void;
  cancelBasedOnInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  clone(): org$bukkit$conversations$ConversationCanceller;
  clone(): any;
}


declare interface $org$bukkit$conversations$MessagePrompt
  extends $org$bukkit$conversations$Prompt {
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  getNextPrompt(
    arg0: org$bukkit$conversations$ConversationContext
  ): org$bukkit$conversations$Prompt;
}

declare class org$bukkit$conversations$MessagePrompt
  implements $org$bukkit$conversations$MessagePrompt {
  constructor();
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  getNextPrompt(
    arg0: org$bukkit$conversations$ConversationContext
  ): org$bukkit$conversations$Prompt;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
}


declare interface $org$bukkit$conversations$NullConversationPrefix
  extends $org$bukkit$conversations$ConversationPrefix {
  getPrefix(arg0: org$bukkit$conversations$ConversationContext): string;
}

declare class org$bukkit$conversations$NullConversationPrefix
  implements $org$bukkit$conversations$NullConversationPrefix {
  constructor();
  getPrefix(arg0: org$bukkit$conversations$ConversationContext): string;
}


declare interface $org$bukkit$conversations$NumericPrompt {
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  isNumberValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: any /* java.lang.Number */
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: any /* java.lang.Number */
  ): org$bukkit$conversations$Prompt;
  getFailedValidationText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): string;
  getInputNotNumericText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): string;
  getFailedValidationText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: any /* java.lang.Number */
  ): string;
}

declare class org$bukkit$conversations$NumericPrompt
  implements $org$bukkit$conversations$NumericPrompt {
  constructor();
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  isNumberValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: any /* java.lang.Number */
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: any /* java.lang.Number */
  ): org$bukkit$conversations$Prompt;
  getFailedValidationText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): string;
  getInputNotNumericText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): string;
  getFailedValidationText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: any /* java.lang.Number */
  ): string;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$PlayerNamePrompt {
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: org$bukkit$entity$Player
  ): org$bukkit$conversations$Prompt;
}

declare class org$bukkit$conversations$PlayerNamePrompt
  implements $org$bukkit$conversations$PlayerNamePrompt {
  constructor(arg0: org$bukkit$plugin$Plugin);
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: org$bukkit$entity$Player
  ): org$bukkit$conversations$Prompt;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$PluginNameConversationPrefix
  extends $org$bukkit$conversations$ConversationPrefix {
  getPrefix(arg0: org$bukkit$conversations$ConversationContext): string;
}

declare class org$bukkit$conversations$PluginNameConversationPrefix
  implements $org$bukkit$conversations$PluginNameConversationPrefix {
  constructor(arg0: org$bukkit$plugin$Plugin);
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$ChatColor
  );
  getPrefix(arg0: org$bukkit$conversations$ConversationContext): string;
}


declare interface $org$bukkit$conversations$RegexPrompt {
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
}

declare class org$bukkit$conversations$RegexPrompt
  implements $org$bukkit$conversations$RegexPrompt {
  constructor(arg0: string);
  constructor(arg0: any /* java.util.regex.Pattern */);
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$StringPrompt
  extends $org$bukkit$conversations$Prompt {
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
}

declare class org$bukkit$conversations$StringPrompt
  implements $org$bukkit$conversations$StringPrompt {
  constructor();
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
}


declare interface $org$bukkit$conversations$ValidatingPrompt
  extends $org$bukkit$conversations$Prompt {
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  getFailedValidationText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): string;
}

declare class org$bukkit$conversations$ValidatingPrompt
  implements $org$bukkit$conversations$ValidatingPrompt {
  constructor();
  acceptInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  blocksForInput(arg0: org$bukkit$conversations$ConversationContext): boolean;
  isInputValid(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): boolean;
  acceptValidatedInput(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): org$bukkit$conversations$Prompt;
  getFailedValidationText(
    arg0: org$bukkit$conversations$ConversationContext,
    arg1: string
  ): string;
  static END_OF_CONVERSATION: org$bukkit$conversations$Prompt;
  getPromptText(arg0: org$bukkit$conversations$ConversationContext): string;
}


declare interface $org$bukkit$CropState {
  getData(): Buffer;
}

declare class org$bukkit$CropState implements $org$bukkit$CropState {
  static SEEDED: org$bukkit$CropState;
  static GERMINATED: org$bukkit$CropState;
  static VERY_SMALL: org$bukkit$CropState;
  static SMALL: org$bukkit$CropState;
  static MEDIUM: org$bukkit$CropState;
  static TALL: org$bukkit$CropState;
  static VERY_TALL: org$bukkit$CropState;
  static RIPE: org$bukkit$CropState;
  static values(): JavaArray<org$bukkit$CropState>;
  static valueOf(arg0: string): org$bukkit$CropState;
  getData(): Buffer;
  static getByData(arg0: Buffer): org$bukkit$CropState;
}


declare interface $org$bukkit$enchantments$EnchantmentOffer {
  getEnchantment(): org$bukkit$enchantments$Enchantment;
  setEnchantment(arg0: org$bukkit$enchantments$Enchantment): void;
  getEnchantmentLevel(): number;
  setEnchantmentLevel(arg0: number): void;
  getCost(): number;
  setCost(arg0: number): void;
}

declare class org$bukkit$enchantments$EnchantmentOffer
  implements $org$bukkit$enchantments$EnchantmentOffer {
  constructor(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: number
  );
  getEnchantment(): org$bukkit$enchantments$Enchantment;
  setEnchantment(arg0: org$bukkit$enchantments$Enchantment): void;
  getEnchantmentLevel(): number;
  setEnchantmentLevel(arg0: number): void;
  getCost(): number;
  setCost(arg0: number): void;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$10 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$10
  implements $org$bukkit$enchantments$EnchantmentTarget$10 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$11 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$11
  implements $org$bukkit$enchantments$EnchantmentTarget$11 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$12 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$12
  implements $org$bukkit$enchantments$EnchantmentTarget$12 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$13 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$13
  implements $org$bukkit$enchantments$EnchantmentTarget$13 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$14 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$14
  implements $org$bukkit$enchantments$EnchantmentTarget$14 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$2 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$2
  implements $org$bukkit$enchantments$EnchantmentTarget$2 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$3 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$3
  implements $org$bukkit$enchantments$EnchantmentTarget$3 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$4 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$4
  implements $org$bukkit$enchantments$EnchantmentTarget$4 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$5 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$5
  implements $org$bukkit$enchantments$EnchantmentTarget$5 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$6 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$6
  implements $org$bukkit$enchantments$EnchantmentTarget$6 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$7 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$7
  implements $org$bukkit$enchantments$EnchantmentTarget$7 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$8 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$8
  implements $org$bukkit$enchantments$EnchantmentTarget$8 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentTarget$9 {
  includes(arg0: org$bukkit$Material): boolean;
}

declare class org$bukkit$enchantments$EnchantmentTarget$9
  implements $org$bukkit$enchantments$EnchantmentTarget$9 {
  constructor(arg0: string, arg1: number);
  includes(arg0: org$bukkit$Material): boolean;
}


declare interface $org$bukkit$enchantments$EnchantmentWrapper {
  getEnchantment(): org$bukkit$enchantments$Enchantment;
  getMaxLevel(): number;
  getStartLevel(): number;
  getItemTarget(): org$bukkit$enchantments$EnchantmentTarget;
  canEnchantItem(arg0: org$bukkit$inventory$ItemStack): boolean;
  getName(): string;
  isTreasure(): boolean;
  isCursed(): boolean;
  conflictsWith(arg0: org$bukkit$enchantments$Enchantment): boolean;
}

declare class org$bukkit$enchantments$EnchantmentWrapper
  implements $org$bukkit$enchantments$EnchantmentWrapper {
  constructor(arg0: string);
  getEnchantment(): org$bukkit$enchantments$Enchantment;
  getMaxLevel(): number;
  getStartLevel(): number;
  getItemTarget(): org$bukkit$enchantments$EnchantmentTarget;
  canEnchantItem(arg0: org$bukkit$inventory$ItemStack): boolean;
  getName(): string;
  isTreasure(): boolean;
  isCursed(): boolean;
  conflictsWith(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getKey(): org$bukkit$NamespacedKey;
}


declare interface $org$bukkit$entity$Ambient extends $org$bukkit$entity$Mob {}

declare class org$bukkit$entity$Ambient implements $org$bukkit$entity$Ambient {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ArmorStand
  extends $org$bukkit$entity$LivingEntity {
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getBoots(): org$bukkit$inventory$ItemStack;
  setBoots(arg0: org$bukkit$inventory$ItemStack): void;
  getLeggings(): org$bukkit$inventory$ItemStack;
  setLeggings(arg0: org$bukkit$inventory$ItemStack): void;
  getChestplate(): org$bukkit$inventory$ItemStack;
  setChestplate(arg0: org$bukkit$inventory$ItemStack): void;
  getHelmet(): org$bukkit$inventory$ItemStack;
  setHelmet(arg0: org$bukkit$inventory$ItemStack): void;
  getBodyPose(): org$bukkit$util$EulerAngle;
  setBodyPose(arg0: org$bukkit$util$EulerAngle): void;
  getLeftArmPose(): org$bukkit$util$EulerAngle;
  setLeftArmPose(arg0: org$bukkit$util$EulerAngle): void;
  getRightArmPose(): org$bukkit$util$EulerAngle;
  setRightArmPose(arg0: org$bukkit$util$EulerAngle): void;
  getLeftLegPose(): org$bukkit$util$EulerAngle;
  setLeftLegPose(arg0: org$bukkit$util$EulerAngle): void;
  getRightLegPose(): org$bukkit$util$EulerAngle;
  setRightLegPose(arg0: org$bukkit$util$EulerAngle): void;
  getHeadPose(): org$bukkit$util$EulerAngle;
  setHeadPose(arg0: org$bukkit$util$EulerAngle): void;
  hasBasePlate(): boolean;
  setBasePlate(arg0: boolean): void;
  isVisible(): boolean;
  setVisible(arg0: boolean): void;
  hasArms(): boolean;
  setArms(arg0: boolean): void;
  isSmall(): boolean;
  setSmall(arg0: boolean): void;
  isMarker(): boolean;
  setMarker(arg0: boolean): void;
  canMove(): boolean;
  setCanMove(arg0: boolean): void;
  canTick(): boolean;
  setCanTick(arg0: boolean): void;
  getItem(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): org$bukkit$inventory$ItemStack;
  setItem(
    arg0: org$bukkit$inventory$EquipmentSlot,
    arg1: org$bukkit$inventory$ItemStack
  ): void;
  getDisabledSlots(): any /* java.util.Set */;
  setDisabledSlots(arg0: JavaArray<org$bukkit$inventory$EquipmentSlot>): void;
  addDisabledSlots(arg0: JavaArray<org$bukkit$inventory$EquipmentSlot>): void;
  removeDisabledSlots(
    arg0: JavaArray<org$bukkit$inventory$EquipmentSlot>
  ): void;
  isSlotDisabled(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
}

declare class org$bukkit$entity$ArmorStand
  implements $org$bukkit$entity$ArmorStand {
  getItemInHand(): org$bukkit$inventory$ItemStack;
  setItemInHand(arg0: org$bukkit$inventory$ItemStack): void;
  getBoots(): org$bukkit$inventory$ItemStack;
  setBoots(arg0: org$bukkit$inventory$ItemStack): void;
  getLeggings(): org$bukkit$inventory$ItemStack;
  setLeggings(arg0: org$bukkit$inventory$ItemStack): void;
  getChestplate(): org$bukkit$inventory$ItemStack;
  setChestplate(arg0: org$bukkit$inventory$ItemStack): void;
  getHelmet(): org$bukkit$inventory$ItemStack;
  setHelmet(arg0: org$bukkit$inventory$ItemStack): void;
  getBodyPose(): org$bukkit$util$EulerAngle;
  setBodyPose(arg0: org$bukkit$util$EulerAngle): void;
  getLeftArmPose(): org$bukkit$util$EulerAngle;
  setLeftArmPose(arg0: org$bukkit$util$EulerAngle): void;
  getRightArmPose(): org$bukkit$util$EulerAngle;
  setRightArmPose(arg0: org$bukkit$util$EulerAngle): void;
  getLeftLegPose(): org$bukkit$util$EulerAngle;
  setLeftLegPose(arg0: org$bukkit$util$EulerAngle): void;
  getRightLegPose(): org$bukkit$util$EulerAngle;
  setRightLegPose(arg0: org$bukkit$util$EulerAngle): void;
  getHeadPose(): org$bukkit$util$EulerAngle;
  setHeadPose(arg0: org$bukkit$util$EulerAngle): void;
  hasBasePlate(): boolean;
  setBasePlate(arg0: boolean): void;
  isVisible(): boolean;
  setVisible(arg0: boolean): void;
  hasArms(): boolean;
  setArms(arg0: boolean): void;
  isSmall(): boolean;
  setSmall(arg0: boolean): void;
  isMarker(): boolean;
  setMarker(arg0: boolean): void;
  canMove(): boolean;
  setCanMove(arg0: boolean): void;
  canTick(): boolean;
  setCanTick(arg0: boolean): void;
  getItem(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): org$bukkit$inventory$ItemStack;
  setItem(
    arg0: org$bukkit$inventory$EquipmentSlot,
    arg1: org$bukkit$inventory$ItemStack
  ): void;
  getDisabledSlots(): any /* java.util.Set */;
  setDisabledSlots(arg0: JavaArray<org$bukkit$inventory$EquipmentSlot>): void;
  addDisabledSlots(arg0: JavaArray<org$bukkit$inventory$EquipmentSlot>): void;
  removeDisabledSlots(
    arg0: JavaArray<org$bukkit$inventory$EquipmentSlot>
  ): void;
  isSlotDisabled(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$util$EulerAngle {
  getX(): number;
  getY(): number;
  getZ(): number;
  setX(arg0: number): org$bukkit$util$EulerAngle;
  setY(arg0: number): org$bukkit$util$EulerAngle;
  setZ(arg0: number): org$bukkit$util$EulerAngle;
  add(arg0: number, arg1: number, arg2: number): org$bukkit$util$EulerAngle;
  subtract(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$util$EulerAngle;
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class org$bukkit$util$EulerAngle
  implements $org$bukkit$util$EulerAngle {
  static ZERO: org$bukkit$util$EulerAngle;
  constructor(arg0: number, arg1: number, arg2: number);
  getX(): number;
  getY(): number;
  getZ(): number;
  setX(arg0: number): org$bukkit$util$EulerAngle;
  setY(arg0: number): org$bukkit$util$EulerAngle;
  setZ(arg0: number): org$bukkit$util$EulerAngle;
  add(arg0: number, arg1: number, arg2: number): org$bukkit$util$EulerAngle;
  subtract(
    arg0: number,
    arg1: number,
    arg2: number
  ): org$bukkit$util$EulerAngle;
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $org$bukkit$entity$Bat extends $org$bukkit$entity$Ambient {
  isAwake(): boolean;
  setAwake(arg0: boolean): void;
}

declare class org$bukkit$entity$Bat implements $org$bukkit$entity$Bat {
  isAwake(): boolean;
  setAwake(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Bee extends $org$bukkit$entity$Animals {
  getHive(): org$bukkit$Location;
  setHive(arg0: org$bukkit$Location): void;
  getFlower(): org$bukkit$Location;
  setFlower(arg0: org$bukkit$Location): void;
  hasNectar(): boolean;
  setHasNectar(arg0: boolean): void;
  hasStung(): boolean;
  setHasStung(arg0: boolean): void;
  getAnger(): number;
  setAnger(arg0: number): void;
  getCannotEnterHiveTicks(): number;
  setCannotEnterHiveTicks(arg0: number): void;
}

declare class org$bukkit$entity$Bee implements $org$bukkit$entity$Bee {
  getHive(): org$bukkit$Location;
  setHive(arg0: org$bukkit$Location): void;
  getFlower(): org$bukkit$Location;
  setFlower(arg0: org$bukkit$Location): void;
  hasNectar(): boolean;
  setHasNectar(arg0: boolean): void;
  hasStung(): boolean;
  setHasStung(arg0: boolean): void;
  getAnger(): number;
  setAnger(arg0: number): void;
  getCannotEnterHiveTicks(): number;
  setCannotEnterHiveTicks(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Blaze extends $org$bukkit$entity$Monster {}

declare class org$bukkit$entity$Blaze implements $org$bukkit$entity$Blaze {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Boat extends $org$bukkit$entity$Vehicle {
  getWoodType(): org$bukkit$TreeSpecies;
  setWoodType(arg0: org$bukkit$TreeSpecies): void;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  getOccupiedDeceleration(): number;
  setOccupiedDeceleration(arg0: number): void;
  getUnoccupiedDeceleration(): number;
  setUnoccupiedDeceleration(arg0: number): void;
  getWorkOnLand(): boolean;
  setWorkOnLand(arg0: boolean): void;
}

declare class org$bukkit$entity$Boat implements $org$bukkit$entity$Boat {
  getWoodType(): org$bukkit$TreeSpecies;
  setWoodType(arg0: org$bukkit$TreeSpecies): void;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  getOccupiedDeceleration(): number;
  setOccupiedDeceleration(arg0: number): void;
  getUnoccupiedDeceleration(): number;
  setUnoccupiedDeceleration(arg0: number): void;
  getWorkOnLand(): boolean;
  setWorkOnLand(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$TreeSpecies {
  getData(): Buffer;
}

declare class org$bukkit$TreeSpecies implements $org$bukkit$TreeSpecies {
  static GENERIC: org$bukkit$TreeSpecies;
  static REDWOOD: org$bukkit$TreeSpecies;
  static BIRCH: org$bukkit$TreeSpecies;
  static JUNGLE: org$bukkit$TreeSpecies;
  static ACACIA: org$bukkit$TreeSpecies;
  static DARK_OAK: org$bukkit$TreeSpecies;
  static values(): JavaArray<org$bukkit$TreeSpecies>;
  static valueOf(arg0: string): org$bukkit$TreeSpecies;
  getData(): Buffer;
  static getByData(arg0: Buffer): org$bukkit$TreeSpecies;
}


declare interface $org$bukkit$entity$Cat
  extends $org$bukkit$entity$Tameable,
    $org$bukkit$entity$Sittable {
  getCatType(): org$bukkit$entity$Cat$Type;
  setCatType(arg0: org$bukkit$entity$Cat$Type): void;
  getCollarColor(): org$bukkit$DyeColor;
  setCollarColor(arg0: org$bukkit$DyeColor): void;
}

declare class org$bukkit$entity$Cat implements $org$bukkit$entity$Cat {
  getCatType(): org$bukkit$entity$Cat$Type;
  setCatType(arg0: org$bukkit$entity$Cat$Type): void;
  getCollarColor(): org$bukkit$DyeColor;
  setCollarColor(arg0: org$bukkit$DyeColor): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isSitting(): boolean;
  setSitting(arg0: boolean): void;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Sittable {
  isSitting(): boolean;
  setSitting(arg0: boolean): void;
}

declare class org$bukkit$entity$Sittable
  implements $org$bukkit$entity$Sittable {
  isSitting(): boolean;
  setSitting(arg0: boolean): void;
}


declare interface $org$bukkit$entity$Cat$Type {}

declare class org$bukkit$entity$Cat$Type
  implements $org$bukkit$entity$Cat$Type {
  static TABBY: org$bukkit$entity$Cat$Type;
  static BLACK: org$bukkit$entity$Cat$Type;
  static RED: org$bukkit$entity$Cat$Type;
  static SIAMESE: org$bukkit$entity$Cat$Type;
  static BRITISH_SHORTHAIR: org$bukkit$entity$Cat$Type;
  static CALICO: org$bukkit$entity$Cat$Type;
  static PERSIAN: org$bukkit$entity$Cat$Type;
  static RAGDOLL: org$bukkit$entity$Cat$Type;
  static WHITE: org$bukkit$entity$Cat$Type;
  static JELLIE: org$bukkit$entity$Cat$Type;
  static ALL_BLACK: org$bukkit$entity$Cat$Type;
  static values(): JavaArray<org$bukkit$entity$Cat$Type>;
  static valueOf(arg0: string): org$bukkit$entity$Cat$Type;
}


declare interface $org$bukkit$entity$CaveSpider
  extends $org$bukkit$entity$Spider {}

declare class org$bukkit$entity$CaveSpider
  implements $org$bukkit$entity$CaveSpider {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Spider
  extends $org$bukkit$entity$Monster {}

declare class org$bukkit$entity$Spider implements $org$bukkit$entity$Spider {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ChestedHorse
  extends $org$bukkit$entity$AbstractHorse {
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
}

declare class org$bukkit$entity$ChestedHorse
  implements $org$bukkit$entity$ChestedHorse {
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Chicken
  extends $org$bukkit$entity$Animals {}

declare class org$bukkit$entity$Chicken implements $org$bukkit$entity$Chicken {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Cod extends $org$bukkit$entity$Fish {}

declare class org$bukkit$entity$Cod implements $org$bukkit$entity$Cod {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Fish extends $org$bukkit$entity$WaterMob {}

declare class org$bukkit$entity$Fish implements $org$bukkit$entity$Fish {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$WaterMob
  extends $org$bukkit$entity$Creature {}

declare class org$bukkit$entity$WaterMob
  implements $org$bukkit$entity$WaterMob {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ComplexEntityPart
  extends $org$bukkit$entity$Entity {
  getParent(): org$bukkit$entity$ComplexLivingEntity;
}

declare class org$bukkit$entity$ComplexEntityPart
  implements $org$bukkit$entity$ComplexEntityPart {
  getParent(): org$bukkit$entity$ComplexLivingEntity;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Cow extends $org$bukkit$entity$Animals {}

declare class org$bukkit$entity$Cow implements $org$bukkit$entity$Cow {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Dolphin
  extends $org$bukkit$entity$WaterMob {}

declare class org$bukkit$entity$Dolphin implements $org$bukkit$entity$Dolphin {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Donkey
  extends $org$bukkit$entity$ChestedHorse {}

declare class org$bukkit$entity$Donkey implements $org$bukkit$entity$Donkey {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Drowned
  extends $org$bukkit$entity$Zombie,
    $com$destroystokyo$paper$entity$RangedEntity {}

declare class org$bukkit$entity$Drowned implements $org$bukkit$entity$Drowned {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isBaby(): boolean;
  setBaby(arg0: boolean): void;
  isVillager(): boolean;
  setVillager(arg0: boolean): void;
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  isDrowning(): boolean;
  startDrowning(arg0: number): void;
  stopDrowning(): void;
  setArmsRaised(arg0: boolean): void;
  isArmsRaised(): boolean;
  shouldBurnInDay(): boolean;
  setShouldBurnInDay(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Zombie extends $org$bukkit$entity$Monster {
  isBaby(): boolean;
  setBaby(arg0: boolean): void;
  isVillager(): boolean;
  setVillager(arg0: boolean): void;
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  isDrowning(): boolean;
  startDrowning(arg0: number): void;
  stopDrowning(): void;
  setArmsRaised(arg0: boolean): void;
  isArmsRaised(): boolean;
  shouldBurnInDay(): boolean;
  setShouldBurnInDay(arg0: boolean): void;
}

declare class org$bukkit$entity$Zombie implements $org$bukkit$entity$Zombie {
  isBaby(): boolean;
  setBaby(arg0: boolean): void;
  isVillager(): boolean;
  setVillager(arg0: boolean): void;
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  isDrowning(): boolean;
  startDrowning(arg0: number): void;
  stopDrowning(): void;
  setArmsRaised(arg0: boolean): void;
  isArmsRaised(): boolean;
  shouldBurnInDay(): boolean;
  setShouldBurnInDay(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ElderGuardian
  extends $org$bukkit$entity$Guardian {}

declare class org$bukkit$entity$ElderGuardian
  implements $org$bukkit$entity$ElderGuardian {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  isElder(): boolean;
  setElder(arg0: boolean): void;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Guardian
  extends $org$bukkit$entity$Monster {
  isElder(): boolean;
  setElder(arg0: boolean): void;
}

declare class org$bukkit$entity$Guardian
  implements $org$bukkit$entity$Guardian {
  isElder(): boolean;
  setElder(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$EnderCrystal
  extends $org$bukkit$entity$Entity {
  isShowingBottom(): boolean;
  setShowingBottom(arg0: boolean): void;
  getBeamTarget(): org$bukkit$Location;
  setBeamTarget(arg0: org$bukkit$Location): void;
}

declare class org$bukkit$entity$EnderCrystal
  implements $org$bukkit$entity$EnderCrystal {
  isShowingBottom(): boolean;
  setShowingBottom(arg0: boolean): void;
  getBeamTarget(): org$bukkit$Location;
  setBeamTarget(arg0: org$bukkit$Location): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$EnderDragonPart
  extends $org$bukkit$entity$ComplexEntityPart,
    $org$bukkit$entity$Damageable {
  getParent(): org$bukkit$entity$EnderDragon;
  getParent(): org$bukkit$entity$ComplexLivingEntity;
}

declare class org$bukkit$entity$EnderDragonPart
  implements $org$bukkit$entity$EnderDragonPart {
  getParent(): org$bukkit$entity$EnderDragon;
  getParent(): org$bukkit$entity$ComplexLivingEntity;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Endermite
  extends $org$bukkit$entity$Monster {
  isPlayerSpawned(): boolean;
  setPlayerSpawned(arg0: boolean): void;
}

declare class org$bukkit$entity$Endermite
  implements $org$bukkit$entity$Endermite {
  isPlayerSpawned(): boolean;
  setPlayerSpawned(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$EnderPearl
  extends $org$bukkit$entity$ThrowableProjectile {}

declare class org$bukkit$entity$EnderPearl
  implements $org$bukkit$entity$EnderPearl {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$EnderSignal
  extends $org$bukkit$entity$Entity {
  getTargetLocation(): org$bukkit$Location;
  setTargetLocation(arg0: org$bukkit$Location): void;
  getDropItem(): boolean;
  setDropItem(arg0: boolean): void;
  getDespawnTimer(): number;
  setDespawnTimer(arg0: number): void;
}

declare class org$bukkit$entity$EnderSignal
  implements $org$bukkit$entity$EnderSignal {
  getTargetLocation(): org$bukkit$Location;
  setTargetLocation(arg0: org$bukkit$Location): void;
  getDropItem(): boolean;
  setDropItem(arg0: boolean): void;
  getDespawnTimer(): number;
  setDespawnTimer(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Evoker
  extends $org$bukkit$entity$Spellcaster {
  getCurrentSpell(): org$bukkit$entity$Evoker$Spell;
  setCurrentSpell(arg0: org$bukkit$entity$Evoker$Spell): void;
}

declare class org$bukkit$entity$Evoker implements $org$bukkit$entity$Evoker {
  getCurrentSpell(): org$bukkit$entity$Evoker$Spell;
  setCurrentSpell(arg0: org$bukkit$entity$Evoker$Spell): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  getSpell(): org$bukkit$entity$Spellcaster$Spell;
  setSpell(arg0: org$bukkit$entity$Spellcaster$Spell): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Illager
  extends $org$bukkit$entity$Raider {}

declare class org$bukkit$entity$Illager implements $org$bukkit$entity$Illager {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Spellcaster
  extends $org$bukkit$entity$Illager {
  getSpell(): org$bukkit$entity$Spellcaster$Spell;
  setSpell(arg0: org$bukkit$entity$Spellcaster$Spell): void;
}

declare class org$bukkit$entity$Spellcaster
  implements $org$bukkit$entity$Spellcaster {
  getSpell(): org$bukkit$entity$Spellcaster$Spell;
  setSpell(arg0: org$bukkit$entity$Spellcaster$Spell): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Spellcaster$Spell {}

declare class org$bukkit$entity$Spellcaster$Spell
  implements $org$bukkit$entity$Spellcaster$Spell {
  static NONE: org$bukkit$entity$Spellcaster$Spell;
  static SUMMON_VEX: org$bukkit$entity$Spellcaster$Spell;
  static FANGS: org$bukkit$entity$Spellcaster$Spell;
  static WOLOLO: org$bukkit$entity$Spellcaster$Spell;
  static DISAPPEAR: org$bukkit$entity$Spellcaster$Spell;
  static BLINDNESS: org$bukkit$entity$Spellcaster$Spell;
  static values(): JavaArray<org$bukkit$entity$Spellcaster$Spell>;
  static valueOf(arg0: string): org$bukkit$entity$Spellcaster$Spell;
}


declare interface $org$bukkit$entity$Evoker$Spell {}

declare class org$bukkit$entity$Evoker$Spell
  implements $org$bukkit$entity$Evoker$Spell {
  static NONE: org$bukkit$entity$Evoker$Spell;
  static SUMMON: org$bukkit$entity$Evoker$Spell;
  static FANGS: org$bukkit$entity$Evoker$Spell;
  static WOLOLO: org$bukkit$entity$Evoker$Spell;
  static DISAPPEAR: org$bukkit$entity$Evoker$Spell;
  static BLINDNESS: org$bukkit$entity$Evoker$Spell;
  static values(): JavaArray<org$bukkit$entity$Evoker$Spell>;
  static valueOf(arg0: string): org$bukkit$entity$Evoker$Spell;
}


declare interface $org$bukkit$entity$EvokerFangs
  extends $org$bukkit$entity$Entity {
  getOwner(): org$bukkit$entity$LivingEntity;
  setOwner(arg0: org$bukkit$entity$LivingEntity): void;
}

declare class org$bukkit$entity$EvokerFangs
  implements $org$bukkit$entity$EvokerFangs {
  getOwner(): org$bukkit$entity$LivingEntity;
  setOwner(arg0: org$bukkit$entity$LivingEntity): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$FishHook
  extends $org$bukkit$entity$Projectile {
  getBiteChance(): number;
  setBiteChance(arg0: number): void;
}

declare class org$bukkit$entity$FishHook
  implements $org$bukkit$entity$FishHook {
  getBiteChance(): number;
  setBiteChance(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Flying extends $org$bukkit$entity$Mob {}

declare class org$bukkit$entity$Flying implements $org$bukkit$entity$Flying {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Fox
  extends $org$bukkit$entity$Animals,
    $org$bukkit$entity$Sittable {
  getFoxType(): org$bukkit$entity$Fox$Type;
  setFoxType(arg0: org$bukkit$entity$Fox$Type): void;
  isCrouching(): boolean;
  setCrouching(arg0: boolean): void;
  setSleeping(arg0: boolean): void;
  getFirstTrustedPlayer(): org$bukkit$entity$AnimalTamer;
  setFirstTrustedPlayer(arg0: org$bukkit$entity$AnimalTamer): void;
  getSecondTrustedPlayer(): org$bukkit$entity$AnimalTamer;
  setSecondTrustedPlayer(arg0: org$bukkit$entity$AnimalTamer): void;
}

declare class org$bukkit$entity$Fox implements $org$bukkit$entity$Fox {
  getFoxType(): org$bukkit$entity$Fox$Type;
  setFoxType(arg0: org$bukkit$entity$Fox$Type): void;
  isCrouching(): boolean;
  setCrouching(arg0: boolean): void;
  setSleeping(arg0: boolean): void;
  getFirstTrustedPlayer(): org$bukkit$entity$AnimalTamer;
  setFirstTrustedPlayer(arg0: org$bukkit$entity$AnimalTamer): void;
  getSecondTrustedPlayer(): org$bukkit$entity$AnimalTamer;
  setSecondTrustedPlayer(arg0: org$bukkit$entity$AnimalTamer): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isSitting(): boolean;
  setSitting(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Fox$Type {}

declare class org$bukkit$entity$Fox$Type
  implements $org$bukkit$entity$Fox$Type {
  static RED: org$bukkit$entity$Fox$Type;
  static SNOW: org$bukkit$entity$Fox$Type;
  static values(): JavaArray<org$bukkit$entity$Fox$Type>;
  static valueOf(arg0: string): org$bukkit$entity$Fox$Type;
}


declare interface $org$bukkit$entity$Ghast extends $org$bukkit$entity$Flying {}

declare class org$bukkit$entity$Ghast implements $org$bukkit$entity$Ghast {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Giant extends $org$bukkit$entity$Monster {}

declare class org$bukkit$entity$Giant implements $org$bukkit$entity$Giant {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Golem
  extends $org$bukkit$entity$Creature {}

declare class org$bukkit$entity$Golem implements $org$bukkit$entity$Golem {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Hanging
  extends $org$bukkit$entity$Entity,
    $org$bukkit$material$Attachable {
  setFacingDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): boolean;
}

declare class org$bukkit$entity$Hanging implements $org$bukkit$entity$Hanging {
  setFacingDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$material$Attachable
  extends $org$bukkit$material$Directional {
  getAttachedFace(): org$bukkit$block$BlockFace;
}

declare class org$bukkit$material$Attachable
  implements $org$bukkit$material$Attachable {
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Directional {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}

declare class org$bukkit$material$Directional
  implements $org$bukkit$material$Directional {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$entity$Horse
  extends $org$bukkit$entity$AbstractHorse {
  getColor(): org$bukkit$entity$Horse$Color;
  setColor(arg0: org$bukkit$entity$Horse$Color): void;
  getStyle(): org$bukkit$entity$Horse$Style;
  setStyle(arg0: org$bukkit$entity$Horse$Style): void;
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  getInventory(): org$bukkit$inventory$HorseInventory;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$entity$Horse implements $org$bukkit$entity$Horse {
  getColor(): org$bukkit$entity$Horse$Color;
  setColor(arg0: org$bukkit$entity$Horse$Color): void;
  getStyle(): org$bukkit$entity$Horse$Style;
  setStyle(arg0: org$bukkit$entity$Horse$Style): void;
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  getInventory(): org$bukkit$inventory$HorseInventory;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Horse$Color {}

declare class org$bukkit$entity$Horse$Color
  implements $org$bukkit$entity$Horse$Color {
  static WHITE: org$bukkit$entity$Horse$Color;
  static CREAMY: org$bukkit$entity$Horse$Color;
  static CHESTNUT: org$bukkit$entity$Horse$Color;
  static BROWN: org$bukkit$entity$Horse$Color;
  static BLACK: org$bukkit$entity$Horse$Color;
  static GRAY: org$bukkit$entity$Horse$Color;
  static DARK_BROWN: org$bukkit$entity$Horse$Color;
  static values(): JavaArray<org$bukkit$entity$Horse$Color>;
  static valueOf(arg0: string): org$bukkit$entity$Horse$Color;
}


declare interface $org$bukkit$entity$Horse$Style {}

declare class org$bukkit$entity$Horse$Style
  implements $org$bukkit$entity$Horse$Style {
  static NONE: org$bukkit$entity$Horse$Style;
  static WHITE: org$bukkit$entity$Horse$Style;
  static WHITEFIELD: org$bukkit$entity$Horse$Style;
  static WHITE_DOTS: org$bukkit$entity$Horse$Style;
  static BLACK_DOTS: org$bukkit$entity$Horse$Style;
  static values(): JavaArray<org$bukkit$entity$Horse$Style>;
  static valueOf(arg0: string): org$bukkit$entity$Horse$Style;
}


declare interface $org$bukkit$inventory$HorseInventory
  extends $org$bukkit$inventory$AbstractHorseInventory,
    $org$bukkit$inventory$ArmoredHorseInventory {}

declare class org$bukkit$inventory$HorseInventory
  implements $org$bukkit$inventory$HorseInventory {
  getSaddle(): org$bukkit$inventory$ItemStack;
  setSaddle(arg0: org$bukkit$inventory$ItemStack): void;
  getArmor(): org$bukkit$inventory$ItemStack;
  setArmor(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$ArmoredHorseInventory
  extends $org$bukkit$inventory$AbstractHorseInventory {
  getArmor(): org$bukkit$inventory$ItemStack;
  setArmor(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$ArmoredHorseInventory
  implements $org$bukkit$inventory$ArmoredHorseInventory {
  getArmor(): org$bukkit$inventory$ItemStack;
  setArmor(arg0: org$bukkit$inventory$ItemStack): void;
  getSaddle(): org$bukkit$inventory$ItemStack;
  setSaddle(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$entity$Husk extends $org$bukkit$entity$Zombie {
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
}

declare class org$bukkit$entity$Husk implements $org$bukkit$entity$Husk {
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isBaby(): boolean;
  setBaby(arg0: boolean): void;
  isVillager(): boolean;
  setVillager(arg0: boolean): void;
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  isDrowning(): boolean;
  startDrowning(arg0: number): void;
  stopDrowning(): void;
  setArmsRaised(arg0: boolean): void;
  isArmsRaised(): boolean;
  shouldBurnInDay(): boolean;
  setShouldBurnInDay(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Illusioner
  extends $org$bukkit$entity$Spellcaster,
    $com$destroystokyo$paper$entity$RangedEntity {}

declare class org$bukkit$entity$Illusioner
  implements $org$bukkit$entity$Illusioner {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  getSpell(): org$bukkit$entity$Spellcaster$Spell;
  setSpell(arg0: org$bukkit$entity$Spellcaster$Spell): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$IronGolem
  extends $org$bukkit$entity$Golem {
  isPlayerCreated(): boolean;
  setPlayerCreated(arg0: boolean): void;
}

declare class org$bukkit$entity$IronGolem
  implements $org$bukkit$entity$IronGolem {
  isPlayerCreated(): boolean;
  setPlayerCreated(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ItemFrame
  extends $org$bukkit$entity$Hanging {
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setItem(arg0: org$bukkit$inventory$ItemStack, arg1: boolean): void;
  getRotation(): org$bukkit$Rotation;
  setRotation(arg0: org$bukkit$Rotation): void;
}

declare class org$bukkit$entity$ItemFrame
  implements $org$bukkit$entity$ItemFrame {
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setItem(arg0: org$bukkit$inventory$ItemStack, arg1: boolean): void;
  getRotation(): org$bukkit$Rotation;
  setRotation(arg0: org$bukkit$Rotation): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setFacingDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$Rotation {
  rotateClockwise(): org$bukkit$Rotation;
  rotateCounterClockwise(): org$bukkit$Rotation;
}

declare class org$bukkit$Rotation implements $org$bukkit$Rotation {
  static NONE: org$bukkit$Rotation;
  static CLOCKWISE_45: org$bukkit$Rotation;
  static CLOCKWISE: org$bukkit$Rotation;
  static CLOCKWISE_135: org$bukkit$Rotation;
  static FLIPPED: org$bukkit$Rotation;
  static FLIPPED_45: org$bukkit$Rotation;
  static COUNTER_CLOCKWISE: org$bukkit$Rotation;
  static COUNTER_CLOCKWISE_45: org$bukkit$Rotation;
  static values(): JavaArray<org$bukkit$Rotation>;
  static valueOf(arg0: string): org$bukkit$Rotation;
  rotateClockwise(): org$bukkit$Rotation;
  rotateCounterClockwise(): org$bukkit$Rotation;
}


declare interface $org$bukkit$entity$LargeFireball
  extends $org$bukkit$entity$SizedFireball {}

declare class org$bukkit$entity$LargeFireball
  implements $org$bukkit$entity$LargeFireball {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getDisplayItem(): org$bukkit$inventory$ItemStack;
  setDisplayItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$SizedFireball
  extends $org$bukkit$entity$Fireball {
  getDisplayItem(): org$bukkit$inventory$ItemStack;
  setDisplayItem(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$entity$SizedFireball
  implements $org$bukkit$entity$SizedFireball {
  getDisplayItem(): org$bukkit$inventory$ItemStack;
  setDisplayItem(arg0: org$bukkit$inventory$ItemStack): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$LeashHitch
  extends $org$bukkit$entity$Hanging {}

declare class org$bukkit$entity$LeashHitch
  implements $org$bukkit$entity$LeashHitch {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setFacingDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$LingeringPotion
  extends $org$bukkit$entity$ThrownPotion {}

declare class org$bukkit$entity$LingeringPotion
  implements $org$bukkit$entity$LingeringPotion {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getEffects(): java$util$Collection;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$ThrownPotion
  extends $org$bukkit$entity$Projectile {
  getEffects(): java$util$Collection;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$entity$ThrownPotion
  implements $org$bukkit$entity$ThrownPotion {
  getEffects(): java$util$Collection;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Llama
  extends $org$bukkit$entity$ChestedHorse,
    $com$destroystokyo$paper$entity$RangedEntity {
  getColor(): org$bukkit$entity$Llama$Color;
  setColor(arg0: org$bukkit$entity$Llama$Color): void;
  getStrength(): number;
  setStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$LlamaInventory;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$entity$Llama implements $org$bukkit$entity$Llama {
  getColor(): org$bukkit$entity$Llama$Color;
  setColor(arg0: org$bukkit$entity$Llama$Color): void;
  getStrength(): number;
  setStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$LlamaInventory;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Llama$Color {}

declare class org$bukkit$entity$Llama$Color
  implements $org$bukkit$entity$Llama$Color {
  static CREAMY: org$bukkit$entity$Llama$Color;
  static WHITE: org$bukkit$entity$Llama$Color;
  static BROWN: org$bukkit$entity$Llama$Color;
  static GRAY: org$bukkit$entity$Llama$Color;
  static values(): JavaArray<org$bukkit$entity$Llama$Color>;
  static valueOf(arg0: string): org$bukkit$entity$Llama$Color;
}


declare interface $org$bukkit$inventory$LlamaInventory
  extends $org$bukkit$inventory$SaddledHorseInventory {
  getDecor(): org$bukkit$inventory$ItemStack;
  setDecor(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$LlamaInventory
  implements $org$bukkit$inventory$LlamaInventory {
  getDecor(): org$bukkit$inventory$ItemStack;
  setDecor(arg0: org$bukkit$inventory$ItemStack): void;
  getSaddle(): org$bukkit$inventory$ItemStack;
  setSaddle(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$SaddledHorseInventory
  extends $org$bukkit$inventory$AbstractHorseInventory {}

declare class org$bukkit$inventory$SaddledHorseInventory
  implements $org$bukkit$inventory$SaddledHorseInventory {
  getSaddle(): org$bukkit$inventory$ItemStack;
  setSaddle(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$entity$LlamaSpit
  extends $org$bukkit$entity$Projectile {}

declare class org$bukkit$entity$LlamaSpit
  implements $org$bukkit$entity$LlamaSpit {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$MagmaCube
  extends $org$bukkit$entity$Slime {}

declare class org$bukkit$entity$MagmaCube
  implements $org$bukkit$entity$MagmaCube {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getSize(): number;
  setSize(arg0: number): void;
  canWander(): boolean;
  setWander(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Minecart
  extends $org$bukkit$entity$Vehicle {
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
}

declare class org$bukkit$entity$Minecart
  implements $org$bukkit$entity$Minecart {
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$CommandMinecart
  extends $org$bukkit$entity$Minecart {
  getCommand(): string;
  setCommand(arg0: string): void;
  setName(arg0: string): void;
}

declare class org$bukkit$entity$minecart$CommandMinecart
  implements $org$bukkit$entity$minecart$CommandMinecart {
  getCommand(): string;
  setCommand(arg0: string): void;
  setName(arg0: string): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$ExplosiveMinecart
  extends $org$bukkit$entity$Minecart {}

declare class org$bukkit$entity$minecart$ExplosiveMinecart
  implements $org$bukkit$entity$minecart$ExplosiveMinecart {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$HopperMinecart
  extends $org$bukkit$entity$Minecart,
    $org$bukkit$inventory$InventoryHolder,
    $com$destroystokyo$paper$loottable$LootableEntityInventory {
  isEnabled(): boolean;
  setEnabled(arg0: boolean): void;
}

declare class org$bukkit$entity$minecart$HopperMinecart
  implements $org$bukkit$entity$minecart$HopperMinecart {
  isEnabled(): boolean;
  setEnabled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  getInventory(): org$bukkit$inventory$Inventory;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$PoweredMinecart
  extends $org$bukkit$entity$Minecart {}

declare class org$bukkit$entity$minecart$PoweredMinecart
  implements $org$bukkit$entity$minecart$PoweredMinecart {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$RideableMinecart
  extends $org$bukkit$entity$Minecart {}

declare class org$bukkit$entity$minecart$RideableMinecart
  implements $org$bukkit$entity$minecart$RideableMinecart {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$SpawnerMinecart
  extends $org$bukkit$entity$Minecart {}

declare class org$bukkit$entity$minecart$SpawnerMinecart
  implements $org$bukkit$entity$minecart$SpawnerMinecart {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$minecart$StorageMinecart
  extends $org$bukkit$entity$Minecart,
    $org$bukkit$inventory$InventoryHolder,
    $com$destroystokyo$paper$loottable$LootableEntityInventory {}

declare class org$bukkit$entity$minecart$StorageMinecart
  implements $org$bukkit$entity$minecart$StorageMinecart {
  getEntity(): org$bukkit$entity$Entity;
  isRefillEnabled(): boolean;
  hasBeenFilled(): boolean;
  hasPlayerLooted(arg0: org$bukkit$entity$Player): boolean;
  hasPlayerLooted(arg0: any /* java.util.UUID */): boolean;
  getLastLooted(arg0: org$bukkit$entity$Player): any /* java.lang.Long */;
  getLastLooted(arg0: any /* java.util.UUID */): any /* java.lang.Long */;
  setHasPlayerLooted(arg0: org$bukkit$entity$Player, arg1: boolean): boolean;
  setHasPlayerLooted(arg0: any /* java.util.UUID */, arg1: boolean): boolean;
  hasPendingRefill(): boolean;
  getLastFilled(): number;
  getNextRefill(): number;
  setNextRefill(arg0: number): number;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setDamage(arg0: number): void;
  getDamage(): number;
  getMaxSpeed(): number;
  setMaxSpeed(arg0: number): void;
  isSlowWhenEmpty(): boolean;
  setSlowWhenEmpty(arg0: boolean): void;
  getFlyingVelocityMod(): org$bukkit$util$Vector;
  setFlyingVelocityMod(arg0: org$bukkit$util$Vector): void;
  getDerailedVelocityMod(): org$bukkit$util$Vector;
  setDerailedVelocityMod(arg0: org$bukkit$util$Vector): void;
  setDisplayBlock(arg0: org$bukkit$material$MaterialData): void;
  getDisplayBlock(): org$bukkit$material$MaterialData;
  setDisplayBlockData(arg0: org$bukkit$block$data$BlockData): void;
  getDisplayBlockData(): org$bukkit$block$data$BlockData;
  setDisplayBlockOffset(arg0: number): void;
  getDisplayBlockOffset(): number;
  getInventory(): org$bukkit$inventory$Inventory;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Mule
  extends $org$bukkit$entity$ChestedHorse {}

declare class org$bukkit$entity$Mule implements $org$bukkit$entity$Mule {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$MushroomCow
  extends $org$bukkit$entity$Cow {
  getVariant(): org$bukkit$entity$MushroomCow$Variant;
  setVariant(arg0: org$bukkit$entity$MushroomCow$Variant): void;
}

declare class org$bukkit$entity$MushroomCow
  implements $org$bukkit$entity$MushroomCow {
  getVariant(): org$bukkit$entity$MushroomCow$Variant;
  setVariant(arg0: org$bukkit$entity$MushroomCow$Variant): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$MushroomCow$Variant {}

declare class org$bukkit$entity$MushroomCow$Variant
  implements $org$bukkit$entity$MushroomCow$Variant {
  static RED: org$bukkit$entity$MushroomCow$Variant;
  static BROWN: org$bukkit$entity$MushroomCow$Variant;
  static values(): JavaArray<org$bukkit$entity$MushroomCow$Variant>;
  static valueOf(arg0: string): org$bukkit$entity$MushroomCow$Variant;
}


declare interface $org$bukkit$entity$Ocelot extends $org$bukkit$entity$Animals {
  getCatType(): org$bukkit$entity$Ocelot$Type;
  setCatType(arg0: org$bukkit$entity$Ocelot$Type): void;
}

declare class org$bukkit$entity$Ocelot implements $org$bukkit$entity$Ocelot {
  getCatType(): org$bukkit$entity$Ocelot$Type;
  setCatType(arg0: org$bukkit$entity$Ocelot$Type): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Ocelot$Type {
  getId(): number;
}

declare class org$bukkit$entity$Ocelot$Type
  implements $org$bukkit$entity$Ocelot$Type {
  static WILD_OCELOT: org$bukkit$entity$Ocelot$Type;
  static BLACK_CAT: org$bukkit$entity$Ocelot$Type;
  static RED_CAT: org$bukkit$entity$Ocelot$Type;
  static SIAMESE_CAT: org$bukkit$entity$Ocelot$Type;
  static values(): JavaArray<org$bukkit$entity$Ocelot$Type>;
  static valueOf(arg0: string): org$bukkit$entity$Ocelot$Type;
  getId(): number;
  static getType(arg0: number): org$bukkit$entity$Ocelot$Type;
}


declare interface $org$bukkit$entity$Painting
  extends $org$bukkit$entity$Hanging {
  getArt(): org$bukkit$Art;
  setArt(arg0: org$bukkit$Art): boolean;
  setArt(arg0: org$bukkit$Art, arg1: boolean): boolean;
}

declare class org$bukkit$entity$Painting
  implements $org$bukkit$entity$Painting {
  getArt(): org$bukkit$Art;
  setArt(arg0: org$bukkit$Art): boolean;
  setArt(arg0: org$bukkit$Art, arg1: boolean): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setFacingDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Panda extends $org$bukkit$entity$Animals {
  getMainGene(): org$bukkit$entity$Panda$Gene;
  setMainGene(arg0: org$bukkit$entity$Panda$Gene): void;
  getHiddenGene(): org$bukkit$entity$Panda$Gene;
  setHiddenGene(arg0: org$bukkit$entity$Panda$Gene): void;
}

declare class org$bukkit$entity$Panda implements $org$bukkit$entity$Panda {
  getMainGene(): org$bukkit$entity$Panda$Gene;
  setMainGene(arg0: org$bukkit$entity$Panda$Gene): void;
  getHiddenGene(): org$bukkit$entity$Panda$Gene;
  setHiddenGene(arg0: org$bukkit$entity$Panda$Gene): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Panda$Gene {
  isRecessive(): boolean;
}

declare class org$bukkit$entity$Panda$Gene
  implements $org$bukkit$entity$Panda$Gene {
  static NORMAL: org$bukkit$entity$Panda$Gene;
  static LAZY: org$bukkit$entity$Panda$Gene;
  static WORRIED: org$bukkit$entity$Panda$Gene;
  static PLAYFUL: org$bukkit$entity$Panda$Gene;
  static BROWN: org$bukkit$entity$Panda$Gene;
  static WEAK: org$bukkit$entity$Panda$Gene;
  static AGGRESSIVE: org$bukkit$entity$Panda$Gene;
  static values(): JavaArray<org$bukkit$entity$Panda$Gene>;
  static valueOf(arg0: string): org$bukkit$entity$Panda$Gene;
  isRecessive(): boolean;
}


declare interface $org$bukkit$entity$Parrot
  extends $org$bukkit$entity$Tameable,
    $org$bukkit$entity$Sittable {
  getVariant(): org$bukkit$entity$Parrot$Variant;
  setVariant(arg0: org$bukkit$entity$Parrot$Variant): void;
}

declare class org$bukkit$entity$Parrot implements $org$bukkit$entity$Parrot {
  getVariant(): org$bukkit$entity$Parrot$Variant;
  setVariant(arg0: org$bukkit$entity$Parrot$Variant): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isSitting(): boolean;
  setSitting(arg0: boolean): void;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Parrot$Variant {}

declare class org$bukkit$entity$Parrot$Variant
  implements $org$bukkit$entity$Parrot$Variant {
  static RED: org$bukkit$entity$Parrot$Variant;
  static BLUE: org$bukkit$entity$Parrot$Variant;
  static GREEN: org$bukkit$entity$Parrot$Variant;
  static CYAN: org$bukkit$entity$Parrot$Variant;
  static GRAY: org$bukkit$entity$Parrot$Variant;
  static values(): JavaArray<org$bukkit$entity$Parrot$Variant>;
  static valueOf(arg0: string): org$bukkit$entity$Parrot$Variant;
}


declare interface $org$bukkit$entity$Phantom extends $org$bukkit$entity$Flying {
  getSize(): number;
  setSize(arg0: number): void;
  getSpawningEntity(): any /* java.util.UUID */;
}

declare class org$bukkit$entity$Phantom implements $org$bukkit$entity$Phantom {
  getSize(): number;
  setSize(arg0: number): void;
  getSpawningEntity(): any /* java.util.UUID */;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Pig
  extends $org$bukkit$entity$Animals,
    $org$bukkit$entity$Vehicle {
  hasSaddle(): boolean;
  setSaddle(arg0: boolean): void;
}

declare class org$bukkit$entity$Pig implements $org$bukkit$entity$Pig {
  hasSaddle(): boolean;
  setSaddle(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$PigZombie
  extends $org$bukkit$entity$Zombie {
  getAnger(): number;
  setAnger(arg0: number): void;
  setAngry(arg0: boolean): void;
  isAngry(): boolean;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
}

declare class org$bukkit$entity$PigZombie
  implements $org$bukkit$entity$PigZombie {
  getAnger(): number;
  setAnger(arg0: number): void;
  setAngry(arg0: boolean): void;
  isAngry(): boolean;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isBaby(): boolean;
  setBaby(arg0: boolean): void;
  isVillager(): boolean;
  setVillager(arg0: boolean): void;
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  isDrowning(): boolean;
  startDrowning(arg0: number): void;
  stopDrowning(): void;
  setArmsRaised(arg0: boolean): void;
  isArmsRaised(): boolean;
  shouldBurnInDay(): boolean;
  setShouldBurnInDay(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Pillager
  extends $org$bukkit$entity$Illager,
    $org$bukkit$inventory$InventoryHolder {}

declare class org$bukkit$entity$Pillager
  implements $org$bukkit$entity$Pillager {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  getInventory(): org$bukkit$inventory$Inventory;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$PolarBear
  extends $org$bukkit$entity$Animals {}

declare class org$bukkit$entity$PolarBear
  implements $org$bukkit$entity$PolarBear {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$PufferFish
  extends $org$bukkit$entity$Fish {
  getPuffState(): number;
  setPuffState(arg0: number): void;
}

declare class org$bukkit$entity$PufferFish
  implements $org$bukkit$entity$PufferFish {
  getPuffState(): number;
  setPuffState(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Rabbit extends $org$bukkit$entity$Animals {
  getRabbitType(): org$bukkit$entity$Rabbit$Type;
  setRabbitType(arg0: org$bukkit$entity$Rabbit$Type): void;
}

declare class org$bukkit$entity$Rabbit implements $org$bukkit$entity$Rabbit {
  getRabbitType(): org$bukkit$entity$Rabbit$Type;
  setRabbitType(arg0: org$bukkit$entity$Rabbit$Type): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Rabbit$Type {}

declare class org$bukkit$entity$Rabbit$Type
  implements $org$bukkit$entity$Rabbit$Type {
  static BROWN: org$bukkit$entity$Rabbit$Type;
  static WHITE: org$bukkit$entity$Rabbit$Type;
  static BLACK: org$bukkit$entity$Rabbit$Type;
  static BLACK_AND_WHITE: org$bukkit$entity$Rabbit$Type;
  static GOLD: org$bukkit$entity$Rabbit$Type;
  static SALT_AND_PEPPER: org$bukkit$entity$Rabbit$Type;
  static THE_KILLER_BUNNY: org$bukkit$entity$Rabbit$Type;
  static values(): JavaArray<org$bukkit$entity$Rabbit$Type>;
  static valueOf(arg0: string): org$bukkit$entity$Rabbit$Type;
}


declare interface $org$bukkit$entity$Ravager
  extends $org$bukkit$entity$Raider {}

declare class org$bukkit$entity$Ravager implements $org$bukkit$entity$Ravager {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Salmon extends $org$bukkit$entity$Fish {}

declare class org$bukkit$entity$Salmon implements $org$bukkit$entity$Salmon {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Sheep
  extends $org$bukkit$entity$Animals,
    $org$bukkit$material$Colorable {
  isSheared(): boolean;
  setSheared(arg0: boolean): void;
}

declare class org$bukkit$entity$Sheep implements $org$bukkit$entity$Sheep {
  isSheared(): boolean;
  setSheared(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Shulker
  extends $org$bukkit$entity$Golem,
    $org$bukkit$material$Colorable {}

declare class org$bukkit$entity$Shulker implements $org$bukkit$entity$Shulker {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ShulkerBullet
  extends $org$bukkit$entity$Projectile {
  getTarget(): org$bukkit$entity$Entity;
  setTarget(arg0: org$bukkit$entity$Entity): void;
}

declare class org$bukkit$entity$ShulkerBullet
  implements $org$bukkit$entity$ShulkerBullet {
  getTarget(): org$bukkit$entity$Entity;
  setTarget(arg0: org$bukkit$entity$Entity): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Silverfish
  extends $org$bukkit$entity$Monster {}

declare class org$bukkit$entity$Silverfish
  implements $org$bukkit$entity$Silverfish {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Skeleton
  extends $org$bukkit$entity$Monster,
    $com$destroystokyo$paper$entity$RangedEntity {
  getSkeletonType(): org$bukkit$entity$Skeleton$SkeletonType;
  setSkeletonType(arg0: org$bukkit$entity$Skeleton$SkeletonType): void;
}

declare class org$bukkit$entity$Skeleton
  implements $org$bukkit$entity$Skeleton {
  getSkeletonType(): org$bukkit$entity$Skeleton$SkeletonType;
  setSkeletonType(arg0: org$bukkit$entity$Skeleton$SkeletonType): void;
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Skeleton$SkeletonType {}

declare class org$bukkit$entity$Skeleton$SkeletonType
  implements $org$bukkit$entity$Skeleton$SkeletonType {
  static NORMAL: org$bukkit$entity$Skeleton$SkeletonType;
  static WITHER: org$bukkit$entity$Skeleton$SkeletonType;
  static STRAY: org$bukkit$entity$Skeleton$SkeletonType;
  static values(): JavaArray<org$bukkit$entity$Skeleton$SkeletonType>;
  static valueOf(arg0: string): org$bukkit$entity$Skeleton$SkeletonType;
}


declare interface $org$bukkit$entity$SmallFireball
  extends $org$bukkit$entity$SizedFireball {}

declare class org$bukkit$entity$SmallFireball
  implements $org$bukkit$entity$SmallFireball {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getDisplayItem(): org$bukkit$inventory$ItemStack;
  setDisplayItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Snowball
  extends $org$bukkit$entity$ThrowableProjectile {}

declare class org$bukkit$entity$Snowball
  implements $org$bukkit$entity$Snowball {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Snowman
  extends $org$bukkit$entity$Golem,
    $com$destroystokyo$paper$entity$RangedEntity {
  isDerp(): boolean;
  setDerp(arg0: boolean): void;
}

declare class org$bukkit$entity$Snowman implements $org$bukkit$entity$Snowman {
  isDerp(): boolean;
  setDerp(arg0: boolean): void;
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$SpectralArrow
  extends $org$bukkit$entity$AbstractArrow {
  getGlowingTicks(): number;
  setGlowingTicks(arg0: number): void;
}

declare class org$bukkit$entity$SpectralArrow
  implements $org$bukkit$entity$SpectralArrow {
  getGlowingTicks(): number;
  setGlowingTicks(arg0: number): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getKnockbackStrength(): number;
  setKnockbackStrength(arg0: number): void;
  getDamage(): number;
  setDamage(arg0: number): void;
  getPierceLevel(): number;
  setPierceLevel(arg0: number): void;
  isCritical(): boolean;
  setCritical(arg0: boolean): void;
  isInBlock(): boolean;
  getAttachedBlock(): org$bukkit$block$Block;
  getPickupStatus(): org$bukkit$entity$AbstractArrow$PickupStatus;
  setPickupStatus(arg0: org$bukkit$entity$AbstractArrow$PickupStatus): void;
  isShotFromCrossbow(): boolean;
  setShotFromCrossbow(arg0: boolean): void;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getPickupRule(): org$bukkit$entity$AbstractArrow$PickupRule;
  setPickupRule(arg0: org$bukkit$entity$AbstractArrow$PickupRule): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$SplashPotion
  extends $org$bukkit$entity$ThrownPotion {}

declare class org$bukkit$entity$SplashPotion
  implements $org$bukkit$entity$SplashPotion {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getEffects(): java$util$Collection;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Squid
  extends $org$bukkit$entity$WaterMob {}

declare class org$bukkit$entity$Squid implements $org$bukkit$entity$Squid {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Stray
  extends $org$bukkit$entity$Skeleton {}

declare class org$bukkit$entity$Stray implements $org$bukkit$entity$Stray {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getSkeletonType(): org$bukkit$entity$Skeleton$SkeletonType;
  setSkeletonType(arg0: org$bukkit$entity$Skeleton$SkeletonType): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ThrownExpBottle
  extends $org$bukkit$entity$ThrowableProjectile {}

declare class org$bukkit$entity$ThrownExpBottle
  implements $org$bukkit$entity$ThrownExpBottle {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$TippedArrow
  extends $org$bukkit$entity$Arrow {}

declare class org$bukkit$entity$TippedArrow
  implements $org$bukkit$entity$TippedArrow {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getKnockbackStrength(): number;
  setKnockbackStrength(arg0: number): void;
  getDamage(): number;
  setDamage(arg0: number): void;
  getPierceLevel(): number;
  setPierceLevel(arg0: number): void;
  isCritical(): boolean;
  setCritical(arg0: boolean): void;
  isInBlock(): boolean;
  getAttachedBlock(): org$bukkit$block$Block;
  getPickupStatus(): org$bukkit$entity$AbstractArrow$PickupStatus;
  setPickupStatus(arg0: org$bukkit$entity$AbstractArrow$PickupStatus): void;
  isShotFromCrossbow(): boolean;
  setShotFromCrossbow(arg0: boolean): void;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getPickupRule(): org$bukkit$entity$AbstractArrow$PickupRule;
  setPickupRule(arg0: org$bukkit$entity$AbstractArrow$PickupRule): void;
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$TNTPrimed
  extends $org$bukkit$entity$Explosive {
  setFuseTicks(arg0: number): void;
  getFuseTicks(): number;
  getSource(): org$bukkit$entity$Entity;
  getSourceLoc(): org$bukkit$Location;
}

declare class org$bukkit$entity$TNTPrimed
  implements $org$bukkit$entity$TNTPrimed {
  setFuseTicks(arg0: number): void;
  getFuseTicks(): number;
  getSource(): org$bukkit$entity$Entity;
  getSourceLoc(): org$bukkit$Location;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$TraderLlama
  extends $org$bukkit$entity$Llama {}

declare class org$bukkit$entity$TraderLlama
  implements $org$bukkit$entity$TraderLlama {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  isCarryingChest(): boolean;
  setCarryingChest(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getColor(): org$bukkit$entity$Llama$Color;
  setColor(arg0: org$bukkit$entity$Llama$Color): void;
  getStrength(): number;
  setStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$LlamaInventory;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Trident
  extends $org$bukkit$entity$AbstractArrow {}

declare class org$bukkit$entity$Trident implements $org$bukkit$entity$Trident {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getKnockbackStrength(): number;
  setKnockbackStrength(arg0: number): void;
  getDamage(): number;
  setDamage(arg0: number): void;
  getPierceLevel(): number;
  setPierceLevel(arg0: number): void;
  isCritical(): boolean;
  setCritical(arg0: boolean): void;
  isInBlock(): boolean;
  getAttachedBlock(): org$bukkit$block$Block;
  getPickupStatus(): org$bukkit$entity$AbstractArrow$PickupStatus;
  setPickupStatus(arg0: org$bukkit$entity$AbstractArrow$PickupStatus): void;
  isShotFromCrossbow(): boolean;
  setShotFromCrossbow(arg0: boolean): void;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getPickupRule(): org$bukkit$entity$AbstractArrow$PickupRule;
  setPickupRule(arg0: org$bukkit$entity$AbstractArrow$PickupRule): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$TropicalFish
  extends $org$bukkit$entity$Fish {
  getPatternColor(): org$bukkit$DyeColor;
  setPatternColor(arg0: org$bukkit$DyeColor): void;
  getBodyColor(): org$bukkit$DyeColor;
  setBodyColor(arg0: org$bukkit$DyeColor): void;
  getPattern(): org$bukkit$entity$TropicalFish$Pattern;
  setPattern(arg0: org$bukkit$entity$TropicalFish$Pattern): void;
}

declare class org$bukkit$entity$TropicalFish
  implements $org$bukkit$entity$TropicalFish {
  getPatternColor(): org$bukkit$DyeColor;
  setPatternColor(arg0: org$bukkit$DyeColor): void;
  getBodyColor(): org$bukkit$DyeColor;
  setBodyColor(arg0: org$bukkit$DyeColor): void;
  getPattern(): org$bukkit$entity$TropicalFish$Pattern;
  setPattern(arg0: org$bukkit$entity$TropicalFish$Pattern): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$TropicalFish$Pattern {}

declare class org$bukkit$entity$TropicalFish$Pattern
  implements $org$bukkit$entity$TropicalFish$Pattern {
  static KOB: org$bukkit$entity$TropicalFish$Pattern;
  static SUNSTREAK: org$bukkit$entity$TropicalFish$Pattern;
  static SNOOPER: org$bukkit$entity$TropicalFish$Pattern;
  static DASHER: org$bukkit$entity$TropicalFish$Pattern;
  static BRINELY: org$bukkit$entity$TropicalFish$Pattern;
  static SPOTTY: org$bukkit$entity$TropicalFish$Pattern;
  static FLOPPER: org$bukkit$entity$TropicalFish$Pattern;
  static STRIPEY: org$bukkit$entity$TropicalFish$Pattern;
  static GLITTER: org$bukkit$entity$TropicalFish$Pattern;
  static BLOCKFISH: org$bukkit$entity$TropicalFish$Pattern;
  static BETTY: org$bukkit$entity$TropicalFish$Pattern;
  static CLAYFISH: org$bukkit$entity$TropicalFish$Pattern;
  static values(): JavaArray<org$bukkit$entity$TropicalFish$Pattern>;
  static valueOf(arg0: string): org$bukkit$entity$TropicalFish$Pattern;
}


declare interface $org$bukkit$entity$Vex extends $org$bukkit$entity$Monster {
  isCharging(): boolean;
  setCharging(arg0: boolean): void;
  getSummoner(): org$bukkit$entity$Mob;
  setSummoner(arg0: org$bukkit$entity$Mob): void;
}

declare class org$bukkit$entity$Vex implements $org$bukkit$entity$Vex {
  isCharging(): boolean;
  setCharging(arg0: boolean): void;
  getSummoner(): org$bukkit$entity$Mob;
  setSummoner(arg0: org$bukkit$entity$Mob): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Vindicator
  extends $org$bukkit$entity$Illager {
  isJohnny(): boolean;
  setJohnny(arg0: boolean): void;
}

declare class org$bukkit$entity$Vindicator
  implements $org$bukkit$entity$Vindicator {
  isJohnny(): boolean;
  setJohnny(arg0: boolean): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getPatrolTarget(): org$bukkit$block$Block;
  setPatrolTarget(arg0: org$bukkit$block$Block): void;
  isPatrolLeader(): boolean;
  setPatrolLeader(arg0: boolean): void;
  isCanJoinRaid(): boolean;
  setCanJoinRaid(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$WanderingTrader
  extends $org$bukkit$entity$AbstractVillager {}

declare class org$bukkit$entity$WanderingTrader
  implements $org$bukkit$entity$WanderingTrader {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  getRecipe(arg0: number): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: number, arg1: org$bukkit$inventory$MerchantRecipe): void;
  getRecipeCount(): number;
  isTrading(): boolean;
  getTrader(): org$bukkit$entity$HumanEntity;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$Wither
  extends $org$bukkit$entity$Monster,
    $org$bukkit$entity$Boss,
    $com$destroystokyo$paper$entity$RangedEntity {}

declare class org$bukkit$entity$Wither implements $org$bukkit$entity$Wither {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getBossBar(): org$bukkit$boss$BossBar;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$WitherSkeleton
  extends $org$bukkit$entity$Skeleton {}

declare class org$bukkit$entity$WitherSkeleton
  implements $org$bukkit$entity$WitherSkeleton {
  rangedAttack(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  setChargingAttack(arg0: boolean): void;
  isChargingAttack(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  getSkeletonType(): org$bukkit$entity$Skeleton$SkeletonType;
  setSkeletonType(arg0: org$bukkit$entity$Skeleton$SkeletonType): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$WitherSkull
  extends $org$bukkit$entity$Fireball {
  setCharged(arg0: boolean): void;
  isCharged(): boolean;
}

declare class org$bukkit$entity$WitherSkull
  implements $org$bukkit$entity$WitherSkull {
  setCharged(arg0: boolean): void;
  isCharged(): boolean;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  setYield(arg0: number): void;
  getYield(): number;
  setIsIncendiary(arg0: boolean): void;
  isIncendiary(): boolean;
  setDirection(arg0: org$bukkit$util$Vector): void;
  getDirection(): org$bukkit$util$Vector;
  getShooter(): org$bukkit$projectiles$ProjectileSource;
  setShooter(arg0: org$bukkit$projectiles$ProjectileSource): void;
  doesBounce(): boolean;
  setBounce(arg0: boolean): void;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$entity$Wolf
  extends $org$bukkit$entity$Tameable,
    $org$bukkit$entity$Sittable {
  isAngry(): boolean;
  setAngry(arg0: boolean): void;
  getCollarColor(): org$bukkit$DyeColor;
  setCollarColor(arg0: org$bukkit$DyeColor): void;
}

declare class org$bukkit$entity$Wolf implements $org$bukkit$entity$Wolf {
  isAngry(): boolean;
  setAngry(arg0: boolean): void;
  getCollarColor(): org$bukkit$DyeColor;
  setCollarColor(arg0: org$bukkit$DyeColor): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isSitting(): boolean;
  setSitting(arg0: boolean): void;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ZombieHorse
  extends $org$bukkit$entity$AbstractHorse {}

declare class org$bukkit$entity$ZombieHorse
  implements $org$bukkit$entity$ZombieHorse {
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  getVariant(): org$bukkit$entity$Horse$Variant;
  setVariant(arg0: org$bukkit$entity$Horse$Variant): void;
  getDomestication(): number;
  setDomestication(arg0: number): void;
  getMaxDomestication(): number;
  setMaxDomestication(arg0: number): void;
  getJumpStrength(): number;
  setJumpStrength(arg0: number): void;
  getInventory(): org$bukkit$inventory$AbstractHorseInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  getAge(): number;
  setAge(arg0: number): void;
  setAgeLock(arg0: boolean): void;
  getAgeLock(): boolean;
  setBaby(): void;
  setAdult(): void;
  isAdult(): boolean;
  canBreed(): boolean;
  setBreed(arg0: boolean): void;
  getBreedCause(): any /* java.util.UUID */;
  setBreedCause(arg0: any /* java.util.UUID */): void;
  isLoveMode(): boolean;
  getLoveModeTicks(): number;
  setLoveModeTicks(arg0: number): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isTamed(): boolean;
  setTamed(arg0: boolean): void;
  getOwnerUniqueId(): any /* java.util.UUID */;
  getOwner(): org$bukkit$entity$AnimalTamer;
  setOwner(arg0: org$bukkit$entity$AnimalTamer): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$entity$ZombieVillager
  extends $org$bukkit$entity$Zombie {
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  getVillagerType(): org$bukkit$entity$Villager$Type;
  setVillagerType(arg0: org$bukkit$entity$Villager$Type): void;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  getConversionPlayer(): org$bukkit$OfflinePlayer;
  setConversionPlayer(arg0: org$bukkit$OfflinePlayer): void;
}

declare class org$bukkit$entity$ZombieVillager
  implements $org$bukkit$entity$ZombieVillager {
  setVillagerProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getVillagerProfession(): org$bukkit$entity$Villager$Profession;
  getVillagerType(): org$bukkit$entity$Villager$Type;
  setVillagerType(arg0: org$bukkit$entity$Villager$Type): void;
  isConverting(): boolean;
  getConversionTime(): number;
  setConversionTime(arg0: number): void;
  getConversionPlayer(): org$bukkit$OfflinePlayer;
  setConversionPlayer(arg0: org$bukkit$OfflinePlayer): void;
  getCustomName(): string;
  setCustomName(arg0: string): void;
  getAttribute(
    arg0: org$bukkit$attribute$Attribute
  ): org$bukkit$attribute$AttributeInstance;
  sendMessage(arg0: string): void;
  sendMessage(arg0: JavaArray<string>): void;
  getServer(): org$bukkit$Server;
  getName(): string;
  spigot(): org$bukkit$command$CommandSender$Spigot;
  sendMessage(arg0: unknown): void;
  sendMessage(arg0: JavaArray<unknown>): void;
  damage(arg0: number): void;
  damage(arg0: number, arg1: org$bukkit$entity$Entity): void;
  getHealth(): number;
  setHealth(arg0: number): void;
  getAbsorptionAmount(): number;
  setAbsorptionAmount(arg0: number): void;
  getMaxHealth(): number;
  setMaxHealth(arg0: number): void;
  resetMaxHealth(): void;
  getLocation(): org$bukkit$Location;
  getLocation(arg0: org$bukkit$Location): org$bukkit$Location;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getVelocity(): org$bukkit$util$Vector;
  getHeight(): number;
  getWidth(): number;
  getBoundingBox(): org$bukkit$util$BoundingBox;
  isOnGround(): boolean;
  getWorld(): org$bukkit$World;
  setRotation(arg0: number, arg1: number): void;
  teleport(arg0: org$bukkit$Location): boolean;
  teleport(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleport(arg0: org$bukkit$entity$Entity): boolean;
  teleport(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): boolean;
  teleportAsync(
    arg0: org$bukkit$Location
  ): any /* java.util.concurrent.CompletableFuture */;
  teleportAsync(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  ): any /* java.util.concurrent.CompletableFuture */;
  getNearbyEntities(
    arg0: number,
    arg1: number,
    arg2: number
  ): any /* java.util.List */;
  getEntityId(): number;
  getFireTicks(): number;
  getMaxFireTicks(): number;
  setFireTicks(arg0: number): void;
  remove(): void;
  isDead(): boolean;
  isValid(): boolean;
  isPersistent(): boolean;
  setPersistent(arg0: boolean): void;
  getPassenger(): org$bukkit$entity$Entity;
  setPassenger(arg0: org$bukkit$entity$Entity): boolean;
  getPassengers(): any /* java.util.List */;
  addPassenger(arg0: org$bukkit$entity$Entity): boolean;
  removePassenger(arg0: org$bukkit$entity$Entity): boolean;
  isEmpty(): boolean;
  eject(): boolean;
  getFallDistance(): number;
  setFallDistance(arg0: number): void;
  setLastDamageCause(arg0: org$bukkit$event$entity$EntityDamageEvent): void;
  getLastDamageCause(): org$bukkit$event$entity$EntityDamageEvent;
  getUniqueId(): any /* java.util.UUID */;
  getTicksLived(): number;
  setTicksLived(arg0: number): void;
  playEffect(arg0: org$bukkit$EntityEffect): void;
  getType(): org$bukkit$entity$EntityType;
  isInsideVehicle(): boolean;
  leaveVehicle(): boolean;
  getVehicle(): org$bukkit$entity$Entity;
  setCustomNameVisible(arg0: boolean): void;
  isCustomNameVisible(): boolean;
  setGlowing(arg0: boolean): void;
  isGlowing(): boolean;
  setInvulnerable(arg0: boolean): void;
  isInvulnerable(): boolean;
  isSilent(): boolean;
  setSilent(arg0: boolean): void;
  hasGravity(): boolean;
  setGravity(arg0: boolean): void;
  getPortalCooldown(): number;
  setPortalCooldown(arg0: number): void;
  getScoreboardTags(): any /* java.util.Set */;
  addScoreboardTag(arg0: string): boolean;
  removeScoreboardTag(arg0: string): boolean;
  getPistonMoveReaction(): org$bukkit$block$PistonMoveReaction;
  getFacing(): org$bukkit$block$BlockFace;
  getPose(): org$bukkit$entity$Pose;
  spigot(): org$bukkit$entity$Entity$Spigot;
  getOrigin(): org$bukkit$Location;
  fromMobSpawner(): boolean;
  getChunk(): org$bukkit$Chunk;
  getEntitySpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEyeHeight(): number;
  getEyeHeight(arg0: boolean): number;
  getEyeLocation(): org$bukkit$Location;
  getLineOfSight(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlock(
    arg0: any /* java.util.Set */,
    arg1: number
  ): org$bukkit$block$Block;
  getTargetBlock(arg0: number): org$bukkit$block$Block;
  getTargetBlock(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$Block;
  getTargetBlockFace(arg0: number): org$bukkit$block$BlockFace;
  getTargetBlockFace(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): org$bukkit$block$BlockFace;
  getTargetBlockInfo(
    arg0: number
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetBlockInfo(
    arg0: number,
    arg1: com$destroystokyo$paper$block$TargetBlockInfo$FluidMode
  ): com$destroystokyo$paper$block$TargetBlockInfo;
  getTargetEntity(arg0: number): org$bukkit$entity$Entity;
  getTargetEntity(arg0: number, arg1: boolean): org$bukkit$entity$Entity;
  getTargetEntityInfo(
    arg0: number
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getTargetEntityInfo(
    arg0: number,
    arg1: boolean
  ): com$destroystokyo$paper$entity$TargetEntityInfo;
  getLastTwoTargetBlocks(
    arg0: any /* java.util.Set */,
    arg1: number
  ): any /* java.util.List */;
  getTargetBlockExact(arg0: number): org$bukkit$block$Block;
  getTargetBlockExact(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$block$Block;
  rayTraceBlocks(arg0: number): org$bukkit$util$RayTraceResult;
  rayTraceBlocks(
    arg0: number,
    arg1: org$bukkit$FluidCollisionMode
  ): org$bukkit$util$RayTraceResult;
  getRemainingAir(): number;
  setRemainingAir(arg0: number): void;
  getMaximumAir(): number;
  setMaximumAir(arg0: number): void;
  getMaximumNoDamageTicks(): number;
  setMaximumNoDamageTicks(arg0: number): void;
  getLastDamage(): number;
  setLastDamage(arg0: number): void;
  getNoDamageTicks(): number;
  setNoDamageTicks(arg0: number): void;
  getKiller(): org$bukkit$entity$Player;
  setKiller(arg0: org$bukkit$entity$Player): void;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect): boolean;
  addPotionEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  addPotionEffects(arg0: java$util$Collection): boolean;
  hasPotionEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  getPotionEffect(
    arg0: org$bukkit$potion$PotionEffectType
  ): org$bukkit$potion$PotionEffect;
  removePotionEffect(arg0: org$bukkit$potion$PotionEffectType): void;
  getActivePotionEffects(): java$util$Collection;
  hasLineOfSight(arg0: org$bukkit$entity$Entity): boolean;
  getRemoveWhenFarAway(): boolean;
  setRemoveWhenFarAway(arg0: boolean): void;
  getEquipment(): org$bukkit$inventory$EntityEquipment;
  setCanPickupItems(arg0: boolean): void;
  getCanPickupItems(): boolean;
  isLeashed(): boolean;
  getLeashHolder(): org$bukkit$entity$Entity;
  setLeashHolder(arg0: org$bukkit$entity$Entity): boolean;
  isGliding(): boolean;
  setGliding(arg0: boolean): void;
  isSwimming(): boolean;
  setSwimming(arg0: boolean): void;
  isRiptiding(): boolean;
  isSleeping(): boolean;
  setAI(arg0: boolean): void;
  hasAI(): boolean;
  attack(arg0: org$bukkit$entity$Entity): void;
  swingMainHand(): void;
  swingOffHand(): void;
  setCollidable(arg0: boolean): void;
  isCollidable(): boolean;
  getMemory(arg0: org$bukkit$entity$memory$MemoryKey): any;
  setMemory(arg0: org$bukkit$entity$memory$MemoryKey, arg1: any): void;
  getArrowsStuck(): number;
  setArrowsStuck(arg0: number): void;
  getShieldBlockingDelay(): number;
  setShieldBlockingDelay(arg0: number): void;
  getActiveItem(): org$bukkit$inventory$ItemStack;
  getItemUseRemainingTime(): number;
  getHandRaisedTime(): number;
  isHandRaised(): boolean;
  isJumping(): boolean;
  setJumping(arg0: boolean): void;
  getPathfinder(): com$destroystokyo$paper$entity$Pathfinder;
  isInDaylight(): boolean;
  setTarget(arg0: org$bukkit$entity$LivingEntity): void;
  getTarget(): org$bukkit$entity$LivingEntity;
  setAware(arg0: boolean): void;
  isAware(): boolean;
  isBaby(): boolean;
  setBaby(arg0: boolean): void;
  isVillager(): boolean;
  setVillager(arg0: boolean): void;
  isDrowning(): boolean;
  startDrowning(arg0: number): void;
  stopDrowning(): void;
  setArmsRaised(arg0: boolean): void;
  isArmsRaised(): boolean;
  shouldBurnInDay(): boolean;
  setShouldBurnInDay(arg0: boolean): void;
  setLootTable(arg0: org$bukkit$loot$LootTable): void;
  getLootTable(): org$bukkit$loot$LootTable;
  setLootTable(arg0: org$bukkit$loot$LootTable, arg1: number): void;
  hasLootTable(): boolean;
  clearLootTable(): void;
  setSeed(arg0: number): void;
  getSeed(): number;
  setMetadata(arg0: string, arg1: org$bukkit$metadata$MetadataValue): void;
  getMetadata(arg0: string): any /* java.util.List */;
  hasMetadata(arg0: string): boolean;
  removeMetadata(arg0: string, arg1: org$bukkit$plugin$Plugin): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  getEffectivePermissions(): any /* java.util.Set */;
  isOp(): boolean;
  setOp(arg0: boolean): void;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
  launchProjectile(
    arg0: any /* java.lang.Class */
  ): org$bukkit$entity$Projectile;
  launchProjectile(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$util$Vector
  ): org$bukkit$entity$Projectile;
}


declare interface $org$bukkit$event$block$Action {}

declare class org$bukkit$event$block$Action
  implements $org$bukkit$event$block$Action {
  static LEFT_CLICK_BLOCK: org$bukkit$event$block$Action;
  static RIGHT_CLICK_BLOCK: org$bukkit$event$block$Action;
  static LEFT_CLICK_AIR: org$bukkit$event$block$Action;
  static RIGHT_CLICK_AIR: org$bukkit$event$block$Action;
  static PHYSICAL: org$bukkit$event$block$Action;
  static values(): JavaArray<org$bukkit$event$block$Action>;
  static valueOf(arg0: string): org$bukkit$event$block$Action;
}


declare interface $org$bukkit$event$block$BlockBreakEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  setDropItems(arg0: boolean): void;
  isDropItems(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$block$BlockBreakEvent
  implements $org$bukkit$event$block$BlockBreakEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$entity$Player);
  getPlayer(): org$bukkit$entity$Player;
  setDropItems(arg0: boolean): void;
  isDropItems(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$BlockBurnEvent
  extends $org$bukkit$event$Cancellable {
  getIgnitingBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockBurnEvent
  implements $org$bukkit$event$block$BlockBurnEvent {
  constructor(arg0: org$bukkit$block$Block);
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$Block);
  getIgnitingBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockCanBuildEvent {
  isBuildable(): boolean;
  setBuildable(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getBlockData(): org$bukkit$block$data$BlockData;
  getPlayer(): org$bukkit$entity$Player;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockCanBuildEvent
  implements $org$bukkit$event$block$BlockCanBuildEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$data$BlockData,
    arg2: boolean
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Player,
    arg2: org$bukkit$block$data$BlockData,
    arg3: boolean
  );
  isBuildable(): boolean;
  setBuildable(arg0: boolean): void;
  getMaterial(): org$bukkit$Material;
  getBlockData(): org$bukkit$block$data$BlockData;
  getPlayer(): org$bukkit$entity$Player;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockCookEvent
  extends $org$bukkit$event$Cancellable {
  getSource(): org$bukkit$inventory$ItemStack;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockCookEvent
  implements $org$bukkit$event$block$BlockCookEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$ItemStack
  );
  getSource(): org$bukkit$inventory$ItemStack;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockDamageEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  getInstaBreak(): boolean;
  setInstaBreak(arg0: boolean): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockDamageEvent
  implements $org$bukkit$event$block$BlockDamageEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: boolean
  );
  getPlayer(): org$bukkit$entity$Player;
  getInstaBreak(): boolean;
  setInstaBreak(arg0: boolean): void;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockDispenseArmorEvent {
  getTargetEntity(): org$bukkit$entity$LivingEntity;
}

declare class org$bukkit$event$block$BlockDispenseArmorEvent
  implements $org$bukkit$event$block$BlockDispenseArmorEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$entity$LivingEntity
  );
  getTargetEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$BlockDispenseEvent
  extends $org$bukkit$event$Cancellable {
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getVelocity(): org$bukkit$util$Vector;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockDispenseEvent
  implements $org$bukkit$event$block$BlockDispenseEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$util$Vector
  );
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getVelocity(): org$bukkit$util$Vector;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockDropItemEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  getBlockState(): org$bukkit$block$BlockState;
  getItems(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockDropItemEvent
  implements $org$bukkit$event$block$BlockDropItemEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$BlockState,
    arg2: org$bukkit$entity$Player,
    arg3: any /* java.util.List */
  );
  getPlayer(): org$bukkit$entity$Player;
  getBlockState(): org$bukkit$block$BlockState;
  getItems(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockEvent {
  getBlock(): org$bukkit$block$Block;
}

declare class org$bukkit$event$block$BlockEvent
  implements $org$bukkit$event$block$BlockEvent {
  constructor(arg0: org$bukkit$block$Block);
  getBlock(): org$bukkit$block$Block;
}


declare interface $org$bukkit$event$block$BlockExpEvent {
  getExpToDrop(): number;
  setExpToDrop(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockExpEvent
  implements $org$bukkit$event$block$BlockExpEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: number);
  getExpToDrop(): number;
  setExpToDrop(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockExplodeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  blockList(): any /* java.util.List */;
  getYield(): number;
  setYield(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockExplodeEvent
  implements $org$bukkit$event$block$BlockExplodeEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: any /* java.util.List */,
    arg2: number
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  blockList(): any /* java.util.List */;
  getYield(): number;
  setYield(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockFadeEvent
  extends $org$bukkit$event$Cancellable {
  getNewState(): org$bukkit$block$BlockState;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockFadeEvent
  implements $org$bukkit$event$block$BlockFadeEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockState);
  getNewState(): org$bukkit$block$BlockState;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockFertilizeEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockFertilizeEvent
  implements $org$bukkit$event$block$BlockFertilizeEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Player,
    arg2: any /* java.util.List */
  );
  getPlayer(): org$bukkit$entity$Player;
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockFormEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockFormEvent
  implements $org$bukkit$event$block$BlockFormEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockState);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$BlockFromToEvent
  extends $org$bukkit$event$Cancellable {
  getFace(): org$bukkit$block$BlockFace;
  getToBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockFromToEvent
  implements $org$bukkit$event$block$BlockFromToEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$Block);
  getFace(): org$bukkit$block$BlockFace;
  getToBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockGrowEvent
  extends $org$bukkit$event$Cancellable {
  getNewState(): org$bukkit$block$BlockState;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockGrowEvent
  implements $org$bukkit$event$block$BlockGrowEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockState);
  getNewState(): org$bukkit$block$BlockState;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockIgniteEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getCause(): org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  getPlayer(): org$bukkit$entity$Player;
  getIgnitingEntity(): org$bukkit$entity$Entity;
  getIgnitingBlock(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockIgniteEvent
  implements $org$bukkit$event$block$BlockIgniteEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$event$block$BlockIgniteEvent$IgniteCause,
    arg2: org$bukkit$entity$Entity
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$event$block$BlockIgniteEvent$IgniteCause,
    arg2: org$bukkit$block$Block
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$event$block$BlockIgniteEvent$IgniteCause,
    arg2: org$bukkit$entity$Entity,
    arg3: org$bukkit$block$Block
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getCause(): org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  getPlayer(): org$bukkit$entity$Player;
  getIgnitingEntity(): org$bukkit$entity$Entity;
  getIgnitingBlock(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockIgniteEvent$IgniteCause {}

declare class org$bukkit$event$block$BlockIgniteEvent$IgniteCause
  implements $org$bukkit$event$block$BlockIgniteEvent$IgniteCause {
  static LAVA: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static FLINT_AND_STEEL: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static SPREAD: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static LIGHTNING: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static FIREBALL: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static ENDER_CRYSTAL: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static EXPLOSION: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static ARROW: org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  static values(): JavaArray<
    org$bukkit$event$block$BlockIgniteEvent$IgniteCause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
}


declare interface $org$bukkit$event$block$BlockMultiPlaceEvent {
  getReplacedBlockStates(): any /* java.util.List */;
}

declare class org$bukkit$event$block$BlockMultiPlaceEvent
  implements $org$bukkit$event$block$BlockMultiPlaceEvent {
  constructor(
    arg0: any /* java.util.List */,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$entity$Player,
    arg4: boolean
  );
  constructor(
    arg0: any /* java.util.List */,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$entity$Player,
    arg4: boolean,
    arg5: org$bukkit$inventory$EquipmentSlot
  );
  getReplacedBlockStates(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$BlockPhysicsEvent
  extends $org$bukkit$event$Cancellable {
  getSourceBlock(): org$bukkit$block$Block;
  getChangedType(): org$bukkit$Material;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockPhysicsEvent
  implements $org$bukkit$event$block$BlockPhysicsEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$data$BlockData,
    arg2: number,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$data$BlockData
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$data$BlockData,
    arg2: org$bukkit$block$Block
  );
  getSourceBlock(): org$bukkit$block$Block;
  getChangedType(): org$bukkit$Material;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockPistonEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isSticky(): boolean;
  getDirection(): org$bukkit$block$BlockFace;
}

declare class org$bukkit$event$block$BlockPistonEvent
  implements $org$bukkit$event$block$BlockPistonEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockFace);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isSticky(): boolean;
  getDirection(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$event$block$BlockPistonExtendEvent {
  getLength(): number;
  getBlocks(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockPistonExtendEvent
  implements $org$bukkit$event$block$BlockPistonExtendEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: number,
    arg2: org$bukkit$block$BlockFace
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$block$BlockFace
  );
  getLength(): number;
  getBlocks(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$BlockPistonRetractEvent {
  getRetractLocation(): org$bukkit$Location;
  getBlocks(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockPistonRetractEvent
  implements $org$bukkit$event$block$BlockPistonRetractEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$block$BlockFace
  );
  getRetractLocation(): org$bukkit$Location;
  getBlocks(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$BlockPlaceEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getPlayer(): org$bukkit$entity$Player;
  getBlockPlaced(): org$bukkit$block$Block;
  getBlockReplacedState(): org$bukkit$block$BlockState;
  getBlockAgainst(): org$bukkit$block$Block;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  canBuild(): boolean;
  setBuild(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockPlaceEvent
  implements $org$bukkit$event$block$BlockPlaceEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$BlockState,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$inventory$ItemStack,
    arg4: org$bukkit$entity$Player,
    arg5: boolean
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$BlockState,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$inventory$ItemStack,
    arg4: org$bukkit$entity$Player,
    arg5: boolean,
    arg6: org$bukkit$inventory$EquipmentSlot
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getPlayer(): org$bukkit$entity$Player;
  getBlockPlaced(): org$bukkit$block$Block;
  getBlockReplacedState(): org$bukkit$block$BlockState;
  getBlockAgainst(): org$bukkit$block$Block;
  getItemInHand(): org$bukkit$inventory$ItemStack;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  canBuild(): boolean;
  setBuild(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockRedstoneEvent {
  getOldCurrent(): number;
  getNewCurrent(): number;
  setNewCurrent(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockRedstoneEvent
  implements $org$bukkit$event$block$BlockRedstoneEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: number, arg2: number);
  getOldCurrent(): number;
  getNewCurrent(): number;
  setNewCurrent(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockShearEntityEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Entity;
  getTool(): org$bukkit$inventory$ItemStack;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockShearEntityEvent
  implements $org$bukkit$event$block$BlockShearEntityEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$inventory$ItemStack
  );
  getEntity(): org$bukkit$entity$Entity;
  getTool(): org$bukkit$inventory$ItemStack;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$BlockSpreadEvent {
  getSource(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$BlockSpreadEvent
  implements $org$bukkit$event$block$BlockSpreadEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockState
  );
  getSource(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$CauldronLevelChangeEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Entity;
  getReason(): org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  getOldLevel(): number;
  getNewLevel(): number;
  setNewLevel(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$CauldronLevelChangeEvent
  implements $org$bukkit$event$block$CauldronLevelChangeEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason,
    arg3: number,
    arg4: number
  );
  getEntity(): org$bukkit$entity$Entity;
  getReason(): org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  getOldLevel(): number;
  getNewLevel(): number;
  setNewLevel(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason {}

declare class org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason
  implements $org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason {
  static BUCKET_FILL: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static BUCKET_EMPTY: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static BOTTLE_FILL: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static BOTTLE_EMPTY: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static BANNER_WASH: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static ARMOR_WASH: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static EXTINGUISH: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static EVAPORATE: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static UNKNOWN: org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  static values(): JavaArray<
    org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
}


declare interface $org$bukkit$event$block$EntityBlockFormEvent {
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$block$EntityBlockFormEvent
  implements $org$bukkit$event$block$EntityBlockFormEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockState
  );
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$block$FluidLevelChangeEvent
  extends $org$bukkit$event$Cancellable {
  getNewData(): org$bukkit$block$data$BlockData;
  setNewData(arg0: org$bukkit$block$data$BlockData): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$FluidLevelChangeEvent
  implements $org$bukkit$event$block$FluidLevelChangeEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$block$data$BlockData
  );
  getNewData(): org$bukkit$block$data$BlockData;
  setNewData(arg0: org$bukkit$block$data$BlockData): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$LeavesDecayEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$LeavesDecayEvent
  implements $org$bukkit$event$block$LeavesDecayEvent {
  constructor(arg0: org$bukkit$block$Block);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$MoistureChangeEvent
  extends $org$bukkit$event$Cancellable {
  getNewState(): org$bukkit$block$BlockState;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$MoistureChangeEvent
  implements $org$bukkit$event$block$MoistureChangeEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: org$bukkit$block$BlockState);
  getNewState(): org$bukkit$block$BlockState;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$NotePlayEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getInstrument(): org$bukkit$Instrument;
  getNote(): org$bukkit$Note;
  setInstrument(arg0: org$bukkit$Instrument): void;
  setNote(arg0: org$bukkit$Note): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$NotePlayEvent
  implements $org$bukkit$event$block$NotePlayEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$Instrument,
    arg2: org$bukkit$Note
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getInstrument(): org$bukkit$Instrument;
  getNote(): org$bukkit$Note;
  setInstrument(arg0: org$bukkit$Instrument): void;
  setNote(arg0: org$bukkit$Note): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$SignChangeEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  getLines(): JavaArray<string>;
  getLine(arg0: number): string;
  setLine(arg0: number, arg1: string): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$SignChangeEvent
  implements $org$bukkit$event$block$SignChangeEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Player,
    arg2: JavaArray<string>
  );
  getPlayer(): org$bukkit$entity$Player;
  getLines(): JavaArray<string>;
  getLine(arg0: number): string;
  setLine(arg0: number, arg1: string): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$block$SpongeAbsorbEvent
  extends $org$bukkit$event$Cancellable {
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$block$SpongeAbsorbEvent
  implements $org$bukkit$event$block$SpongeAbsorbEvent {
  constructor(arg0: org$bukkit$block$Block, arg1: any /* java.util.List */);
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$command$UnknownCommandEvent {
  getSender(): org$bukkit$command$CommandSender;
  getCommandLine(): string;
  getMessage(): string;
  setMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$command$UnknownCommandEvent
  implements $org$bukkit$event$command$UnknownCommandEvent {
  constructor(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: string
  );
  getSender(): org$bukkit$command$CommandSender;
  getCommandLine(): string;
  getMessage(): string;
  setMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$enchantment$EnchantItemEvent
  extends $org$bukkit$event$Cancellable {
  getEnchanter(): org$bukkit$entity$Player;
  getEnchantBlock(): org$bukkit$block$Block;
  getItem(): org$bukkit$inventory$ItemStack;
  getExpLevelCost(): number;
  setExpLevelCost(arg0: number): void;
  getEnchantsToAdd(): any /* java.util.Map */;
  whichButton(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$enchantment$EnchantItemEvent
  implements $org$bukkit$event$enchantment$EnchantItemEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$InventoryView,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$inventory$ItemStack,
    arg4: number,
    arg5: any /* java.util.Map */,
    arg6: number
  );
  getEnchanter(): org$bukkit$entity$Player;
  getEnchantBlock(): org$bukkit$block$Block;
  getItem(): org$bukkit$inventory$ItemStack;
  getExpLevelCost(): number;
  setExpLevelCost(arg0: number): void;
  getEnchantsToAdd(): any /* java.util.Map */;
  whichButton(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$enchantment$PrepareItemEnchantEvent
  extends $org$bukkit$event$Cancellable {
  getEnchanter(): org$bukkit$entity$Player;
  getEnchantBlock(): org$bukkit$block$Block;
  getItem(): org$bukkit$inventory$ItemStack;
  getExpLevelCostsOffered(): JavaArray<number>;
  getOffers(): JavaArray<org$bukkit$enchantments$EnchantmentOffer>;
  getEnchantmentBonus(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$enchantment$PrepareItemEnchantEvent
  implements $org$bukkit$event$enchantment$PrepareItemEnchantEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$InventoryView,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$inventory$ItemStack,
    arg4: JavaArray<org$bukkit$enchantments$EnchantmentOffer>,
    arg5: number
  );
  getEnchanter(): org$bukkit$entity$Player;
  getEnchantBlock(): org$bukkit$block$Block;
  getItem(): org$bukkit$inventory$ItemStack;
  getExpLevelCostsOffered(): JavaArray<number>;
  getOffers(): JavaArray<org$bukkit$enchantments$EnchantmentOffer>;
  getEnchantmentBonus(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$AreaEffectCloudApplyEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AreaEffectCloud;
  getAffectedEntities(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$AreaEffectCloudApplyEvent
  implements $org$bukkit$event$entity$AreaEffectCloudApplyEvent {
  constructor(
    arg0: org$bukkit$entity$AreaEffectCloud,
    arg1: any /* java.util.List */
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AreaEffectCloud;
  getAffectedEntities(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$BatToggleSleepEvent
  extends $org$bukkit$event$Cancellable {
  isAwake(): boolean;
  setCancelled(arg0: boolean): void;
  isCancelled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$BatToggleSleepEvent
  implements $org$bukkit$event$entity$BatToggleSleepEvent {
  constructor(arg0: org$bukkit$entity$Bat, arg1: boolean);
  isAwake(): boolean;
  setCancelled(arg0: boolean): void;
  isCancelled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$CreatureSpawnEvent {
  getEntity(): org$bukkit$entity$LivingEntity;
  getSpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$CreatureSpawnEvent
  implements $org$bukkit$event$entity$CreatureSpawnEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getSpawnReason(): org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$CreeperPowerEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Creeper;
  getLightning(): org$bukkit$entity$LightningStrike;
  getCause(): org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$CreeperPowerEvent
  implements $org$bukkit$event$entity$CreeperPowerEvent {
  constructor(
    arg0: org$bukkit$entity$Creeper,
    arg1: org$bukkit$entity$LightningStrike,
    arg2: org$bukkit$event$entity$CreeperPowerEvent$PowerCause
  );
  constructor(
    arg0: org$bukkit$entity$Creeper,
    arg1: org$bukkit$event$entity$CreeperPowerEvent$PowerCause
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Creeper;
  getLightning(): org$bukkit$entity$LightningStrike;
  getCause(): org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$CreeperPowerEvent$PowerCause {}

declare class org$bukkit$event$entity$CreeperPowerEvent$PowerCause
  implements $org$bukkit$event$entity$CreeperPowerEvent$PowerCause {
  static LIGHTNING: org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
  static SET_ON: org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
  static SET_OFF: org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
  static values(): JavaArray<
    org$bukkit$event$entity$CreeperPowerEvent$PowerCause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
}


declare interface $org$bukkit$event$entity$EnderDragonChangePhaseEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$EnderDragon;
  getCurrentPhase(): org$bukkit$entity$EnderDragon$Phase;
  getNewPhase(): org$bukkit$entity$EnderDragon$Phase;
  setNewPhase(arg0: org$bukkit$entity$EnderDragon$Phase): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EnderDragonChangePhaseEvent
  implements $org$bukkit$event$entity$EnderDragonChangePhaseEvent {
  constructor(
    arg0: org$bukkit$entity$EnderDragon,
    arg1: org$bukkit$entity$EnderDragon$Phase,
    arg2: org$bukkit$entity$EnderDragon$Phase
  );
  getEntity(): org$bukkit$entity$EnderDragon;
  getCurrentPhase(): org$bukkit$entity$EnderDragon$Phase;
  getNewPhase(): org$bukkit$entity$EnderDragon$Phase;
  setNewPhase(arg0: org$bukkit$entity$EnderDragon$Phase): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntityAirChangeEvent
  extends $org$bukkit$event$Cancellable {
  getAmount(): number;
  setAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityAirChangeEvent
  implements $org$bukkit$event$entity$EntityAirChangeEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: number);
  getAmount(): number;
  setAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityBreakDoorEvent {
  getEntity(): org$bukkit$entity$LivingEntity;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityBreakDoorEvent
  implements $org$bukkit$event$entity$EntityBreakDoorEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$block$Block
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityBreedEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  getMother(): org$bukkit$entity$LivingEntity;
  getFather(): org$bukkit$entity$LivingEntity;
  getBreeder(): org$bukkit$entity$LivingEntity;
  getBredWith(): org$bukkit$inventory$ItemStack;
  getExperience(): number;
  setExperience(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityBreedEvent
  implements $org$bukkit$event$entity$EntityBreedEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$entity$LivingEntity,
    arg2: org$bukkit$entity$LivingEntity,
    arg3: org$bukkit$entity$LivingEntity,
    arg4: org$bukkit$inventory$ItemStack,
    arg5: number
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getMother(): org$bukkit$entity$LivingEntity;
  getFather(): org$bukkit$entity$LivingEntity;
  getBreeder(): org$bukkit$entity$LivingEntity;
  getBredWith(): org$bukkit$inventory$ItemStack;
  getExperience(): number;
  setExperience(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntityChangeBlockEvent
  extends $org$bukkit$event$Cancellable {
  getBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getTo(): org$bukkit$Material;
  getBlockData(): org$bukkit$block$data$BlockData;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityChangeBlockEvent
  implements $org$bukkit$event$entity$EntityChangeBlockEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$data$BlockData
  );
  getBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getTo(): org$bukkit$Material;
  getBlockData(): org$bukkit$block$data$BlockData;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityCombustByBlockEvent {
  getCombuster(): org$bukkit$block$Block;
}

declare class org$bukkit$event$entity$EntityCombustByBlockEvent
  implements $org$bukkit$event$entity$EntityCombustByBlockEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Entity,
    arg2: number
  );
  getCombuster(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityCombustByEntityEvent {
  getCombuster(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityCombustByEntityEvent
  implements $org$bukkit$event$entity$EntityCombustByEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: number
  );
  getCombuster(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityCombustEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getDuration(): number;
  setDuration(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityCombustEvent
  implements $org$bukkit$event$entity$EntityCombustEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: number);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getDuration(): number;
  setDuration(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityCreatePortalEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getPortalType(): org$bukkit$PortalType;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityCreatePortalEvent
  implements $org$bukkit$event$entity$EntityCreatePortalEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$PortalType
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getPortalType(): org$bukkit$PortalType;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$PortalType {}

declare class org$bukkit$PortalType implements $org$bukkit$PortalType {
  static NETHER: org$bukkit$PortalType;
  static ENDER: org$bukkit$PortalType;
  static CUSTOM: org$bukkit$PortalType;
  static values(): JavaArray<org$bukkit$PortalType>;
  static valueOf(arg0: string): org$bukkit$PortalType;
}


declare interface $org$bukkit$event$entity$EntityDamageByBlockEvent {
  getDamager(): org$bukkit$block$Block;
}

declare class org$bukkit$event$entity$EntityDamageByBlockEvent
  implements $org$bukkit$event$entity$EntityDamageByBlockEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$entity$EntityDamageEvent$DamageCause,
    arg3: number
  );
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$entity$EntityDamageEvent$DamageCause,
    arg3: any /* java.util.Map */,
    arg4: any /* java.util.Map */
  );
  getDamager(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityDamageByEntityEvent {
  getDamager(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityDamageByEntityEvent
  implements $org$bukkit$event$entity$EntityDamageByEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$entity$EntityDamageEvent$DamageCause,
    arg3: number
  );
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$entity$EntityDamageEvent$DamageCause,
    arg3: any /* java.util.Map */,
    arg4: any /* java.util.Map */
  );
  getDamager(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityDeathEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  getDroppedExp(): number;
  setDroppedExp(arg0: number): void;
  getDrops(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getReviveHealth(): number;
  setReviveHealth(arg0: number): void;
  shouldPlayDeathSound(): boolean;
  setShouldPlayDeathSound(arg0: boolean): void;
  getDeathSound(): org$bukkit$Sound;
  setDeathSound(arg0: org$bukkit$Sound): void;
  getDeathSoundCategory(): org$bukkit$SoundCategory;
  setDeathSoundCategory(arg0: org$bukkit$SoundCategory): void;
  getDeathSoundVolume(): number;
  setDeathSoundVolume(arg0: number): void;
  getDeathSoundPitch(): number;
  setDeathSoundPitch(arg0: number): void;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityDeathEvent
  implements $org$bukkit$event$entity$EntityDeathEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: any /* java.util.List */
  );
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: any /* java.util.List */,
    arg2: number
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getDroppedExp(): number;
  setDroppedExp(arg0: number): void;
  getDrops(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getReviveHealth(): number;
  setReviveHealth(arg0: number): void;
  shouldPlayDeathSound(): boolean;
  setShouldPlayDeathSound(arg0: boolean): void;
  getDeathSound(): org$bukkit$Sound;
  setDeathSound(arg0: org$bukkit$Sound): void;
  getDeathSoundCategory(): org$bukkit$SoundCategory;
  setDeathSoundCategory(arg0: org$bukkit$SoundCategory): void;
  getDeathSoundVolume(): number;
  setDeathSoundVolume(arg0: number): void;
  getDeathSoundPitch(): number;
  setDeathSoundPitch(arg0: number): void;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntityDropItemEvent
  extends $org$bukkit$event$Cancellable {
  getItemDrop(): org$bukkit$entity$Item;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityDropItemEvent
  implements $org$bukkit$event$entity$EntityDropItemEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$entity$Item);
  getItemDrop(): org$bukkit$entity$Item;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityEnterBlockEvent
  extends $org$bukkit$event$Cancellable {
  getBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityEnterBlockEvent
  implements $org$bukkit$event$entity$EntityEnterBlockEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$block$Block);
  getBlock(): org$bukkit$block$Block;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityEvent {
  getEntity(): org$bukkit$entity$Entity;
  getEntityType(): org$bukkit$entity$EntityType;
}

declare class org$bukkit$event$entity$EntityEvent
  implements $org$bukkit$event$entity$EntityEvent {
  constructor(arg0: org$bukkit$entity$Entity);
  getEntity(): org$bukkit$entity$Entity;
  getEntityType(): org$bukkit$entity$EntityType;
}


declare interface $org$bukkit$event$entity$EntityExplodeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  blockList(): any /* java.util.List */;
  getLocation(): org$bukkit$Location;
  getYield(): number;
  setYield(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityExplodeEvent
  implements $org$bukkit$event$entity$EntityExplodeEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: any /* java.util.List */,
    arg3: number
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  blockList(): any /* java.util.List */;
  getLocation(): org$bukkit$Location;
  getYield(): number;
  setYield(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityInteractEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getBlock(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityInteractEvent
  implements $org$bukkit$event$entity$EntityInteractEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$block$Block);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getBlock(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityPickupItemEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  getItem(): org$bukkit$entity$Item;
  getRemaining(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityPickupItemEvent
  implements $org$bukkit$event$entity$EntityPickupItemEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$entity$Item,
    arg2: number
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getItem(): org$bukkit$entity$Item;
  getRemaining(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntityPlaceEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  getBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityPlaceEvent
  implements $org$bukkit$event$entity$EntityPlaceEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Player,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace
  );
  getPlayer(): org$bukkit$entity$Player;
  getBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityPortalEnterEvent {
  getLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityPortalEnterEvent
  implements $org$bukkit$event$entity$EntityPortalEnterEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$Location);
  getLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityPortalEvent {
  setSearchRadius(arg0: number): void;
  getSearchRadius(): number;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityPortalEvent
  implements $org$bukkit$event$entity$EntityPortalEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: number
  );
  setSearchRadius(arg0: number): void;
  getSearchRadius(): number;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityPortalExitEvent {
  getBefore(): org$bukkit$util$Vector;
  getAfter(): org$bukkit$util$Vector;
  setAfter(arg0: org$bukkit$util$Vector): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityPortalExitEvent
  implements $org$bukkit$event$entity$EntityPortalExitEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: org$bukkit$util$Vector,
    arg4: org$bukkit$util$Vector
  );
  getBefore(): org$bukkit$util$Vector;
  getAfter(): org$bukkit$util$Vector;
  setAfter(arg0: org$bukkit$util$Vector): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityPoseChangeEvent {
  getPose(): org$bukkit$entity$Pose;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityPoseChangeEvent
  implements $org$bukkit$event$entity$EntityPoseChangeEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$entity$Pose);
  getPose(): org$bukkit$entity$Pose;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityPotionEffectEvent
  extends $org$bukkit$event$Cancellable {
  getOldEffect(): org$bukkit$potion$PotionEffect;
  getNewEffect(): org$bukkit$potion$PotionEffect;
  getCause(): org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  getAction(): org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  getModifiedType(): org$bukkit$potion$PotionEffectType;
  isOverride(): boolean;
  setOverride(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityPotionEffectEvent
  implements $org$bukkit$event$entity$EntityPotionEffectEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$potion$PotionEffect,
    arg2: org$bukkit$potion$PotionEffect,
    arg3: org$bukkit$event$entity$EntityPotionEffectEvent$Cause,
    arg4: org$bukkit$event$entity$EntityPotionEffectEvent$Action,
    arg5: boolean
  );
  getOldEffect(): org$bukkit$potion$PotionEffect;
  getNewEffect(): org$bukkit$potion$PotionEffect;
  getCause(): org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  getAction(): org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  getModifiedType(): org$bukkit$potion$PotionEffectType;
  isOverride(): boolean;
  setOverride(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityPotionEffectEvent$Cause {}

declare class org$bukkit$event$entity$EntityPotionEffectEvent$Cause
  implements $org$bukkit$event$entity$EntityPotionEffectEvent$Cause {
  static AREA_EFFECT_CLOUD: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static ARROW: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static ATTACK: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static BEACON: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static COMMAND: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static CONDUIT: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static CONVERSION: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static DEATH: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static DOLPHIN: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static EXPIRATION: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static FOOD: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static ILLUSION: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static MILK: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static PATROL_CAPTAIN: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static PLUGIN: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static POTION_DRINK: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static POTION_SPLASH: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static SPIDER_SPAWN: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static TOTEM: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static TURTLE_HELMET: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static UNKNOWN: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static VILLAGER_TRADE: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static WITHER_ROSE: org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityPotionEffectEvent$Cause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
}


declare interface $org$bukkit$event$entity$EntityPotionEffectEvent$Action {}

declare class org$bukkit$event$entity$EntityPotionEffectEvent$Action
  implements $org$bukkit$event$entity$EntityPotionEffectEvent$Action {
  static ADDED: org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  static CHANGED: org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  static CLEARED: org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  static REMOVED: org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityPotionEffectEvent$Action
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityPotionEffectEvent$Action;
}


declare interface $org$bukkit$event$entity$EntityRegainHealthEvent
  extends $org$bukkit$event$Cancellable {
  isFastRegen(): boolean;
  getAmount(): number;
  setAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getRegainReason(): org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityRegainHealthEvent
  implements $org$bukkit$event$entity$EntityRegainHealthEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason
  );
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: number,
    arg2: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason,
    arg3: boolean
  );
  isFastRegen(): boolean;
  getAmount(): number;
  setAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getRegainReason(): org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason {}

declare class org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason
  implements $org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason {
  static REGEN: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static SATIATED: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static EATING: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static ENDER_CRYSTAL: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static MAGIC: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static MAGIC_REGEN: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static WITHER_SPAWN: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static WITHER: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static CUSTOM: org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
}


declare interface $org$bukkit$event$entity$EntityResurrectEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityResurrectEvent
  implements $org$bukkit$event$entity$EntityResurrectEvent {
  constructor(arg0: org$bukkit$entity$LivingEntity);
  getEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntityShootBowEvent
  extends $org$bukkit$event$Cancellable {
  setConsumeArrow(arg0: boolean): void;
  getConsumeArrow(): boolean;
  getArrowItem(): org$bukkit$inventory$ItemStack;

  getEntity(): org$bukkit$entity$LivingEntity;
  getBow(): org$bukkit$inventory$ItemStack;
  getProjectile(): org$bukkit$entity$Entity;
  setProjectile(arg0: org$bukkit$entity$Entity): void;
  getForce(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityShootBowEvent
  implements $org$bukkit$event$entity$EntityShootBowEvent {
  setConsumeArrow(arg0: boolean): void;
  getConsumeArrow(): boolean;
  getArrowItem(): org$bukkit$inventory$ItemStack;
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$entity$Entity,
    arg3: number
  );
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$entity$Entity,
    arg4: number
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  getBow(): org$bukkit$inventory$ItemStack;
  getProjectile(): org$bukkit$entity$Entity;
  setProjectile(arg0: org$bukkit$entity$Entity): void;
  getForce(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntitySpawnEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntitySpawnEvent
  implements $org$bukkit$event$entity$EntitySpawnEvent {
  constructor(arg0: org$bukkit$entity$Entity);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityTameEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getOwner(): org$bukkit$entity$AnimalTamer;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityTameEvent
  implements $org$bukkit$event$entity$EntityTameEvent {
  constructor(
    arg0: org$bukkit$entity$LivingEntity,
    arg1: org$bukkit$entity$AnimalTamer
  );
  getEntity(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getOwner(): org$bukkit$entity$AnimalTamer;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$EntityTargetEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getReason(): org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  getTarget(): org$bukkit$entity$Entity;
  setTarget(arg0: org$bukkit$entity$Entity): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityTargetEvent
  implements $org$bukkit$event$entity$EntityTargetEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$entity$EntityTargetEvent$TargetReason
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getReason(): org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  getTarget(): org$bukkit$entity$Entity;
  setTarget(arg0: org$bukkit$entity$Entity): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityTargetEvent$TargetReason {}

declare class org$bukkit$event$entity$EntityTargetEvent$TargetReason
  implements $org$bukkit$event$entity$EntityTargetEvent$TargetReason {
  static TARGET_DIED: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static CLOSEST_PLAYER: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static TARGET_ATTACKED_ENTITY: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static PIG_ZOMBIE_TARGET: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static FORGOT_TARGET: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static TARGET_ATTACKED_OWNER: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static OWNER_ATTACKED_TARGET: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static RANDOM_TARGET: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static DEFEND_VILLAGE: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static TARGET_ATTACKED_NEARBY_ENTITY: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static REINFORCEMENT_TARGET: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static COLLISION: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static CUSTOM: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static CLOSEST_ENTITY: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static FOLLOW_LEADER: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static TEMPT: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static UNKNOWN: org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityTargetEvent$TargetReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityTargetEvent$TargetReason;
}


declare interface $org$bukkit$event$entity$EntityTargetLivingEntityEvent {
  getTarget(): org$bukkit$entity$LivingEntity;
  setTarget(arg0: org$bukkit$entity$Entity): void;
  getTarget(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$EntityTargetLivingEntityEvent
  implements $org$bukkit$event$entity$EntityTargetLivingEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$LivingEntity,
    arg2: org$bukkit$event$entity$EntityTargetEvent$TargetReason
  );
  getTarget(): org$bukkit$entity$LivingEntity;
  setTarget(arg0: org$bukkit$entity$Entity): void;
  getTarget(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$EntityTeleportEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getFrom(): org$bukkit$Location;
  setFrom(arg0: org$bukkit$Location): void;
  getTo(): org$bukkit$Location;
  setTo(arg0: org$bukkit$Location): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityTeleportEvent
  implements $org$bukkit$event$entity$EntityTeleportEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getFrom(): org$bukkit$Location;
  setFrom(arg0: org$bukkit$Location): void;
  getTo(): org$bukkit$Location;
  setTo(arg0: org$bukkit$Location): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityToggleGlideEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isGliding(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityToggleGlideEvent
  implements $org$bukkit$event$entity$EntityToggleGlideEvent {
  constructor(arg0: org$bukkit$entity$LivingEntity, arg1: boolean);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isGliding(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityToggleSwimEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isSwimming(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityToggleSwimEvent
  implements $org$bukkit$event$entity$EntityToggleSwimEvent {
  constructor(arg0: org$bukkit$entity$LivingEntity, arg1: boolean);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isSwimming(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityTransformEvent
  extends $org$bukkit$event$Cancellable {
  getTransformedEntity(): org$bukkit$entity$Entity;
  getTransformedEntities(): any /* java.util.List */;
  getTransformReason(): org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityTransformEvent
  implements $org$bukkit$event$entity$EntityTransformEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: any /* java.util.List */,
    arg2: org$bukkit$event$entity$EntityTransformEvent$TransformReason
  );
  getTransformedEntity(): org$bukkit$entity$Entity;
  getTransformedEntities(): any /* java.util.List */;
  getTransformReason(): org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityTransformEvent$TransformReason {}

declare class org$bukkit$event$entity$EntityTransformEvent$TransformReason
  implements $org$bukkit$event$entity$EntityTransformEvent$TransformReason {
  static CURED: org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  static INFECTION: org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  static DROWNED: org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  static SHEARED: org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  static LIGHTNING: org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  static SPLIT: org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityTransformEvent$TransformReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityTransformEvent$TransformReason;
}


declare interface $org$bukkit$event$entity$EntityUnleashEvent {
  getReason(): org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$EntityUnleashEvent
  implements $org$bukkit$event$entity$EntityUnleashEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$event$entity$EntityUnleashEvent$UnleashReason
  );
  getReason(): org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$EntityUnleashEvent$UnleashReason {}

declare class org$bukkit$event$entity$EntityUnleashEvent$UnleashReason
  implements $org$bukkit$event$entity$EntityUnleashEvent$UnleashReason {
  static HOLDER_GONE: org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  static PLAYER_UNLEASH: org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  static DISTANCE: org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  static UNKNOWN: org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  static values(): JavaArray<
    org$bukkit$event$entity$EntityUnleashEvent$UnleashReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
}


declare interface $org$bukkit$event$entity$ExpBottleEvent {
  getEntity(): org$bukkit$entity$ThrownExpBottle;
  getShowEffect(): boolean;
  setShowEffect(arg0: boolean): void;
  getExperience(): number;
  setExperience(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$ExpBottleEvent
  implements $org$bukkit$event$entity$ExpBottleEvent {
  constructor(arg0: org$bukkit$entity$ThrownExpBottle, arg1: number);
  getEntity(): org$bukkit$entity$ThrownExpBottle;
  getShowEffect(): boolean;
  setShowEffect(arg0: boolean): void;
  getExperience(): number;
  setExperience(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$ExplosionPrimeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getRadius(): number;
  setRadius(arg0: number): void;
  getFire(): boolean;
  setFire(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$entity$ExplosionPrimeEvent
  implements $org$bukkit$event$entity$ExplosionPrimeEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: number, arg2: boolean);
  constructor(arg0: org$bukkit$entity$Explosive);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getRadius(): number;
  setRadius(arg0: number): void;
  getFire(): boolean;
  setFire(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$entity$FireworkExplodeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Firework;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$FireworkExplodeEvent
  implements $org$bukkit$event$entity$FireworkExplodeEvent {
  constructor(arg0: org$bukkit$entity$Firework);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Firework;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$FoodLevelChangeEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$HumanEntity;
  getItem(): org$bukkit$inventory$ItemStack;
  getFoodLevel(): number;
  setFoodLevel(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$FoodLevelChangeEvent
  implements $org$bukkit$event$entity$FoodLevelChangeEvent {
  constructor(arg0: org$bukkit$entity$HumanEntity, arg1: number);
  constructor(
    arg0: org$bukkit$entity$HumanEntity,
    arg1: number,
    arg2: org$bukkit$inventory$ItemStack
  );
  getEntity(): org$bukkit$entity$HumanEntity;
  getItem(): org$bukkit$inventory$ItemStack;
  getFoodLevel(): number;
  setFoodLevel(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$HorseJumpEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AbstractHorse;
  getPower(): number;
  setPower(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$HorseJumpEvent
  implements $org$bukkit$event$entity$HorseJumpEvent {
  constructor(arg0: org$bukkit$entity$AbstractHorse, arg1: number);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AbstractHorse;
  getPower(): number;
  setPower(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$ItemDespawnEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Item;
  getLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$ItemDespawnEvent
  implements $org$bukkit$event$entity$ItemDespawnEvent {
  constructor(arg0: org$bukkit$entity$Item, arg1: org$bukkit$Location);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Item;
  getLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$ItemMergeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Item;
  getTarget(): org$bukkit$entity$Item;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$ItemMergeEvent
  implements $org$bukkit$event$entity$ItemMergeEvent {
  constructor(arg0: org$bukkit$entity$Item, arg1: org$bukkit$entity$Item);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Item;
  getTarget(): org$bukkit$entity$Item;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$ItemSpawnEvent {
  getEntity(): org$bukkit$entity$Item;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$ItemSpawnEvent
  implements $org$bukkit$event$entity$ItemSpawnEvent {
  constructor(arg0: org$bukkit$entity$Item, arg1: org$bukkit$Location);
  constructor(arg0: org$bukkit$entity$Item);
  getEntity(): org$bukkit$entity$Item;
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$LingeringPotionSplashEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$ThrownPotion;
  getAreaEffectCloud(): org$bukkit$entity$AreaEffectCloud;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$LingeringPotionSplashEvent
  implements $org$bukkit$event$entity$LingeringPotionSplashEvent {
  constructor(
    arg0: org$bukkit$entity$ThrownPotion,
    arg1: org$bukkit$entity$AreaEffectCloud
  );
  getEntity(): org$bukkit$entity$ThrownPotion;
  getAreaEffectCloud(): org$bukkit$entity$AreaEffectCloud;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$PigZapEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Pig;
  getLightning(): org$bukkit$entity$LightningStrike;
  getPigZombie(): org$bukkit$entity$PigZombie;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$PigZapEvent
  implements $org$bukkit$event$entity$PigZapEvent {
  constructor(
    arg0: org$bukkit$entity$Pig,
    arg1: org$bukkit$entity$LightningStrike,
    arg2: org$bukkit$entity$PigZombie
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Pig;
  getLightning(): org$bukkit$entity$LightningStrike;
  getPigZombie(): org$bukkit$entity$PigZombie;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$PigZombieAngerEvent
  extends $org$bukkit$event$Cancellable {
  getTarget(): org$bukkit$entity$Entity;
  getNewAnger(): number;
  setNewAnger(arg0: number): void;
  getEntity(): org$bukkit$entity$PigZombie;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$PigZombieAngerEvent
  implements $org$bukkit$event$entity$PigZombieAngerEvent {
  constructor(
    arg0: org$bukkit$entity$PigZombie,
    arg1: org$bukkit$entity$Entity,
    arg2: number
  );
  getTarget(): org$bukkit$entity$Entity;
  getNewAnger(): number;
  setNewAnger(arg0: number): void;
  getEntity(): org$bukkit$entity$PigZombie;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$PlayerDeathEvent {
  getItemsToKeep(): any /* java.util.List */;
  shouldDropExperience(): boolean;
  setShouldDropExperience(arg0: boolean): void;

  getEntity(): org$bukkit$entity$Player;
  setDeathMessage(arg0: string): void;
  getDeathMessage(): string;
  getNewExp(): number;
  setNewExp(arg0: number): void;
  getNewLevel(): number;
  setNewLevel(arg0: number): void;
  getNewTotalExp(): number;
  setNewTotalExp(arg0: number): void;
  getKeepLevel(): boolean;
  setKeepLevel(arg0: boolean): void;
  setKeepInventory(arg0: boolean): void;
  getKeepInventory(): boolean;
  getEntity(): org$bukkit$entity$LivingEntity;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$PlayerDeathEvent
  implements $org$bukkit$event$entity$PlayerDeathEvent {
  getItemsToKeep(): any /* java.util.List */;
  shouldDropExperience(): boolean;
  setShouldDropExperience(arg0: boolean): void;
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: any /* java.util.List */,
    arg2: number,
    arg3: string
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: any /* java.util.List */,
    arg2: number,
    arg3: number,
    arg4: string
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: any /* java.util.List */,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: string
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: any /* java.util.List */,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: string,
    arg7: boolean
  );
  getEntity(): org$bukkit$entity$Player;
  setDeathMessage(arg0: string): void;
  getDeathMessage(): string;
  getNewExp(): number;
  setNewExp(arg0: number): void;
  getNewLevel(): number;
  setNewLevel(arg0: number): void;
  getNewTotalExp(): number;
  setNewTotalExp(arg0: number): void;
  getKeepLevel(): boolean;
  setKeepLevel(arg0: boolean): void;
  setKeepInventory(arg0: boolean): void;
  getKeepInventory(): boolean;
  getEntity(): org$bukkit$entity$LivingEntity;
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$PlayerLeashEntityEvent
  extends $org$bukkit$event$Cancellable {
  getLeashHolder(): org$bukkit$entity$Entity;
  getEntity(): org$bukkit$entity$Entity;
  getPlayer(): org$bukkit$entity$Player;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$entity$PlayerLeashEntityEvent
  implements $org$bukkit$event$entity$PlayerLeashEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$entity$Player
  );
  getLeashHolder(): org$bukkit$entity$Entity;
  getEntity(): org$bukkit$entity$Entity;
  getPlayer(): org$bukkit$entity$Player;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$PotionSplashEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$ThrownPotion;
  getPotion(): org$bukkit$entity$ThrownPotion;
  getAffectedEntities(): java$util$Collection;
  getIntensity(arg0: org$bukkit$entity$LivingEntity): number;
  setIntensity(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$PotionSplashEvent
  implements $org$bukkit$event$entity$PotionSplashEvent {
  constructor(
    arg0: org$bukkit$entity$ThrownPotion,
    arg1: any /* java.util.Map */
  );
  getEntity(): org$bukkit$entity$ThrownPotion;
  getPotion(): org$bukkit$entity$ThrownPotion;
  getAffectedEntities(): java$util$Collection;
  getIntensity(arg0: org$bukkit$entity$LivingEntity): number;
  setIntensity(arg0: org$bukkit$entity$LivingEntity, arg1: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$ProjectileHitEvent {
  getEntity(): org$bukkit$entity$Projectile;
  getHitBlock(): org$bukkit$block$Block;
  getHitBlockFace(): org$bukkit$block$BlockFace;
  getHitEntity(): org$bukkit$entity$Entity;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$ProjectileHitEvent
  implements $org$bukkit$event$entity$ProjectileHitEvent {
  constructor(arg0: org$bukkit$entity$Projectile);
  constructor(
    arg0: org$bukkit$entity$Projectile,
    arg1: org$bukkit$entity$Entity
  );
  constructor(arg0: org$bukkit$entity$Projectile, arg1: org$bukkit$block$Block);
  constructor(
    arg0: org$bukkit$entity$Projectile,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$block$Block
  );
  constructor(
    arg0: org$bukkit$entity$Projectile,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace
  );
  getEntity(): org$bukkit$entity$Projectile;
  getHitBlock(): org$bukkit$block$Block;
  getHitBlockFace(): org$bukkit$block$BlockFace;
  getHitEntity(): org$bukkit$entity$Entity;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$ProjectileLaunchEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$ProjectileLaunchEvent
  implements $org$bukkit$event$entity$ProjectileLaunchEvent {
  constructor(arg0: org$bukkit$entity$Entity);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Projectile;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$SheepDyeWoolEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Sheep;
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$SheepDyeWoolEvent
  implements $org$bukkit$event$entity$SheepDyeWoolEvent {
  constructor(arg0: org$bukkit$entity$Sheep, arg1: org$bukkit$DyeColor);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Sheep;
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$SheepRegrowWoolEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Sheep;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$SheepRegrowWoolEvent
  implements $org$bukkit$event$entity$SheepRegrowWoolEvent {
  constructor(arg0: org$bukkit$entity$Sheep);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Sheep;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$SlimeSplitEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Slime;
  getCount(): number;
  setCount(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$SlimeSplitEvent
  implements $org$bukkit$event$entity$SlimeSplitEvent {
  constructor(arg0: org$bukkit$entity$Slime, arg1: number);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Slime;
  getCount(): number;
  setCount(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$SpawnerSpawnEvent {
  getSpawner(): org$bukkit$block$CreatureSpawner;
}

declare class org$bukkit$event$entity$SpawnerSpawnEvent
  implements $org$bukkit$event$entity$SpawnerSpawnEvent {
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$block$CreatureSpawner
  );
  getSpawner(): org$bukkit$block$CreatureSpawner;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$entity$VillagerAcquireTradeEvent
  extends $org$bukkit$event$Cancellable {
  getRecipe(): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: org$bukkit$inventory$MerchantRecipe): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AbstractVillager;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$VillagerAcquireTradeEvent
  implements $org$bukkit$event$entity$VillagerAcquireTradeEvent {
  constructor(
    arg0: org$bukkit$entity$AbstractVillager,
    arg1: org$bukkit$inventory$MerchantRecipe
  );
  getRecipe(): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: org$bukkit$inventory$MerchantRecipe): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AbstractVillager;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$VillagerCareerChangeEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Villager;
  getProfession(): org$bukkit$entity$Villager$Profession;
  setProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getReason(): org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$VillagerCareerChangeEvent
  implements $org$bukkit$event$entity$VillagerCareerChangeEvent {
  constructor(
    arg0: org$bukkit$entity$Villager,
    arg1: org$bukkit$entity$Villager$Profession,
    arg2: org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason
  );
  getEntity(): org$bukkit$entity$Villager;
  getProfession(): org$bukkit$entity$Villager$Profession;
  setProfession(arg0: org$bukkit$entity$Villager$Profession): void;
  getReason(): org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason {}

declare class org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason
  implements $org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason {
  static LOSING_JOB: org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason;
  static EMPLOYED: org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason;
  static values(): JavaArray<
    org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason;
}


declare interface $org$bukkit$event$entity$VillagerReplenishTradeEvent
  extends $org$bukkit$event$Cancellable {
  getRecipe(): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: org$bukkit$inventory$MerchantRecipe): void;
  getBonus(): number;
  setBonus(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AbstractVillager;
  getHandlers(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$entity$VillagerReplenishTradeEvent
  implements $org$bukkit$event$entity$VillagerReplenishTradeEvent {
  constructor(
    arg0: org$bukkit$entity$AbstractVillager,
    arg1: org$bukkit$inventory$MerchantRecipe,
    arg2: number
  );
  getRecipe(): org$bukkit$inventory$MerchantRecipe;
  setRecipe(arg0: org$bukkit$inventory$MerchantRecipe): void;
  getBonus(): number;
  setBonus(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$AbstractVillager;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getEntity(): org$bukkit$entity$Entity;
}


declare interface $org$bukkit$event$Event$Result {}

declare class org$bukkit$event$Event$Result
  implements $org$bukkit$event$Event$Result {
  static DENY: org$bukkit$event$Event$Result;
  static DEFAULT: org$bukkit$event$Event$Result;
  static ALLOW: org$bukkit$event$Event$Result;
  static values(): JavaArray<org$bukkit$event$Event$Result>;
  static valueOf(arg0: string): org$bukkit$event$Event$Result;
}


declare interface $org$bukkit$event$EventException {
  getCause(): any /* java.lang.Throwable */;
}

declare class org$bukkit$event$EventException
  implements $org$bukkit$event$EventException {
  constructor(arg0: any /* java.lang.Throwable */);
  constructor();
  constructor(arg0: any /* java.lang.Throwable */, arg1: string);
  constructor(arg0: string);
  getCause(): any /* java.lang.Throwable */;
}


declare interface $org$bukkit$event$EventHandler {
  priority(): org$bukkit$event$EventPriority;
  ignoreCancelled(): boolean;
}

declare class org$bukkit$event$EventHandler
  implements $org$bukkit$event$EventHandler {
  priority(): org$bukkit$event$EventPriority;
  ignoreCancelled(): boolean;
}


declare interface $org$bukkit$event$hanging$HangingBreakByEntityEvent {
  getRemover(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$hanging$HangingBreakByEntityEvent
  implements $org$bukkit$event$hanging$HangingBreakByEntityEvent {
  constructor(arg0: org$bukkit$entity$Hanging, arg1: org$bukkit$entity$Entity);
  constructor(
    arg0: org$bukkit$entity$Hanging,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause
  );
  getRemover(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$hanging$HangingBreakEvent$RemoveCause {}

declare class org$bukkit$event$hanging$HangingBreakEvent$RemoveCause
  implements $org$bukkit$event$hanging$HangingBreakEvent$RemoveCause {
  static ENTITY: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  static EXPLOSION: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  static OBSTRUCTION: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  static PHYSICS: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  static DEFAULT: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  static values(): JavaArray<
    org$bukkit$event$hanging$HangingBreakEvent$RemoveCause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
}


declare interface $org$bukkit$event$hanging$HangingBreakEvent
  extends $org$bukkit$event$Cancellable {
  getCause(): org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$hanging$HangingBreakEvent
  implements $org$bukkit$event$hanging$HangingBreakEvent {
  constructor(
    arg0: org$bukkit$entity$Hanging,
    arg1: org$bukkit$event$hanging$HangingBreakEvent$RemoveCause
  );
  getCause(): org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$hanging$HangingEvent {
  getEntity(): org$bukkit$entity$Hanging;
}

declare class org$bukkit$event$hanging$HangingEvent
  implements $org$bukkit$event$hanging$HangingEvent {
  constructor(arg0: org$bukkit$entity$Hanging);
  getEntity(): org$bukkit$entity$Hanging;
}


declare interface $org$bukkit$event$hanging$HangingPlaceEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  getBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$hanging$HangingPlaceEvent
  implements $org$bukkit$event$hanging$HangingPlaceEvent {
  constructor(
    arg0: org$bukkit$entity$Hanging,
    arg1: org$bukkit$entity$Player,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace
  );
  getPlayer(): org$bukkit$entity$Player;
  getBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$BrewEvent
  extends $org$bukkit$event$Cancellable {
  getContents(): org$bukkit$inventory$BrewerInventory;
  getFuelLevel(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$BrewEvent
  implements $org$bukkit$event$inventory$BrewEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$BrewerInventory,
    arg2: number
  );
  getContents(): org$bukkit$inventory$BrewerInventory;
  getFuelLevel(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$BrewingStandFuelEvent
  extends $org$bukkit$event$Cancellable {
  getFuel(): org$bukkit$inventory$ItemStack;
  getFuelPower(): number;
  setFuelPower(arg0: number): void;
  isConsuming(): boolean;
  setConsuming(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$BrewingStandFuelEvent
  implements $org$bukkit$event$inventory$BrewingStandFuelEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: number
  );
  getFuel(): org$bukkit$inventory$ItemStack;
  getFuelPower(): number;
  setFuelPower(arg0: number): void;
  isConsuming(): boolean;
  setConsuming(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$ClickType {
  isKeyboardClick(): boolean;
  isCreativeAction(): boolean;
  isRightClick(): boolean;
  isLeftClick(): boolean;
  isShiftClick(): boolean;
}

declare class org$bukkit$event$inventory$ClickType
  implements $org$bukkit$event$inventory$ClickType {
  static LEFT: org$bukkit$event$inventory$ClickType;
  static SHIFT_LEFT: org$bukkit$event$inventory$ClickType;
  static RIGHT: org$bukkit$event$inventory$ClickType;
  static SHIFT_RIGHT: org$bukkit$event$inventory$ClickType;
  static WINDOW_BORDER_LEFT: org$bukkit$event$inventory$ClickType;
  static WINDOW_BORDER_RIGHT: org$bukkit$event$inventory$ClickType;
  static MIDDLE: org$bukkit$event$inventory$ClickType;
  static NUMBER_KEY: org$bukkit$event$inventory$ClickType;
  static DOUBLE_CLICK: org$bukkit$event$inventory$ClickType;
  static DROP: org$bukkit$event$inventory$ClickType;
  static CONTROL_DROP: org$bukkit$event$inventory$ClickType;
  static CREATIVE: org$bukkit$event$inventory$ClickType;
  static UNKNOWN: org$bukkit$event$inventory$ClickType;
  static values(): JavaArray<org$bukkit$event$inventory$ClickType>;
  static valueOf(arg0: string): org$bukkit$event$inventory$ClickType;
  isKeyboardClick(): boolean;
  isCreativeAction(): boolean;
  isRightClick(): boolean;
  isLeftClick(): boolean;
  isShiftClick(): boolean;
}


declare interface $org$bukkit$event$inventory$CraftItemEvent {
  getRecipe(): org$bukkit$inventory$Recipe;
  getInventory(): org$bukkit$inventory$CraftingInventory;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$event$inventory$CraftItemEvent
  implements $org$bukkit$event$inventory$CraftItemEvent {
  constructor(
    arg0: org$bukkit$inventory$Recipe,
    arg1: org$bukkit$inventory$InventoryView,
    arg2: org$bukkit$event$inventory$InventoryType$SlotType,
    arg3: number,
    arg4: org$bukkit$event$inventory$ClickType,
    arg5: org$bukkit$event$inventory$InventoryAction
  );
  constructor(
    arg0: org$bukkit$inventory$Recipe,
    arg1: org$bukkit$inventory$InventoryView,
    arg2: org$bukkit$event$inventory$InventoryType$SlotType,
    arg3: number,
    arg4: org$bukkit$event$inventory$ClickType,
    arg5: org$bukkit$event$inventory$InventoryAction,
    arg6: number
  );
  getRecipe(): org$bukkit$inventory$Recipe;
  getInventory(): org$bukkit$inventory$CraftingInventory;
  getInventory(): org$bukkit$inventory$Inventory;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$inventory$InventoryAction {}

declare class org$bukkit$event$inventory$InventoryAction
  implements $org$bukkit$event$inventory$InventoryAction {
  static NOTHING: org$bukkit$event$inventory$InventoryAction;
  static PICKUP_ALL: org$bukkit$event$inventory$InventoryAction;
  static PICKUP_SOME: org$bukkit$event$inventory$InventoryAction;
  static PICKUP_HALF: org$bukkit$event$inventory$InventoryAction;
  static PICKUP_ONE: org$bukkit$event$inventory$InventoryAction;
  static PLACE_ALL: org$bukkit$event$inventory$InventoryAction;
  static PLACE_SOME: org$bukkit$event$inventory$InventoryAction;
  static PLACE_ONE: org$bukkit$event$inventory$InventoryAction;
  static SWAP_WITH_CURSOR: org$bukkit$event$inventory$InventoryAction;
  static DROP_ALL_CURSOR: org$bukkit$event$inventory$InventoryAction;
  static DROP_ONE_CURSOR: org$bukkit$event$inventory$InventoryAction;
  static DROP_ALL_SLOT: org$bukkit$event$inventory$InventoryAction;
  static DROP_ONE_SLOT: org$bukkit$event$inventory$InventoryAction;
  static MOVE_TO_OTHER_INVENTORY: org$bukkit$event$inventory$InventoryAction;
  static HOTBAR_MOVE_AND_READD: org$bukkit$event$inventory$InventoryAction;
  static HOTBAR_SWAP: org$bukkit$event$inventory$InventoryAction;
  static CLONE_STACK: org$bukkit$event$inventory$InventoryAction;
  static COLLECT_TO_CURSOR: org$bukkit$event$inventory$InventoryAction;
  static UNKNOWN: org$bukkit$event$inventory$InventoryAction;
  static values(): JavaArray<org$bukkit$event$inventory$InventoryAction>;
  static valueOf(arg0: string): org$bukkit$event$inventory$InventoryAction;
}


declare interface $org$bukkit$inventory$CraftingInventory
  extends $org$bukkit$inventory$Inventory {
  getResult(): org$bukkit$inventory$ItemStack;
  getMatrix(): JavaArray<org$bukkit$inventory$ItemStack>;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  setMatrix(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getRecipe(): org$bukkit$inventory$Recipe;
}

declare class org$bukkit$inventory$CraftingInventory
  implements $org$bukkit$inventory$CraftingInventory {
  getResult(): org$bukkit$inventory$ItemStack;
  getMatrix(): JavaArray<org$bukkit$inventory$ItemStack>;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  setMatrix(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getRecipe(): org$bukkit$inventory$Recipe;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$event$inventory$DragType {}

declare class org$bukkit$event$inventory$DragType
  implements $org$bukkit$event$inventory$DragType {
  static SINGLE: org$bukkit$event$inventory$DragType;
  static EVEN: org$bukkit$event$inventory$DragType;
  static values(): JavaArray<org$bukkit$event$inventory$DragType>;
  static valueOf(arg0: string): org$bukkit$event$inventory$DragType;
}


declare interface $org$bukkit$event$inventory$FurnaceBurnEvent
  extends $org$bukkit$event$Cancellable {
  getFuel(): org$bukkit$inventory$ItemStack;
  getBurnTime(): number;
  setBurnTime(arg0: number): void;
  isBurning(): boolean;
  setBurning(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$FurnaceBurnEvent
  implements $org$bukkit$event$inventory$FurnaceBurnEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: number
  );
  getFuel(): org$bukkit$inventory$ItemStack;
  getBurnTime(): number;
  setBurnTime(arg0: number): void;
  isBurning(): boolean;
  setBurning(arg0: boolean): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$FurnaceExtractEvent {
  getPlayer(): org$bukkit$entity$Player;
  getItemType(): org$bukkit$Material;
  getItemAmount(): number;
}

declare class org$bukkit$event$inventory$FurnaceExtractEvent
  implements $org$bukkit$event$inventory$FurnaceExtractEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number
  );
  getPlayer(): org$bukkit$entity$Player;
  getItemType(): org$bukkit$Material;
  getItemAmount(): number;
}


declare interface $org$bukkit$event$inventory$FurnaceSmeltEvent {}

declare class org$bukkit$event$inventory$FurnaceSmeltEvent
  implements $org$bukkit$event$inventory$FurnaceSmeltEvent {
  constructor(
    arg0: org$bukkit$block$Block,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$ItemStack
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$inventory$InventoryClickEvent {
  getSlotType(): org$bukkit$event$inventory$InventoryType$SlotType;
  getCursor(): org$bukkit$inventory$ItemStack;
  getCurrentItem(): org$bukkit$inventory$ItemStack;
  isRightClick(): boolean;
  isLeftClick(): boolean;
  isShiftClick(): boolean;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  setCurrentItem(arg0: org$bukkit$inventory$ItemStack): void;
  getClickedInventory(): org$bukkit$inventory$Inventory;
  getSlot(): number;
  getRawSlot(): number;
  getHotbarButton(): number;
  getAction(): org$bukkit$event$inventory$InventoryAction;
  getClick(): org$bukkit$event$inventory$ClickType;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryClickEvent
  implements $org$bukkit$event$inventory$InventoryClickEvent {
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$event$inventory$InventoryType$SlotType,
    arg2: number,
    arg3: org$bukkit$event$inventory$ClickType,
    arg4: org$bukkit$event$inventory$InventoryAction
  );
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$event$inventory$InventoryType$SlotType,
    arg2: number,
    arg3: org$bukkit$event$inventory$ClickType,
    arg4: org$bukkit$event$inventory$InventoryAction,
    arg5: number
  );
  getSlotType(): org$bukkit$event$inventory$InventoryType$SlotType;
  getCursor(): org$bukkit$inventory$ItemStack;
  getCurrentItem(): org$bukkit$inventory$ItemStack;
  isRightClick(): boolean;
  isLeftClick(): boolean;
  isShiftClick(): boolean;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  setCurrentItem(arg0: org$bukkit$inventory$ItemStack): void;
  getClickedInventory(): org$bukkit$inventory$Inventory;
  getSlot(): number;
  getRawSlot(): number;
  getHotbarButton(): number;
  getAction(): org$bukkit$event$inventory$InventoryAction;
  getClick(): org$bukkit$event$inventory$ClickType;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$inventory$InventoryCloseEvent {
  getReason(): org$bukkit$event$inventory$InventoryCloseEvent$Reason;

  getPlayer(): org$bukkit$entity$HumanEntity;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryCloseEvent
  implements $org$bukkit$event$inventory$InventoryCloseEvent {
  getReason(): org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  constructor(arg0: org$bukkit$inventory$InventoryView);
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$event$inventory$InventoryCloseEvent$Reason
  );
  getPlayer(): org$bukkit$entity$HumanEntity;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$InventoryCreativeEvent {
  getCursor(): org$bukkit$inventory$ItemStack;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$event$inventory$InventoryCreativeEvent
  implements $org$bukkit$event$inventory$InventoryCreativeEvent {
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$event$inventory$InventoryType$SlotType,
    arg2: number,
    arg3: org$bukkit$inventory$ItemStack
  );
  getCursor(): org$bukkit$inventory$ItemStack;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$inventory$InventoryDragEvent {
  getNewItems(): any /* java.util.Map */;
  getRawSlots(): any /* java.util.Set */;
  getInventorySlots(): any /* java.util.Set */;
  getCursor(): org$bukkit$inventory$ItemStack;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  getOldCursor(): org$bukkit$inventory$ItemStack;
  getType(): org$bukkit$event$inventory$DragType;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryDragEvent
  implements $org$bukkit$event$inventory$InventoryDragEvent {
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: boolean,
    arg4: any /* java.util.Map */
  );
  getNewItems(): any /* java.util.Map */;
  getRawSlots(): any /* java.util.Set */;
  getInventorySlots(): any /* java.util.Set */;
  getCursor(): org$bukkit$inventory$ItemStack;
  setCursor(arg0: org$bukkit$inventory$ItemStack): void;
  getOldCursor(): org$bukkit$inventory$ItemStack;
  getType(): org$bukkit$event$inventory$DragType;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$inventory$InventoryEvent {
  getInventory(): org$bukkit$inventory$Inventory;
  getViewers(): any /* java.util.List */;
  getView(): org$bukkit$inventory$InventoryView;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryEvent
  implements $org$bukkit$event$inventory$InventoryEvent {
  constructor(arg0: org$bukkit$inventory$InventoryView);
  getInventory(): org$bukkit$inventory$Inventory;
  getViewers(): any /* java.util.List */;
  getView(): org$bukkit$inventory$InventoryView;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$InventoryInteractEvent
  extends $org$bukkit$event$Cancellable {
  getWhoClicked(): org$bukkit$entity$HumanEntity;
  setResult(arg0: org$bukkit$event$Event$Result): void;
  getResult(): org$bukkit$event$Event$Result;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$inventory$InventoryInteractEvent
  implements $org$bukkit$event$inventory$InventoryInteractEvent {
  constructor(arg0: org$bukkit$inventory$InventoryView);
  getWhoClicked(): org$bukkit$entity$HumanEntity;
  setResult(arg0: org$bukkit$event$Event$Result): void;
  getResult(): org$bukkit$event$Event$Result;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$inventory$InventoryMoveItemEvent
  extends $org$bukkit$event$Cancellable {
  calledGetItem: boolean;
  calledSetItem: boolean;

  getSource(): org$bukkit$inventory$Inventory;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getDestination(): org$bukkit$inventory$Inventory;
  getInitiator(): org$bukkit$inventory$Inventory;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryMoveItemEvent
  implements $org$bukkit$event$inventory$InventoryMoveItemEvent {
  calledGetItem: boolean;
  calledSetItem: boolean;
  constructor(
    arg0: org$bukkit$inventory$Inventory,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$Inventory,
    arg3: boolean
  );
  getSource(): org$bukkit$inventory$Inventory;
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getDestination(): org$bukkit$inventory$Inventory;
  getInitiator(): org$bukkit$inventory$Inventory;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$InventoryOpenEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$HumanEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryOpenEvent
  implements $org$bukkit$event$inventory$InventoryOpenEvent {
  constructor(arg0: org$bukkit$inventory$InventoryView);
  getPlayer(): org$bukkit$entity$HumanEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$InventoryPickupItemEvent
  extends $org$bukkit$event$Cancellable {
  getInventory(): org$bukkit$inventory$Inventory;
  getItem(): org$bukkit$entity$Item;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$inventory$InventoryPickupItemEvent
  implements $org$bukkit$event$inventory$InventoryPickupItemEvent {
  constructor(
    arg0: org$bukkit$inventory$Inventory,
    arg1: org$bukkit$entity$Item
  );
  getInventory(): org$bukkit$inventory$Inventory;
  getItem(): org$bukkit$entity$Item;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$inventory$PrepareAnvilEvent {
  getInventory(): org$bukkit$inventory$AnvilInventory;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$event$inventory$PrepareAnvilEvent
  implements $org$bukkit$event$inventory$PrepareAnvilEvent {
  constructor(
    arg0: org$bukkit$inventory$InventoryView,
    arg1: org$bukkit$inventory$ItemStack
  );
  getInventory(): org$bukkit$inventory$AnvilInventory;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}


declare interface $org$bukkit$event$inventory$PrepareItemCraftEvent {
  getRecipe(): org$bukkit$inventory$Recipe;
  getInventory(): org$bukkit$inventory$CraftingInventory;
  isRepair(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$event$inventory$PrepareItemCraftEvent
  implements $org$bukkit$event$inventory$PrepareItemCraftEvent {
  constructor(
    arg0: org$bukkit$inventory$CraftingInventory,
    arg1: org$bukkit$inventory$InventoryView,
    arg2: boolean
  );
  getRecipe(): org$bukkit$inventory$Recipe;
  getInventory(): org$bukkit$inventory$CraftingInventory;
  isRepair(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}


declare interface $org$bukkit$event$inventory$TradeSelectEvent {
  getIndex(): number;
  getInventory(): org$bukkit$inventory$MerchantInventory;
  getMerchant(): org$bukkit$inventory$Merchant;
  getHandlers(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
}

declare class org$bukkit$event$inventory$TradeSelectEvent
  implements $org$bukkit$event$inventory$TradeSelectEvent {
  constructor(arg0: org$bukkit$inventory$InventoryView, arg1: number);
  getIndex(): number;
  getInventory(): org$bukkit$inventory$MerchantInventory;
  getMerchant(): org$bukkit$inventory$Merchant;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getInventory(): org$bukkit$inventory$Inventory;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$inventory$MerchantInventory
  extends $org$bukkit$inventory$Inventory {
  getSelectedRecipeIndex(): number;
  getSelectedRecipe(): org$bukkit$inventory$MerchantRecipe;
  getMerchant(): org$bukkit$inventory$Merchant;
}

declare class org$bukkit$inventory$MerchantInventory
  implements $org$bukkit$inventory$MerchantInventory {
  getSelectedRecipeIndex(): number;
  getSelectedRecipe(): org$bukkit$inventory$MerchantRecipe;
  getMerchant(): org$bukkit$inventory$Merchant;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$event$player$AsyncPlayerChatEvent
  extends $org$bukkit$event$Cancellable {
  getMessage(): string;
  setMessage(arg0: string): void;
  getFormat(): string;
  setFormat(arg0: string): void;
  getRecipients(): any /* java.util.Set */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$AsyncPlayerChatEvent
  implements $org$bukkit$event$player$AsyncPlayerChatEvent {
  constructor(
    arg0: boolean,
    arg1: org$bukkit$entity$Player,
    arg2: string,
    arg3: any /* java.util.Set */
  );
  getMessage(): string;
  setMessage(arg0: string): void;
  getFormat(): string;
  setFormat(arg0: string): void;
  getRecipients(): any /* java.util.Set */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$AsyncPlayerPreLoginEvent {
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;

  getLoginResult(): org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  getResult(): org$bukkit$event$player$PlayerPreLoginEvent$Result;
  setLoginResult(
    arg0: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result
  ): void;
  setResult(arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  allow(): void;
  disallow(
    arg0: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result,
    arg1: string
  ): void;
  disallow(
    arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result,
    arg1: string
  ): void;
  getName(): string;
  getAddress(): any /* java.net.InetAddress */;
  getUniqueId(): any /* java.util.UUID */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$AsyncPlayerPreLoginEvent
  implements $org$bukkit$event$player$AsyncPlayerPreLoginEvent {
  constructor(arg0: string, arg1: any /* java.net.InetAddress */);
  constructor(
    arg0: string,
    arg1: any /* java.net.InetAddress */,
    arg2: any /* java.util.UUID */
  );
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  constructor(
    arg0: string,
    arg1: any /* java.net.InetAddress */,
    arg2: any /* java.util.UUID */,
    arg3: com$destroystokyo$paper$profile$PlayerProfile
  );
  getLoginResult(): org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  getResult(): org$bukkit$event$player$PlayerPreLoginEvent$Result;
  setLoginResult(
    arg0: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result
  ): void;
  setResult(arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  allow(): void;
  disallow(
    arg0: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result,
    arg1: string
  ): void;
  disallow(
    arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result,
    arg1: string
  ): void;
  getName(): string;
  getAddress(): any /* java.net.InetAddress */;
  getUniqueId(): any /* java.util.UUID */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result {}

declare class org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result
  implements $org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result {
  static ALLOWED: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  static KICK_FULL: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  static KICK_BANNED: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  static KICK_WHITELIST: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  static KICK_OTHER: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  static values(): JavaArray<
    org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  static access$000(
    arg0: org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result
  ): org$bukkit$event$player$PlayerPreLoginEvent$Result;
}


declare interface $org$bukkit$event$player$PlayerPreLoginEvent$Result {}

declare class org$bukkit$event$player$PlayerPreLoginEvent$Result
  implements $org$bukkit$event$player$PlayerPreLoginEvent$Result {
  static ALLOWED: org$bukkit$event$player$PlayerPreLoginEvent$Result;
  static KICK_FULL: org$bukkit$event$player$PlayerPreLoginEvent$Result;
  static KICK_BANNED: org$bukkit$event$player$PlayerPreLoginEvent$Result;
  static KICK_WHITELIST: org$bukkit$event$player$PlayerPreLoginEvent$Result;
  static KICK_OTHER: org$bukkit$event$player$PlayerPreLoginEvent$Result;
  static values(): JavaArray<
    org$bukkit$event$player$PlayerPreLoginEvent$Result
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$player$PlayerPreLoginEvent$Result;
}


declare interface $org$bukkit$event$player$PlayerAdvancementDoneEvent {
  getAdvancement(): org$bukkit$advancement$Advancement;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerAdvancementDoneEvent
  implements $org$bukkit$event$player$PlayerAdvancementDoneEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$advancement$Advancement
  );
  getAdvancement(): org$bukkit$advancement$Advancement;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerAnimationEvent
  extends $org$bukkit$event$Cancellable {
  getAnimationType(): org$bukkit$event$player$PlayerAnimationType;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerAnimationEvent
  implements $org$bukkit$event$player$PlayerAnimationEvent {
  constructor(arg0: org$bukkit$entity$Player);
  getAnimationType(): org$bukkit$event$player$PlayerAnimationType;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerAnimationType {}

declare class org$bukkit$event$player$PlayerAnimationType
  implements $org$bukkit$event$player$PlayerAnimationType {
  static ARM_SWING: org$bukkit$event$player$PlayerAnimationType;
  static values(): JavaArray<org$bukkit$event$player$PlayerAnimationType>;
  static valueOf(arg0: string): org$bukkit$event$player$PlayerAnimationType;
}


declare interface $org$bukkit$event$player$PlayerArmorStandManipulateEvent {
  getPlayerItem(): org$bukkit$inventory$ItemStack;
  getArmorStandItem(): org$bukkit$inventory$ItemStack;
  getSlot(): org$bukkit$inventory$EquipmentSlot;
  getRightClicked(): org$bukkit$entity$ArmorStand;
  getHandlers(): org$bukkit$event$HandlerList;
  getRightClicked(): org$bukkit$entity$Entity;
}

declare class org$bukkit$event$player$PlayerArmorStandManipulateEvent
  implements $org$bukkit$event$player$PlayerArmorStandManipulateEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$ArmorStand,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$inventory$ItemStack,
    arg4: org$bukkit$inventory$EquipmentSlot
  );
  getPlayerItem(): org$bukkit$inventory$ItemStack;
  getArmorStandItem(): org$bukkit$inventory$ItemStack;
  getSlot(): org$bukkit$inventory$EquipmentSlot;
  getRightClicked(): org$bukkit$entity$ArmorStand;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  getRightClicked(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerAttemptPickupItemEvent
  extends $org$bukkit$event$Cancellable {
  getItem(): org$bukkit$entity$Item;
  getRemaining(): number;
  setFlyAtPlayer(arg0: boolean): void;
  getFlyAtPlayer(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerAttemptPickupItemEvent
  implements $org$bukkit$event$player$PlayerAttemptPickupItemEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$entity$Item);
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Item,
    arg2: number
  );
  getItem(): org$bukkit$entity$Item;
  getRemaining(): number;
  setFlyAtPlayer(arg0: boolean): void;
  getFlyAtPlayer(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerBedEnterEvent
  extends $org$bukkit$event$Cancellable {
  getBedEnterResult(): org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  useBed(): org$bukkit$event$Event$Result;
  setUseBed(arg0: org$bukkit$event$Event$Result): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getBed(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerBedEnterEvent
  implements $org$bukkit$event$player$PlayerBedEnterEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult
  );
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$block$Block);
  getBedEnterResult(): org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  useBed(): org$bukkit$event$Event$Result;
  setUseBed(arg0: org$bukkit$event$Event$Result): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getBed(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult {}

declare class org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult
  implements $org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult {
  static OK: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  static NOT_POSSIBLE_HERE: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  static NOT_POSSIBLE_NOW: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  static TOO_FAR_AWAY: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  static NOT_SAFE: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  static OTHER_PROBLEM: org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  static values(): JavaArray<
    org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
}


declare interface $org$bukkit$event$player$PlayerBedLeaveEvent {
  getBed(): org$bukkit$block$Block;
  shouldSetSpawnLocation(): boolean;
  setSpawnLocation(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerBedLeaveEvent
  implements $org$bukkit$event$player$PlayerBedLeaveEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: boolean
  );
  getBed(): org$bukkit$block$Block;
  shouldSetSpawnLocation(): boolean;
  setSpawnLocation(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerBucketEmptyEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerBucketEmptyEvent
  implements $org$bukkit$event$player$PlayerBucketEmptyEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace,
    arg3: org$bukkit$Material,
    arg4: org$bukkit$inventory$ItemStack
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace,
    arg4: org$bukkit$Material,
    arg5: org$bukkit$inventory$ItemStack
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace,
    arg3: org$bukkit$Material,
    arg4: org$bukkit$inventory$ItemStack,
    arg5: org$bukkit$inventory$EquipmentSlot
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace,
    arg4: org$bukkit$Material,
    arg5: org$bukkit$inventory$ItemStack,
    arg6: org$bukkit$inventory$EquipmentSlot
  );
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerBucketEvent
  extends $org$bukkit$event$Cancellable {
  getBucket(): org$bukkit$Material;
  getItemStack(): org$bukkit$inventory$ItemStack;
  setItemStack(arg0: org$bukkit$inventory$ItemStack): void;
  getBlock(): org$bukkit$block$Block;
  getBlockClicked(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$player$PlayerBucketEvent
  implements $org$bukkit$event$player$PlayerBucketEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace,
    arg3: org$bukkit$Material,
    arg4: org$bukkit$inventory$ItemStack
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace,
    arg4: org$bukkit$Material,
    arg5: org$bukkit$inventory$ItemStack
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace,
    arg3: org$bukkit$Material,
    arg4: org$bukkit$inventory$ItemStack,
    arg5: org$bukkit$inventory$EquipmentSlot
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace,
    arg4: org$bukkit$Material,
    arg5: org$bukkit$inventory$ItemStack,
    arg6: org$bukkit$inventory$EquipmentSlot
  );
  getBucket(): org$bukkit$Material;
  getItemStack(): org$bukkit$inventory$ItemStack;
  setItemStack(arg0: org$bukkit$inventory$ItemStack): void;
  getBlock(): org$bukkit$block$Block;
  getBlockClicked(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerBucketFillEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerBucketFillEvent
  implements $org$bukkit$event$player$PlayerBucketFillEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace,
    arg3: org$bukkit$Material,
    arg4: org$bukkit$inventory$ItemStack
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace,
    arg4: org$bukkit$Material,
    arg5: org$bukkit$inventory$ItemStack
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$BlockFace,
    arg3: org$bukkit$Material,
    arg4: org$bukkit$inventory$ItemStack,
    arg5: org$bukkit$inventory$EquipmentSlot
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$block$Block,
    arg2: org$bukkit$block$Block,
    arg3: org$bukkit$block$BlockFace,
    arg4: org$bukkit$Material,
    arg5: org$bukkit$inventory$ItemStack,
    arg6: org$bukkit$inventory$EquipmentSlot
  );
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerChangedMainHandEvent {
  getMainHand(): org$bukkit$inventory$MainHand;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerChangedMainHandEvent
  implements $org$bukkit$event$player$PlayerChangedMainHandEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$MainHand
  );
  getMainHand(): org$bukkit$inventory$MainHand;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerChangedWorldEvent {
  getFrom(): org$bukkit$World;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerChangedWorldEvent
  implements $org$bukkit$event$player$PlayerChangedWorldEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$World);
  getFrom(): org$bukkit$World;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerChannelEvent {
  getChannel(): string;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerChannelEvent
  implements $org$bukkit$event$player$PlayerChannelEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
  getChannel(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerChatEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getMessage(): string;
  setMessage(arg0: string): void;
  setPlayer(arg0: org$bukkit$entity$Player): void;
  getFormat(): string;
  setFormat(arg0: string): void;
  getRecipients(): any /* java.util.Set */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerChatEvent
  implements $org$bukkit$event$player$PlayerChatEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: string,
    arg3: any /* java.util.Set */
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getMessage(): string;
  setMessage(arg0: string): void;
  setPlayer(arg0: org$bukkit$entity$Player): void;
  getFormat(): string;
  setFormat(arg0: string): void;
  getRecipients(): any /* java.util.Set */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerChatTabCompleteEvent {
  getChatMessage(): string;
  getLastToken(): string;
  getTabCompletions(): java$util$Collection;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerChatTabCompleteEvent
  implements $org$bukkit$event$player$PlayerChatTabCompleteEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: java$util$Collection
  );
  getChatMessage(): string;
  getLastToken(): string;
  getTabCompletions(): java$util$Collection;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerCommandPreprocessEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getMessage(): string;
  setMessage(arg0: string): void;
  setPlayer(arg0: org$bukkit$entity$Player): void;
  getRecipients(): any /* java.util.Set */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerCommandPreprocessEvent
  implements $org$bukkit$event$player$PlayerCommandPreprocessEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: any /* java.util.Set */
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getMessage(): string;
  setMessage(arg0: string): void;
  setPlayer(arg0: org$bukkit$entity$Player): void;
  getRecipients(): any /* java.util.Set */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerCommandSendEvent {
  getCommands(): java$util$Collection;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerCommandSendEvent
  implements $org$bukkit$event$player$PlayerCommandSendEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: java$util$Collection);
  getCommands(): java$util$Collection;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerDropItemEvent
  extends $org$bukkit$event$Cancellable {
  getItemDrop(): org$bukkit$entity$Item;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerDropItemEvent
  implements $org$bukkit$event$player$PlayerDropItemEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$entity$Item);
  getItemDrop(): org$bukkit$entity$Item;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerEditBookEvent
  extends $org$bukkit$event$Cancellable {
  getPreviousBookMeta(): org$bukkit$inventory$meta$BookMeta;
  getNewBookMeta(): org$bukkit$inventory$meta$BookMeta;
  getSlot(): number;
  setNewBookMeta(arg0: org$bukkit$inventory$meta$BookMeta): void;
  isSigning(): boolean;
  setSigning(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$player$PlayerEditBookEvent
  implements $org$bukkit$event$player$PlayerEditBookEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: number,
    arg2: org$bukkit$inventory$meta$BookMeta,
    arg3: org$bukkit$inventory$meta$BookMeta,
    arg4: boolean
  );
  getPreviousBookMeta(): org$bukkit$inventory$meta$BookMeta;
  getNewBookMeta(): org$bukkit$inventory$meta$BookMeta;
  getSlot(): number;
  setNewBookMeta(arg0: org$bukkit$inventory$meta$BookMeta): void;
  isSigning(): boolean;
  setSigning(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$inventory$meta$BookMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasTitle(): boolean;
  getTitle(): string;
  setTitle(arg0: string): boolean;
  hasAuthor(): boolean;
  getAuthor(): string;
  setAuthor(arg0: string): void;
  hasGeneration(): boolean;
  getGeneration(): org$bukkit$inventory$meta$BookMeta$Generation;
  setGeneration(arg0: org$bukkit$inventory$meta$BookMeta$Generation): void;
  hasPages(): boolean;
  getPage(arg0: number): string;
  setPage(arg0: number, arg1: string): void;
  getPages(): any /* java.util.List */;
  setPages(arg0: any /* java.util.List */): void;
  setPages(arg0: JavaArray<string>): void;
  addPage(arg0: JavaArray<string>): void;
  getPageCount(): number;
  clone(): org$bukkit$inventory$meta$BookMeta;
  spigot(): org$bukkit$inventory$meta$BookMeta$Spigot;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$BookMeta
  implements $org$bukkit$inventory$meta$BookMeta {
  hasTitle(): boolean;
  getTitle(): string;
  setTitle(arg0: string): boolean;
  hasAuthor(): boolean;
  getAuthor(): string;
  setAuthor(arg0: string): void;
  hasGeneration(): boolean;
  getGeneration(): org$bukkit$inventory$meta$BookMeta$Generation;
  setGeneration(arg0: org$bukkit$inventory$meta$BookMeta$Generation): void;
  hasPages(): boolean;
  getPage(arg0: number): string;
  setPage(arg0: number, arg1: string): void;
  getPages(): any /* java.util.List */;
  setPages(arg0: any /* java.util.List */): void;
  setPages(arg0: JavaArray<string>): void;
  addPage(arg0: JavaArray<string>): void;
  getPageCount(): number;
  clone(): org$bukkit$inventory$meta$BookMeta;
  spigot(): org$bukkit$inventory$meta$BookMeta$Spigot;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$BookMeta$Generation {}

declare class org$bukkit$inventory$meta$BookMeta$Generation
  implements $org$bukkit$inventory$meta$BookMeta$Generation {
  static ORIGINAL: org$bukkit$inventory$meta$BookMeta$Generation;
  static COPY_OF_ORIGINAL: org$bukkit$inventory$meta$BookMeta$Generation;
  static COPY_OF_COPY: org$bukkit$inventory$meta$BookMeta$Generation;
  static TATTERED: org$bukkit$inventory$meta$BookMeta$Generation;
  static values(): JavaArray<org$bukkit$inventory$meta$BookMeta$Generation>;
  static valueOf(arg0: string): org$bukkit$inventory$meta$BookMeta$Generation;
}


declare interface $org$bukkit$inventory$meta$BookMeta$Spigot {
  getPage(arg0: number): JavaArray<unknown>;
  setPage(arg0: number, arg1: JavaArray<unknown>): void;
  getPages(): any /* java.util.List */;
  setPages(arg0: any /* java.util.List */): void;
  setPages(arg0: JavaArray<unknown>): void;
  addPage(arg0: JavaArray<unknown>): void;
}

declare class org$bukkit$inventory$meta$BookMeta$Spigot
  implements $org$bukkit$inventory$meta$BookMeta$Spigot {
  constructor();
  getPage(arg0: number): JavaArray<unknown>;
  setPage(arg0: number, arg1: JavaArray<unknown>): void;
  getPages(): any /* java.util.List */;
  setPages(arg0: any /* java.util.List */): void;
  setPages(arg0: JavaArray<unknown>): void;
  addPage(arg0: JavaArray<unknown>): void;
}


declare interface $org$bukkit$event$player$PlayerEggThrowEvent {
  getEgg(): org$bukkit$entity$Egg;
  isHatching(): boolean;
  setHatching(arg0: boolean): void;
  getHatchingType(): org$bukkit$entity$EntityType;
  setHatchingType(arg0: org$bukkit$entity$EntityType): void;
  getNumHatches(): Buffer;
  setNumHatches(arg0: Buffer): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerEggThrowEvent
  implements $org$bukkit$event$player$PlayerEggThrowEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Egg,
    arg2: boolean,
    arg3: Buffer,
    arg4: org$bukkit$entity$EntityType
  );
  getEgg(): org$bukkit$entity$Egg;
  isHatching(): boolean;
  setHatching(arg0: boolean): void;
  getHatchingType(): org$bukkit$entity$EntityType;
  setHatchingType(arg0: org$bukkit$entity$EntityType): void;
  getNumHatches(): Buffer;
  setNumHatches(arg0: Buffer): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerEvent {
  getPlayer(): org$bukkit$entity$Player;
}

declare class org$bukkit$event$player$PlayerEvent
  implements $org$bukkit$event$player$PlayerEvent {
  constructor(arg0: org$bukkit$entity$Player);
  constructor(arg0: org$bukkit$entity$Player, arg1: boolean);
  getPlayer(): org$bukkit$entity$Player;
}


declare interface $org$bukkit$event$player$PlayerExpChangeEvent {
  getSource(): org$bukkit$entity$Entity;
  getAmount(): number;
  setAmount(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerExpChangeEvent
  implements $org$bukkit$event$player$PlayerExpChangeEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: number);
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: number
  );
  getSource(): org$bukkit$entity$Entity;
  getAmount(): number;
  setAmount(arg0: number): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerFishEvent
  extends $org$bukkit$event$Cancellable {
  getCaught(): org$bukkit$entity$Entity;
  getHook(): org$bukkit$entity$FishHook;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getExpToDrop(): number;
  setExpToDrop(arg0: number): void;
  getState(): org$bukkit$event$player$PlayerFishEvent$State;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerFishEvent
  implements $org$bukkit$event$player$PlayerFishEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$entity$FishHook,
    arg3: org$bukkit$event$player$PlayerFishEvent$State
  );
  getCaught(): org$bukkit$entity$Entity;
  getHook(): org$bukkit$entity$FishHook;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getExpToDrop(): number;
  setExpToDrop(arg0: number): void;
  getState(): org$bukkit$event$player$PlayerFishEvent$State;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerFishEvent$State {}

declare class org$bukkit$event$player$PlayerFishEvent$State
  implements $org$bukkit$event$player$PlayerFishEvent$State {
  static FISHING: org$bukkit$event$player$PlayerFishEvent$State;
  static CAUGHT_FISH: org$bukkit$event$player$PlayerFishEvent$State;
  static CAUGHT_ENTITY: org$bukkit$event$player$PlayerFishEvent$State;
  static IN_GROUND: org$bukkit$event$player$PlayerFishEvent$State;
  static FAILED_ATTEMPT: org$bukkit$event$player$PlayerFishEvent$State;
  static REEL_IN: org$bukkit$event$player$PlayerFishEvent$State;
  static BITE: org$bukkit$event$player$PlayerFishEvent$State;
  static values(): JavaArray<org$bukkit$event$player$PlayerFishEvent$State>;
  static valueOf(arg0: string): org$bukkit$event$player$PlayerFishEvent$State;
}


declare interface $org$bukkit$event$player$PlayerGameModeChangeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getNewGameMode(): org$bukkit$GameMode;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerGameModeChangeEvent
  implements $org$bukkit$event$player$PlayerGameModeChangeEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$GameMode);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getNewGameMode(): org$bukkit$GameMode;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerInteractAtEntityEvent {
  getClickedPosition(): org$bukkit$util$Vector;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerInteractAtEntityEvent
  implements $org$bukkit$event$player$PlayerInteractAtEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$util$Vector
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$util$Vector,
    arg3: org$bukkit$inventory$EquipmentSlot
  );
  getClickedPosition(): org$bukkit$util$Vector;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerInteractEntityEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getRightClicked(): org$bukkit$entity$Entity;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerInteractEntityEvent
  implements $org$bukkit$event$player$PlayerInteractEntityEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$entity$Entity);
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$inventory$EquipmentSlot
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getRightClicked(): org$bukkit$entity$Entity;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerInteractEvent
  extends $org$bukkit$event$Cancellable {
  getAction(): org$bukkit$event$block$Action;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getItem(): org$bukkit$inventory$ItemStack;
  getMaterial(): org$bukkit$Material;
  hasBlock(): boolean;
  hasItem(): boolean;
  isBlockInHand(): boolean;
  getClickedBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  useInteractedBlock(): org$bukkit$event$Event$Result;
  setUseInteractedBlock(arg0: org$bukkit$event$Event$Result): void;
  useItemInHand(): org$bukkit$event$Event$Result;
  setUseItemInHand(arg0: org$bukkit$event$Event$Result): void;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerInteractEvent
  implements $org$bukkit$event$player$PlayerInteractEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$event$block$Action,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$block$Block,
    arg4: org$bukkit$block$BlockFace
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$event$block$Action,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$block$Block,
    arg4: org$bukkit$block$BlockFace,
    arg5: org$bukkit$inventory$EquipmentSlot
  );
  getAction(): org$bukkit$event$block$Action;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getItem(): org$bukkit$inventory$ItemStack;
  getMaterial(): org$bukkit$Material;
  hasBlock(): boolean;
  hasItem(): boolean;
  isBlockInHand(): boolean;
  getClickedBlock(): org$bukkit$block$Block;
  getBlockFace(): org$bukkit$block$BlockFace;
  useInteractedBlock(): org$bukkit$event$Event$Result;
  setUseInteractedBlock(arg0: org$bukkit$event$Event$Result): void;
  useItemInHand(): org$bukkit$event$Event$Result;
  setUseItemInHand(arg0: org$bukkit$event$Event$Result): void;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerItemBreakEvent {
  getBrokenItem(): org$bukkit$inventory$ItemStack;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerItemBreakEvent
  implements $org$bukkit$event$player$PlayerItemBreakEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack
  );
  getBrokenItem(): org$bukkit$inventory$ItemStack;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerItemConsumeEvent
  extends $org$bukkit$event$Cancellable {
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getReplacement(): org$bukkit$inventory$ItemStack;
  setReplacement(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerItemConsumeEvent
  implements $org$bukkit$event$player$PlayerItemConsumeEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack
  );
  getItem(): org$bukkit$inventory$ItemStack;
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getReplacement(): org$bukkit$inventory$ItemStack;
  setReplacement(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerItemDamageEvent
  extends $org$bukkit$event$Cancellable {
  getItem(): org$bukkit$inventory$ItemStack;
  getDamage(): number;
  setDamage(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerItemDamageEvent
  implements $org$bukkit$event$player$PlayerItemDamageEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: number
  );
  getItem(): org$bukkit$inventory$ItemStack;
  getDamage(): number;
  setDamage(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerItemHeldEvent
  extends $org$bukkit$event$Cancellable {
  getPreviousSlot(): number;
  getNewSlot(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerItemHeldEvent
  implements $org$bukkit$event$player$PlayerItemHeldEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: number, arg2: number);
  getPreviousSlot(): number;
  getNewSlot(): number;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerItemMendEvent
  extends $org$bukkit$event$Cancellable {
  getItem(): org$bukkit$inventory$ItemStack;
  getExperienceOrb(): org$bukkit$entity$ExperienceOrb;
  getRepairAmount(): number;
  setRepairAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerItemMendEvent
  implements $org$bukkit$event$player$PlayerItemMendEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$entity$ExperienceOrb,
    arg3: number
  );
  getItem(): org$bukkit$inventory$ItemStack;
  getExperienceOrb(): org$bukkit$entity$ExperienceOrb;
  getRepairAmount(): number;
  setRepairAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerJoinEvent {
  getJoinMessage(): string;
  setJoinMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerJoinEvent
  implements $org$bukkit$event$player$PlayerJoinEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
  getJoinMessage(): string;
  setJoinMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerKickEvent
  extends $org$bukkit$event$Cancellable {
  getReason(): string;
  getLeaveMessage(): string;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  setReason(arg0: string): void;
  setLeaveMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerKickEvent
  implements $org$bukkit$event$player$PlayerKickEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string, arg2: string);
  getReason(): string;
  getLeaveMessage(): string;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  setReason(arg0: string): void;
  setLeaveMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerLevelChangeEvent {
  getOldLevel(): number;
  getNewLevel(): number;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerLevelChangeEvent
  implements $org$bukkit$event$player$PlayerLevelChangeEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: number, arg2: number);
  getOldLevel(): number;
  getNewLevel(): number;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerLocaleChangeEvent {
  getLocale(): string;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerLocaleChangeEvent
  implements $org$bukkit$event$player$PlayerLocaleChangeEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
  getLocale(): string;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerLoginEvent {
  getRealAddress(): any /* java.net.InetAddress */;
  getResult(): org$bukkit$event$player$PlayerLoginEvent$Result;
  setResult(arg0: org$bukkit$event$player$PlayerLoginEvent$Result): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  getHostname(): string;
  allow(): void;
  disallow(
    arg0: org$bukkit$event$player$PlayerLoginEvent$Result,
    arg1: string
  ): void;
  getAddress(): any /* java.net.InetAddress */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerLoginEvent
  implements $org$bukkit$event$player$PlayerLoginEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: any /* java.net.InetAddress */,
    arg3: any /* java.net.InetAddress */
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: any /* java.net.InetAddress */
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: any /* java.net.InetAddress */,
    arg3: org$bukkit$event$player$PlayerLoginEvent$Result,
    arg4: string,
    arg5: any /* java.net.InetAddress */
  );
  getRealAddress(): any /* java.net.InetAddress */;
  getResult(): org$bukkit$event$player$PlayerLoginEvent$Result;
  setResult(arg0: org$bukkit$event$player$PlayerLoginEvent$Result): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  getHostname(): string;
  allow(): void;
  disallow(
    arg0: org$bukkit$event$player$PlayerLoginEvent$Result,
    arg1: string
  ): void;
  getAddress(): any /* java.net.InetAddress */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerLoginEvent$Result {}

declare class org$bukkit$event$player$PlayerLoginEvent$Result
  implements $org$bukkit$event$player$PlayerLoginEvent$Result {
  static ALLOWED: org$bukkit$event$player$PlayerLoginEvent$Result;
  static KICK_FULL: org$bukkit$event$player$PlayerLoginEvent$Result;
  static KICK_BANNED: org$bukkit$event$player$PlayerLoginEvent$Result;
  static KICK_WHITELIST: org$bukkit$event$player$PlayerLoginEvent$Result;
  static KICK_OTHER: org$bukkit$event$player$PlayerLoginEvent$Result;
  static values(): JavaArray<org$bukkit$event$player$PlayerLoginEvent$Result>;
  static valueOf(arg0: string): org$bukkit$event$player$PlayerLoginEvent$Result;
}


declare interface $org$bukkit$event$player$PlayerMoveEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getFrom(): org$bukkit$Location;
  setFrom(arg0: org$bukkit$Location): void;
  getTo(): org$bukkit$Location;
  setTo(arg0: org$bukkit$Location): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerMoveEvent
  implements $org$bukkit$event$player$PlayerMoveEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getFrom(): org$bukkit$Location;
  setFrom(arg0: org$bukkit$Location): void;
  getTo(): org$bukkit$Location;
  setTo(arg0: org$bukkit$Location): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerPickupArrowEvent {
  getArrow(): org$bukkit$entity$AbstractArrow;
}

declare class org$bukkit$event$player$PlayerPickupArrowEvent
  implements $org$bukkit$event$player$PlayerPickupArrowEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Item,
    arg2: org$bukkit$entity$AbstractArrow
  );
  getArrow(): org$bukkit$entity$AbstractArrow;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerPickupItemEvent
  extends $org$bukkit$event$Cancellable {
  getItem(): org$bukkit$entity$Item;
  getRemaining(): number;
  setFlyAtPlayer(arg0: boolean): void;
  getFlyAtPlayer(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerPickupItemEvent
  implements $org$bukkit$event$player$PlayerPickupItemEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Item,
    arg2: number
  );
  getItem(): org$bukkit$entity$Item;
  getRemaining(): number;
  setFlyAtPlayer(arg0: boolean): void;
  getFlyAtPlayer(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerPortalEvent {
  setSearchRadius(arg0: number): void;
  getSearchRadius(): number;
  getCanCreatePortal(): boolean;
  setCanCreatePortal(arg0: boolean): void;
  setCreationRadius(arg0: number): void;
  getCreationRadius(): number;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerPortalEvent
  implements $org$bukkit$event$player$PlayerPortalEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause,
    arg4: number,
    arg5: boolean,
    arg6: number
  );
  setSearchRadius(arg0: number): void;
  getSearchRadius(): number;
  getCanCreatePortal(): boolean;
  setCanCreatePortal(arg0: boolean): void;
  setCreationRadius(arg0: number): void;
  getCreationRadius(): number;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerPreLoginEvent {
  getResult(): org$bukkit$event$player$PlayerPreLoginEvent$Result;
  setResult(arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  allow(): void;
  disallow(
    arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result,
    arg1: string
  ): void;
  getName(): string;
  getAddress(): any /* java.net.InetAddress */;
  getHandlers(): org$bukkit$event$HandlerList;
  getUniqueId(): any /* java.util.UUID */;
}

declare class org$bukkit$event$player$PlayerPreLoginEvent
  implements $org$bukkit$event$player$PlayerPreLoginEvent {
  constructor(arg0: string, arg1: any /* java.net.InetAddress */);
  constructor(
    arg0: string,
    arg1: any /* java.net.InetAddress */,
    arg2: any /* java.util.UUID */
  );
  getResult(): org$bukkit$event$player$PlayerPreLoginEvent$Result;
  setResult(arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result): void;
  getKickMessage(): string;
  setKickMessage(arg0: string): void;
  allow(): void;
  disallow(
    arg0: org$bukkit$event$player$PlayerPreLoginEvent$Result,
    arg1: string
  ): void;
  getName(): string;
  getAddress(): any /* java.net.InetAddress */;
  getHandlers(): org$bukkit$event$HandlerList;
  getUniqueId(): any /* java.util.UUID */;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerQuitEvent {
  getQuitMessage(): string;
  setQuitMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerQuitEvent
  implements $org$bukkit$event$player$PlayerQuitEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
  getQuitMessage(): string;
  setQuitMessage(arg0: string): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerRecipeDiscoverEvent
  extends $org$bukkit$event$Cancellable {
  getRecipe(): org$bukkit$NamespacedKey;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerRecipeDiscoverEvent
  implements $org$bukkit$event$player$PlayerRecipeDiscoverEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$NamespacedKey);
  getRecipe(): org$bukkit$NamespacedKey;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerRegisterChannelEvent {}

declare class org$bukkit$event$player$PlayerRegisterChannelEvent
  implements $org$bukkit$event$player$PlayerRegisterChannelEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
}


declare interface $org$bukkit$event$player$PlayerResourcePackStatusEvent {
  getHash(): string;
  getStatus(): org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerResourcePackStatusEvent
  implements $org$bukkit$event$player$PlayerResourcePackStatusEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$event$player$PlayerResourcePackStatusEvent$Status
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$event$player$PlayerResourcePackStatusEvent$Status,
    arg2: string
  );
  getHash(): string;
  getStatus(): org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerRespawnEvent {
  getRespawnLocation(): org$bukkit$Location;
  setRespawnLocation(arg0: org$bukkit$Location): void;
  isBedSpawn(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerRespawnEvent
  implements $org$bukkit$event$player$PlayerRespawnEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: boolean
  );
  getRespawnLocation(): org$bukkit$Location;
  setRespawnLocation(arg0: org$bukkit$Location): void;
  isBedSpawn(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerRiptideEvent {
  getItem(): org$bukkit$inventory$ItemStack;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerRiptideEvent
  implements $org$bukkit$event$player$PlayerRiptideEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack
  );
  getItem(): org$bukkit$inventory$ItemStack;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerShearEntityEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
  getItem(): org$bukkit$inventory$ItemStack;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerShearEntityEvent
  implements $org$bukkit$event$player$PlayerShearEntityEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$inventory$ItemStack,
    arg3: org$bukkit$inventory$EquipmentSlot
  );
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$entity$Entity);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getEntity(): org$bukkit$entity$Entity;
  getItem(): org$bukkit$inventory$ItemStack;
  getHand(): org$bukkit$inventory$EquipmentSlot;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerStatisticIncrementEvent
  extends $org$bukkit$event$Cancellable {
  getStatistic(): org$bukkit$Statistic;
  getPreviousValue(): number;
  getNewValue(): number;
  getEntityType(): org$bukkit$entity$EntityType;
  getMaterial(): org$bukkit$Material;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerStatisticIncrementEvent
  implements $org$bukkit$event$player$PlayerStatisticIncrementEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Statistic,
    arg2: number,
    arg3: number
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Statistic,
    arg2: number,
    arg3: number,
    arg4: org$bukkit$entity$EntityType
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Statistic,
    arg2: number,
    arg3: number,
    arg4: org$bukkit$Material
  );
  getStatistic(): org$bukkit$Statistic;
  getPreviousValue(): number;
  getNewValue(): number;
  getEntityType(): org$bukkit$entity$EntityType;
  getMaterial(): org$bukkit$Material;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerSwapHandItemsEvent
  extends $org$bukkit$event$Cancellable {
  getMainHandItem(): org$bukkit$inventory$ItemStack;
  setMainHandItem(arg0: org$bukkit$inventory$ItemStack): void;
  getOffHandItem(): org$bukkit$inventory$ItemStack;
  setOffHandItem(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerSwapHandItemsEvent
  implements $org$bukkit$event$player$PlayerSwapHandItemsEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$ItemStack
  );
  getMainHandItem(): org$bukkit$inventory$ItemStack;
  setMainHandItem(arg0: org$bukkit$inventory$ItemStack): void;
  getOffHandItem(): org$bukkit$inventory$ItemStack;
  setOffHandItem(arg0: org$bukkit$inventory$ItemStack): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerTakeLecternBookEvent
  extends $org$bukkit$event$Cancellable {
  getLectern(): org$bukkit$block$Lectern;
  getBook(): org$bukkit$inventory$ItemStack;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerTakeLecternBookEvent
  implements $org$bukkit$event$player$PlayerTakeLecternBookEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$block$Lectern);
  getLectern(): org$bukkit$block$Lectern;
  getBook(): org$bukkit$inventory$ItemStack;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerTeleportEvent {
  getCause(): org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerTeleportEvent
  implements $org$bukkit$event$player$PlayerTeleportEvent {
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  constructor(
    arg0: org$bukkit$entity$Player,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location,
    arg3: org$bukkit$event$player$PlayerTeleportEvent$TeleportCause
  );
  getCause(): org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerToggleFlightEvent
  extends $org$bukkit$event$Cancellable {
  isFlying(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerToggleFlightEvent
  implements $org$bukkit$event$player$PlayerToggleFlightEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: boolean);
  isFlying(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerToggleSneakEvent
  extends $org$bukkit$event$Cancellable {
  isSneaking(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerToggleSneakEvent
  implements $org$bukkit$event$player$PlayerToggleSneakEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: boolean);
  isSneaking(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerToggleSprintEvent
  extends $org$bukkit$event$Cancellable {
  isSprinting(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerToggleSprintEvent
  implements $org$bukkit$event$player$PlayerToggleSprintEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: boolean);
  isSprinting(): boolean;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$player$PlayerUnleashEntityEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$player$PlayerUnleashEntityEvent
  implements $org$bukkit$event$player$PlayerUnleashEntityEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$entity$Player);
  getPlayer(): org$bukkit$entity$Player;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$player$PlayerUnregisterChannelEvent {}

declare class org$bukkit$event$player$PlayerUnregisterChannelEvent
  implements $org$bukkit$event$player$PlayerUnregisterChannelEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: string);
}


declare interface $org$bukkit$event$player$PlayerVelocityEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getVelocity(): org$bukkit$util$Vector;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$player$PlayerVelocityEvent
  implements $org$bukkit$event$player$PlayerVelocityEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$util$Vector);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getVelocity(): org$bukkit$util$Vector;
  setVelocity(arg0: org$bukkit$util$Vector): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$raid$RaidEvent {
  getRaid(): org$bukkit$Raid;
}

declare class org$bukkit$event$raid$RaidEvent
  implements $org$bukkit$event$raid$RaidEvent {
  constructor(arg0: org$bukkit$Raid, arg1: org$bukkit$World);
  getRaid(): org$bukkit$Raid;
}


declare interface $org$bukkit$event$raid$RaidFinishEvent {
  getWinners(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$raid$RaidFinishEvent
  implements $org$bukkit$event$raid$RaidFinishEvent {
  constructor(
    arg0: org$bukkit$Raid,
    arg1: org$bukkit$World,
    arg2: any /* java.util.List */
  );
  getWinners(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$raid$RaidSpawnWaveEvent {
  getPatrolLeader(): org$bukkit$entity$Raider;
  getRaiders(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$raid$RaidSpawnWaveEvent
  implements $org$bukkit$event$raid$RaidSpawnWaveEvent {
  constructor(
    arg0: org$bukkit$Raid,
    arg1: org$bukkit$World,
    arg2: org$bukkit$entity$Raider,
    arg3: any /* java.util.List */
  );
  getPatrolLeader(): org$bukkit$entity$Raider;
  getRaiders(): any /* java.util.List */;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$raid$RaidStopEvent {
  getReason(): org$bukkit$event$raid$RaidStopEvent$Reason;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$raid$RaidStopEvent
  implements $org$bukkit$event$raid$RaidStopEvent {
  constructor(
    arg0: org$bukkit$Raid,
    arg1: org$bukkit$World,
    arg2: org$bukkit$event$raid$RaidStopEvent$Reason
  );
  getReason(): org$bukkit$event$raid$RaidStopEvent$Reason;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$raid$RaidStopEvent$Reason {}

declare class org$bukkit$event$raid$RaidStopEvent$Reason
  implements $org$bukkit$event$raid$RaidStopEvent$Reason {
  static PEACE: org$bukkit$event$raid$RaidStopEvent$Reason;
  static TIMEOUT: org$bukkit$event$raid$RaidStopEvent$Reason;
  static FINISHED: org$bukkit$event$raid$RaidStopEvent$Reason;
  static UNSPAWNABLE: org$bukkit$event$raid$RaidStopEvent$Reason;
  static NOT_IN_VILLAGE: org$bukkit$event$raid$RaidStopEvent$Reason;
  static values(): JavaArray<org$bukkit$event$raid$RaidStopEvent$Reason>;
  static valueOf(arg0: string): org$bukkit$event$raid$RaidStopEvent$Reason;
}


declare interface $org$bukkit$event$raid$RaidTriggerEvent
  extends $org$bukkit$event$Cancellable {
  getPlayer(): org$bukkit$entity$Player;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$raid$RaidTriggerEvent
  implements $org$bukkit$event$raid$RaidTriggerEvent {
  constructor(
    arg0: org$bukkit$Raid,
    arg1: org$bukkit$World,
    arg2: org$bukkit$entity$Player
  );
  getPlayer(): org$bukkit$entity$Player;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$BroadcastMessageEvent
  extends $org$bukkit$event$Cancellable {
  getMessage(): string;
  setMessage(arg0: string): void;
  getRecipients(): any /* java.util.Set */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$BroadcastMessageEvent
  implements $org$bukkit$event$server$BroadcastMessageEvent {
  constructor(arg0: string, arg1: any /* java.util.Set */);
  constructor(arg0: boolean, arg1: string, arg2: any /* java.util.Set */);
  getMessage(): string;
  setMessage(arg0: string): void;
  getRecipients(): any /* java.util.Set */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$MapInitializeEvent {
  getMap(): org$bukkit$map$MapView;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$MapInitializeEvent
  implements $org$bukkit$event$server$MapInitializeEvent {
  constructor(arg0: org$bukkit$map$MapView);
  getMap(): org$bukkit$map$MapView;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$PluginDisableEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$PluginDisableEvent
  implements $org$bukkit$event$server$PluginDisableEvent {
  constructor(arg0: org$bukkit$plugin$Plugin);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$PluginEnableEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$PluginEnableEvent
  implements $org$bukkit$event$server$PluginEnableEvent {
  constructor(arg0: org$bukkit$plugin$Plugin);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$PluginEvent {
  getPlugin(): org$bukkit$plugin$Plugin;
}

declare class org$bukkit$event$server$PluginEvent
  implements $org$bukkit$event$server$PluginEvent {
  constructor(arg0: org$bukkit$plugin$Plugin);
  getPlugin(): org$bukkit$plugin$Plugin;
}


declare interface $org$bukkit$event$server$RemoteServerCommandEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$RemoteServerCommandEvent
  implements $org$bukkit$event$server$RemoteServerCommandEvent {
  constructor(arg0: org$bukkit$command$CommandSender, arg1: string);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$server$ServerCommandEvent
  extends $org$bukkit$event$Cancellable {
  getCommand(): string;
  setCommand(arg0: string): void;
  getSender(): org$bukkit$command$CommandSender;
  getHandlers(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}

declare class org$bukkit$event$server$ServerCommandEvent
  implements $org$bukkit$event$server$ServerCommandEvent {
  constructor(arg0: org$bukkit$command$CommandSender, arg1: string);
  getCommand(): string;
  setCommand(arg0: string): void;
  getSender(): org$bukkit$command$CommandSender;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
}


declare interface $org$bukkit$event$server$ServerEvent {}

declare class org$bukkit$event$server$ServerEvent
  implements $org$bukkit$event$server$ServerEvent {
  constructor();
  constructor(arg0: boolean);
}


declare interface $org$bukkit$event$server$ServerListPingEvent {
  getAddress(): any /* java.net.InetAddress */;
  getMotd(): string;
  setMotd(arg0: string): void;
  getNumPlayers(): number;
  getMaxPlayers(): number;
  setMaxPlayers(arg0: number): void;
  setServerIcon(arg0: org$bukkit$util$CachedServerIcon): void;
  getHandlers(): org$bukkit$event$HandlerList;
  iterator(): any /* java.util.Iterator */;
}

declare class org$bukkit$event$server$ServerListPingEvent
  implements $org$bukkit$event$server$ServerListPingEvent {
  constructor(
    arg0: any /* java.net.InetAddress */,
    arg1: string,
    arg2: number,
    arg3: number
  );
  constructor(arg0: any /* java.net.InetAddress */, arg1: string, arg2: number);
  getAddress(): any /* java.net.InetAddress */;
  getMotd(): string;
  setMotd(arg0: string): void;
  getNumPlayers(): number;
  getMaxPlayers(): number;
  setMaxPlayers(arg0: number): void;
  setServerIcon(arg0: org$bukkit$util$CachedServerIcon): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$event$server$ServerLoadEvent {
  getType(): org$bukkit$event$server$ServerLoadEvent$LoadType;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$ServerLoadEvent
  implements $org$bukkit$event$server$ServerLoadEvent {
  constructor(arg0: org$bukkit$event$server$ServerLoadEvent$LoadType);
  getType(): org$bukkit$event$server$ServerLoadEvent$LoadType;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$ServerLoadEvent$LoadType {}

declare class org$bukkit$event$server$ServerLoadEvent$LoadType
  implements $org$bukkit$event$server$ServerLoadEvent$LoadType {
  static STARTUP: org$bukkit$event$server$ServerLoadEvent$LoadType;
  static RELOAD: org$bukkit$event$server$ServerLoadEvent$LoadType;
  static values(): JavaArray<org$bukkit$event$server$ServerLoadEvent$LoadType>;
  static valueOf(
    arg0: string
  ): org$bukkit$event$server$ServerLoadEvent$LoadType;
}


declare interface $org$bukkit$event$server$ServiceEvent {
  getProvider(): org$bukkit$plugin$RegisteredServiceProvider;
}

declare class org$bukkit$event$server$ServiceEvent
  implements $org$bukkit$event$server$ServiceEvent {
  constructor(arg0: org$bukkit$plugin$RegisteredServiceProvider);
  getProvider(): org$bukkit$plugin$RegisteredServiceProvider;
}


declare interface $org$bukkit$event$server$ServiceRegisterEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$ServiceRegisterEvent
  implements $org$bukkit$event$server$ServiceRegisterEvent {
  constructor(arg0: org$bukkit$plugin$RegisteredServiceProvider);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$ServiceUnregisterEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$ServiceUnregisterEvent
  implements $org$bukkit$event$server$ServiceUnregisterEvent {
  constructor(arg0: org$bukkit$plugin$RegisteredServiceProvider);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$server$TabCompleteEvent
  extends $org$bukkit$event$Cancellable {
  getSender(): org$bukkit$command$CommandSender;
  getBuffer(): string;
  getCompletions(): any /* java.util.List */;
  isCommand(): boolean;
  getLocation(): org$bukkit$Location;
  setCompletions(arg0: any /* java.util.List */): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$server$TabCompleteEvent
  implements $org$bukkit$event$server$TabCompleteEvent {
  constructor(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: any /* java.util.List */
  );
  constructor(
    arg0: org$bukkit$command$CommandSender,
    arg1: string,
    arg2: any /* java.util.List */,
    arg3: boolean,
    arg4: org$bukkit$Location
  );
  getSender(): org$bukkit$command$CommandSender;
  getBuffer(): string;
  getCompletions(): any /* java.util.List */;
  isCommand(): boolean;
  getLocation(): org$bukkit$Location;
  setCompletions(arg0: any /* java.util.List */): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleBlockCollisionEvent {
  getBlock(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleBlockCollisionEvent
  implements $org$bukkit$event$vehicle$VehicleBlockCollisionEvent {
  constructor(arg0: org$bukkit$entity$Vehicle, arg1: org$bukkit$block$Block);
  getBlock(): org$bukkit$block$Block;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleCollisionEvent {}

declare class org$bukkit$event$vehicle$VehicleCollisionEvent
  implements $org$bukkit$event$vehicle$VehicleCollisionEvent {
  constructor(arg0: org$bukkit$entity$Vehicle);
}


declare interface $org$bukkit$event$vehicle$VehicleCreateEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleCreateEvent
  implements $org$bukkit$event$vehicle$VehicleCreateEvent {
  constructor(arg0: org$bukkit$entity$Vehicle);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleDamageEvent
  extends $org$bukkit$event$Cancellable {
  getAttacker(): org$bukkit$entity$Entity;
  getDamage(): number;
  setDamage(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleDamageEvent
  implements $org$bukkit$event$vehicle$VehicleDamageEvent {
  constructor(
    arg0: org$bukkit$entity$Vehicle,
    arg1: org$bukkit$entity$Entity,
    arg2: number
  );
  getAttacker(): org$bukkit$entity$Entity;
  getDamage(): number;
  setDamage(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleDestroyEvent
  extends $org$bukkit$event$Cancellable {
  getAttacker(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleDestroyEvent
  implements $org$bukkit$event$vehicle$VehicleDestroyEvent {
  constructor(arg0: org$bukkit$entity$Vehicle, arg1: org$bukkit$entity$Entity);
  getAttacker(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleEnterEvent
  extends $org$bukkit$event$Cancellable {
  getEntered(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleEnterEvent
  implements $org$bukkit$event$vehicle$VehicleEnterEvent {
  constructor(arg0: org$bukkit$entity$Vehicle, arg1: org$bukkit$entity$Entity);
  getEntered(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleEntityCollisionEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isPickupCancelled(): boolean;
  setPickupCancelled(arg0: boolean): void;
  isCollisionCancelled(): boolean;
  setCollisionCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleEntityCollisionEvent
  implements $org$bukkit$event$vehicle$VehicleEntityCollisionEvent {
  constructor(arg0: org$bukkit$entity$Vehicle, arg1: org$bukkit$entity$Entity);
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isPickupCancelled(): boolean;
  setPickupCancelled(arg0: boolean): void;
  isCollisionCancelled(): boolean;
  setCollisionCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleEvent {
  getVehicle(): org$bukkit$entity$Vehicle;
}

declare class org$bukkit$event$vehicle$VehicleEvent
  implements $org$bukkit$event$vehicle$VehicleEvent {
  constructor(arg0: org$bukkit$entity$Vehicle);
  getVehicle(): org$bukkit$entity$Vehicle;
}


declare interface $org$bukkit$event$vehicle$VehicleExitEvent
  extends $org$bukkit$event$Cancellable {
  getExited(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isCancellable(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleExitEvent
  implements $org$bukkit$event$vehicle$VehicleExitEvent {
  constructor(
    arg0: org$bukkit$entity$Vehicle,
    arg1: org$bukkit$entity$LivingEntity,
    arg2: boolean
  );
  constructor(
    arg0: org$bukkit$entity$Vehicle,
    arg1: org$bukkit$entity$LivingEntity
  );
  getExited(): org$bukkit$entity$LivingEntity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isCancellable(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleMoveEvent {
  getFrom(): org$bukkit$Location;
  getTo(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleMoveEvent
  implements $org$bukkit$event$vehicle$VehicleMoveEvent {
  constructor(
    arg0: org$bukkit$entity$Vehicle,
    arg1: org$bukkit$Location,
    arg2: org$bukkit$Location
  );
  getFrom(): org$bukkit$Location;
  getTo(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$vehicle$VehicleUpdateEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$vehicle$VehicleUpdateEvent
  implements $org$bukkit$event$vehicle$VehicleUpdateEvent {
  constructor(arg0: org$bukkit$entity$Vehicle);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$weather$LightningStrikeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getLightning(): org$bukkit$entity$LightningStrike;
  getCause(): org$bukkit$event$weather$LightningStrikeEvent$Cause;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$weather$LightningStrikeEvent
  implements $org$bukkit$event$weather$LightningStrikeEvent {
  constructor(arg0: org$bukkit$World, arg1: org$bukkit$entity$LightningStrike);
  constructor(
    arg0: org$bukkit$World,
    arg1: org$bukkit$entity$LightningStrike,
    arg2: org$bukkit$event$weather$LightningStrikeEvent$Cause
  );
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getLightning(): org$bukkit$entity$LightningStrike;
  getCause(): org$bukkit$event$weather$LightningStrikeEvent$Cause;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$weather$LightningStrikeEvent$Cause {}

declare class org$bukkit$event$weather$LightningStrikeEvent$Cause
  implements $org$bukkit$event$weather$LightningStrikeEvent$Cause {
  static COMMAND: org$bukkit$event$weather$LightningStrikeEvent$Cause;
  static TRIDENT: org$bukkit$event$weather$LightningStrikeEvent$Cause;
  static TRAP: org$bukkit$event$weather$LightningStrikeEvent$Cause;
  static WEATHER: org$bukkit$event$weather$LightningStrikeEvent$Cause;
  static UNKNOWN: org$bukkit$event$weather$LightningStrikeEvent$Cause;
  static values(): JavaArray<
    org$bukkit$event$weather$LightningStrikeEvent$Cause
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$weather$LightningStrikeEvent$Cause;
}


declare interface $org$bukkit$event$weather$ThunderChangeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  toThunderState(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$weather$ThunderChangeEvent
  implements $org$bukkit$event$weather$ThunderChangeEvent {
  constructor(arg0: org$bukkit$World, arg1: boolean);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  toThunderState(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$weather$WeatherChangeEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  toWeatherState(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$weather$WeatherChangeEvent
  implements $org$bukkit$event$weather$WeatherChangeEvent {
  constructor(arg0: org$bukkit$World, arg1: boolean);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  toWeatherState(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$weather$WeatherEvent {
  getWorld(): org$bukkit$World;
}

declare class org$bukkit$event$weather$WeatherEvent
  implements $org$bukkit$event$weather$WeatherEvent {
  constructor(arg0: org$bukkit$World);
  getWorld(): org$bukkit$World;
}


declare interface $org$bukkit$event$world$ChunkEvent {
  getChunk(): org$bukkit$Chunk;
}

declare class org$bukkit$event$world$ChunkEvent
  implements $org$bukkit$event$world$ChunkEvent {
  constructor(arg0: org$bukkit$Chunk);
  getChunk(): org$bukkit$Chunk;
}


declare interface $org$bukkit$event$world$ChunkLoadEvent {
  isNewChunk(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$ChunkLoadEvent
  implements $org$bukkit$event$world$ChunkLoadEvent {
  constructor(arg0: org$bukkit$Chunk, arg1: boolean);
  isNewChunk(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$ChunkPopulateEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$ChunkPopulateEvent
  implements $org$bukkit$event$world$ChunkPopulateEvent {
  constructor(arg0: org$bukkit$Chunk);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$ChunkUnloadEvent {
  isSaveChunk(): boolean;
  setSaveChunk(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$ChunkUnloadEvent
  implements $org$bukkit$event$world$ChunkUnloadEvent {
  constructor(arg0: org$bukkit$Chunk);
  constructor(arg0: org$bukkit$Chunk, arg1: boolean);
  isSaveChunk(): boolean;
  setSaveChunk(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$LootGenerateEvent
  extends $org$bukkit$event$Cancellable {
  getEntity(): org$bukkit$entity$Entity;
  getInventoryHolder(): org$bukkit$inventory$InventoryHolder;
  getLootTable(): org$bukkit$loot$LootTable;
  getLootContext(): org$bukkit$loot$LootContext;
  setLoot(arg0: java$util$Collection): void;
  getLoot(): any /* java.util.List */;
  isPlugin(): boolean;
  setCancelled(arg0: boolean): void;
  isCancelled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$LootGenerateEvent
  implements $org$bukkit$event$world$LootGenerateEvent {
  constructor(
    arg0: org$bukkit$World,
    arg1: org$bukkit$entity$Entity,
    arg2: org$bukkit$inventory$InventoryHolder,
    arg3: org$bukkit$loot$LootTable,
    arg4: org$bukkit$loot$LootContext,
    arg5: any /* java.util.List */,
    arg6: boolean
  );
  getEntity(): org$bukkit$entity$Entity;
  getInventoryHolder(): org$bukkit$inventory$InventoryHolder;
  getLootTable(): org$bukkit$loot$LootTable;
  getLootContext(): org$bukkit$loot$LootContext;
  setLoot(arg0: java$util$Collection): void;
  getLoot(): any /* java.util.List */;
  isPlugin(): boolean;
  setCancelled(arg0: boolean): void;
  isCancelled(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$PortalCreateEvent
  extends $org$bukkit$event$Cancellable {
  getBlocks(): any /* java.util.List */;
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getReason(): org$bukkit$event$world$PortalCreateEvent$CreateReason;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$PortalCreateEvent
  implements $org$bukkit$event$world$PortalCreateEvent {
  constructor(
    arg0: any /* java.util.List */,
    arg1: org$bukkit$World,
    arg2: org$bukkit$event$world$PortalCreateEvent$CreateReason
  );
  constructor(
    arg0: any /* java.util.List */,
    arg1: org$bukkit$World,
    arg2: org$bukkit$entity$Entity,
    arg3: org$bukkit$event$world$PortalCreateEvent$CreateReason
  );
  getBlocks(): any /* java.util.List */;
  getEntity(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getReason(): org$bukkit$event$world$PortalCreateEvent$CreateReason;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$PortalCreateEvent$CreateReason {}

declare class org$bukkit$event$world$PortalCreateEvent$CreateReason
  implements $org$bukkit$event$world$PortalCreateEvent$CreateReason {
  static FIRE: org$bukkit$event$world$PortalCreateEvent$CreateReason;
  static NETHER_PAIR: org$bukkit$event$world$PortalCreateEvent$CreateReason;
  static END_PLATFORM: org$bukkit$event$world$PortalCreateEvent$CreateReason;
  static values(): JavaArray<
    org$bukkit$event$world$PortalCreateEvent$CreateReason
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$event$world$PortalCreateEvent$CreateReason;
}


declare interface $org$bukkit$event$world$SpawnChangeEvent {
  getPreviousLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$SpawnChangeEvent
  implements $org$bukkit$event$world$SpawnChangeEvent {
  constructor(arg0: org$bukkit$World, arg1: org$bukkit$Location);
  getPreviousLocation(): org$bukkit$Location;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$StructureGrowEvent
  extends $org$bukkit$event$Cancellable {
  getLocation(): org$bukkit$Location;
  getSpecies(): org$bukkit$TreeType;
  isFromBonemeal(): boolean;
  getPlayer(): org$bukkit$entity$Player;
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$StructureGrowEvent
  implements $org$bukkit$event$world$StructureGrowEvent {
  constructor(
    arg0: org$bukkit$Location,
    arg1: org$bukkit$TreeType,
    arg2: boolean,
    arg3: org$bukkit$entity$Player,
    arg4: any /* java.util.List */
  );
  getLocation(): org$bukkit$Location;
  getSpecies(): org$bukkit$TreeType;
  isFromBonemeal(): boolean;
  getPlayer(): org$bukkit$entity$Player;
  getBlocks(): any /* java.util.List */;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$TimeSkipEvent
  extends $org$bukkit$event$Cancellable {
  getSkipReason(): org$bukkit$event$world$TimeSkipEvent$SkipReason;
  getSkipAmount(): number;
  setSkipAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$TimeSkipEvent
  implements $org$bukkit$event$world$TimeSkipEvent {
  constructor(
    arg0: org$bukkit$World,
    arg1: org$bukkit$event$world$TimeSkipEvent$SkipReason,
    arg2: number
  );
  getSkipReason(): org$bukkit$event$world$TimeSkipEvent$SkipReason;
  getSkipAmount(): number;
  setSkipAmount(arg0: number): void;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$TimeSkipEvent$SkipReason {}

declare class org$bukkit$event$world$TimeSkipEvent$SkipReason
  implements $org$bukkit$event$world$TimeSkipEvent$SkipReason {
  static COMMAND: org$bukkit$event$world$TimeSkipEvent$SkipReason;
  static CUSTOM: org$bukkit$event$world$TimeSkipEvent$SkipReason;
  static NIGHT_SKIP: org$bukkit$event$world$TimeSkipEvent$SkipReason;
  static values(): JavaArray<org$bukkit$event$world$TimeSkipEvent$SkipReason>;
  static valueOf(arg0: string): org$bukkit$event$world$TimeSkipEvent$SkipReason;
}


declare interface $org$bukkit$event$world$WorldEvent {
  getWorld(): org$bukkit$World;
}

declare class org$bukkit$event$world$WorldEvent
  implements $org$bukkit$event$world$WorldEvent {
  constructor(arg0: org$bukkit$World);
  getWorld(): org$bukkit$World;
}


declare interface $org$bukkit$event$world$WorldInitEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$WorldInitEvent
  implements $org$bukkit$event$world$WorldInitEvent {
  constructor(arg0: org$bukkit$World);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$WorldLoadEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$WorldLoadEvent
  implements $org$bukkit$event$world$WorldLoadEvent {
  constructor(arg0: org$bukkit$World);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$WorldSaveEvent {
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$WorldSaveEvent
  implements $org$bukkit$event$world$WorldSaveEvent {
  constructor(arg0: org$bukkit$World);
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$event$world$WorldUnloadEvent
  extends $org$bukkit$event$Cancellable {
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$bukkit$event$world$WorldUnloadEvent
  implements $org$bukkit$event$world$WorldUnloadEvent {
  constructor(arg0: org$bukkit$World);
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$bukkit$generator$BlockPopulator {
  populate(
    arg0: org$bukkit$World,
    arg1: any /* java.util.Random */,
    arg2: org$bukkit$Chunk
  ): void;
}

declare class org$bukkit$generator$BlockPopulator
  implements $org$bukkit$generator$BlockPopulator {
  constructor();
  populate(
    arg0: org$bukkit$World,
    arg1: any /* java.util.Random */,
    arg2: org$bukkit$Chunk
  ): void;
}


declare interface $org$bukkit$generator$ChunkGenerator$1 {}

declare class org$bukkit$generator$ChunkGenerator$1
  implements $org$bukkit$generator$ChunkGenerator$1 {}


declare interface $org$bukkit$GrassSpecies {
  getData(): Buffer;
}

declare class org$bukkit$GrassSpecies implements $org$bukkit$GrassSpecies {
  static DEAD: org$bukkit$GrassSpecies;
  static NORMAL: org$bukkit$GrassSpecies;
  static FERN_LIKE: org$bukkit$GrassSpecies;
  static values(): JavaArray<org$bukkit$GrassSpecies>;
  static valueOf(arg0: string): org$bukkit$GrassSpecies;
  getData(): Buffer;
  static getByData(arg0: Buffer): org$bukkit$GrassSpecies;
}


declare interface $org$bukkit$help$GenericCommandHelpTopic {
  canSee(arg0: org$bukkit$command$CommandSender): boolean;
}

declare class org$bukkit$help$GenericCommandHelpTopic
  implements $org$bukkit$help$GenericCommandHelpTopic {
  constructor(arg0: org$bukkit$command$Command);
  canSee(arg0: org$bukkit$command$CommandSender): boolean;
}


declare interface $org$bukkit$help$HelpTopicComparator {
  compare(
    arg0: org$bukkit$help$HelpTopic,
    arg1: org$bukkit$help$HelpTopic
  ): number;
  compare(arg0: any, arg1: any): number;
}

declare class org$bukkit$help$HelpTopicComparator
  implements $org$bukkit$help$HelpTopicComparator {
  static topicNameComparatorInstance(): org$bukkit$help$HelpTopicComparator$TopicNameComparator;
  static helpTopicComparatorInstance(): org$bukkit$help$HelpTopicComparator;
  compare(
    arg0: org$bukkit$help$HelpTopic,
    arg1: org$bukkit$help$HelpTopic
  ): number;
  compare(arg0: any, arg1: any): number;
}


declare interface $org$bukkit$help$HelpTopicComparator$TopicNameComparator {
  compare(arg0: string, arg1: string): number;
  compare(arg0: any, arg1: any): number;
}

declare class org$bukkit$help$HelpTopicComparator$TopicNameComparator
  implements $org$bukkit$help$HelpTopicComparator$TopicNameComparator {
  compare(arg0: string, arg1: string): number;
  compare(arg0: any, arg1: any): number;
  constructor(arg0: org$bukkit$help$HelpTopicComparator$1);
}


declare interface $org$bukkit$help$HelpTopicComparator$1 {}

declare class org$bukkit$help$HelpTopicComparator$1
  implements $org$bukkit$help$HelpTopicComparator$1 {}


declare interface $org$bukkit$help$IndexHelpTopic {
  setTopicsCollection(arg0: java$util$Collection): void;
  canSee(arg0: org$bukkit$command$CommandSender): boolean;
  amendCanSee(arg0: string): void;
  getFullText(arg0: org$bukkit$command$CommandSender): string;
  buildPreamble(arg0: org$bukkit$command$CommandSender): string;
  buildIndexLine(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$help$HelpTopic
  ): string;
}

declare class org$bukkit$help$IndexHelpTopic
  implements $org$bukkit$help$IndexHelpTopic {
  constructor(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: java$util$Collection
  );
  constructor(
    arg0: string,
    arg1: string,
    arg2: string,
    arg3: java$util$Collection,
    arg4: string
  );
  setTopicsCollection(arg0: java$util$Collection): void;
  canSee(arg0: org$bukkit$command$CommandSender): boolean;
  amendCanSee(arg0: string): void;
  getFullText(arg0: org$bukkit$command$CommandSender): string;
  buildPreamble(arg0: org$bukkit$command$CommandSender): string;
  buildIndexLine(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$help$HelpTopic
  ): string;
}


declare interface $org$bukkit$inventory$BeaconInventory
  extends $org$bukkit$inventory$Inventory {
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getItem(): org$bukkit$inventory$ItemStack;
}

declare class org$bukkit$inventory$BeaconInventory
  implements $org$bukkit$inventory$BeaconInventory {
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getItem(): org$bukkit$inventory$ItemStack;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$BlastingRecipe {}

declare class org$bukkit$inventory$BlastingRecipe
  implements $org$bukkit$inventory$BlastingRecipe {
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$RecipeChoice,
    arg3: number,
    arg4: number
  );
  getKey(): org$bukkit$NamespacedKey;
  getResult(): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$inventory$CampfireRecipe {}

declare class org$bukkit$inventory$CampfireRecipe
  implements $org$bukkit$inventory$CampfireRecipe {
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$RecipeChoice,
    arg3: number,
    arg4: number
  );
  getKey(): org$bukkit$NamespacedKey;
  getResult(): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$inventory$CartographyInventory
  extends $org$bukkit$inventory$Inventory {}

declare class org$bukkit$inventory$CartographyInventory
  implements $org$bukkit$inventory$CartographyInventory {
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$ComplexRecipe
  extends $org$bukkit$inventory$Recipe,
    $org$bukkit$Keyed {}

declare class org$bukkit$inventory$ComplexRecipe
  implements $org$bukkit$inventory$ComplexRecipe {
  getKey(): org$bukkit$NamespacedKey;
  getResult(): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$inventory$CookingRecipe
  extends $org$bukkit$inventory$Recipe,
    $org$bukkit$Keyed {
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$CookingRecipe;
  getInput(): org$bukkit$inventory$ItemStack;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$CookingRecipe;
  getInputChoice(): org$bukkit$inventory$RecipeChoice;
  getResult(): org$bukkit$inventory$ItemStack;
  setExperience(arg0: number): void;
  getExperience(): number;
  setCookingTime(arg0: number): void;
  getCookingTime(): number;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}

declare class org$bukkit$inventory$CookingRecipe
  implements $org$bukkit$inventory$CookingRecipe {
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$RecipeChoice,
    arg3: number,
    arg4: number
  );
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$CookingRecipe;
  getInput(): org$bukkit$inventory$ItemStack;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$CookingRecipe;
  getInputChoice(): org$bukkit$inventory$RecipeChoice;
  getResult(): org$bukkit$inventory$ItemStack;
  setExperience(arg0: number): void;
  getExperience(): number;
  setCookingTime(arg0: number): void;
  getCookingTime(): number;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}


declare interface $org$bukkit$inventory$EnchantingInventory
  extends $org$bukkit$inventory$Inventory {
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getItem(): org$bukkit$inventory$ItemStack;
  setSecondary(arg0: org$bukkit$inventory$ItemStack): void;
  getSecondary(): org$bukkit$inventory$ItemStack;
}

declare class org$bukkit$inventory$EnchantingInventory
  implements $org$bukkit$inventory$EnchantingInventory {
  setItem(arg0: org$bukkit$inventory$ItemStack): void;
  getItem(): org$bukkit$inventory$ItemStack;
  setSecondary(arg0: org$bukkit$inventory$ItemStack): void;
  getSecondary(): org$bukkit$inventory$ItemStack;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$FurnaceRecipe {
  setInput(
    arg0: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$FurnaceRecipe;
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$FurnaceRecipe;
  setInput(
    arg0: org$bukkit$Material,
    arg1: number
  ): org$bukkit$inventory$FurnaceRecipe;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$FurnaceRecipe;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$CookingRecipe;
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$CookingRecipe;
}

declare class org$bukkit$inventory$FurnaceRecipe
  implements $org$bukkit$inventory$FurnaceRecipe {
  constructor(arg0: org$bukkit$inventory$ItemStack, arg1: org$bukkit$Material);
  constructor(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: org$bukkit$material$MaterialData
  );
  constructor(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: org$bukkit$material$MaterialData,
    arg2: number
  );
  constructor(
    arg0: org$bukkit$inventory$ItemStack,
    arg1: org$bukkit$Material,
    arg2: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number,
    arg5: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$RecipeChoice,
    arg3: number,
    arg4: number
  );
  setInput(
    arg0: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$FurnaceRecipe;
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$FurnaceRecipe;
  setInput(
    arg0: org$bukkit$Material,
    arg1: number
  ): org$bukkit$inventory$FurnaceRecipe;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$FurnaceRecipe;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$CookingRecipe;
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$CookingRecipe;
  getKey(): org$bukkit$NamespacedKey;
  getResult(): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$inventory$InventoryView$1 {}

declare class org$bukkit$inventory$InventoryView$1
  implements $org$bukkit$inventory$InventoryView$1 {}


declare interface $org$bukkit$inventory$LecternInventory
  extends $org$bukkit$inventory$Inventory {
  getHolder(): org$bukkit$block$Lectern;
  getBook(): org$bukkit$inventory$ItemStack;
  setBook(arg0: org$bukkit$inventory$ItemStack): void;
  getHolder(): org$bukkit$inventory$InventoryHolder;
}

declare class org$bukkit$inventory$LecternInventory
  implements $org$bukkit$inventory$LecternInventory {
  getHolder(): org$bukkit$block$Lectern;
  getBook(): org$bukkit$inventory$ItemStack;
  setBook(arg0: org$bukkit$inventory$ItemStack): void;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$LoomInventory
  extends $org$bukkit$inventory$Inventory {}

declare class org$bukkit$inventory$LoomInventory
  implements $org$bukkit$inventory$LoomInventory {
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$meta$BannerMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  getBaseColor(): org$bukkit$DyeColor;
  setBaseColor(arg0: org$bukkit$DyeColor): void;
  getPatterns(): any /* java.util.List */;
  setPatterns(arg0: any /* java.util.List */): void;
  addPattern(arg0: org$bukkit$block$banner$Pattern): void;
  getPattern(arg0: number): org$bukkit$block$banner$Pattern;
  removePattern(arg0: number): org$bukkit$block$banner$Pattern;
  setPattern(arg0: number, arg1: org$bukkit$block$banner$Pattern): void;
  numberOfPatterns(): number;
}

declare class org$bukkit$inventory$meta$BannerMeta
  implements $org$bukkit$inventory$meta$BannerMeta {
  getBaseColor(): org$bukkit$DyeColor;
  setBaseColor(arg0: org$bukkit$DyeColor): void;
  getPatterns(): any /* java.util.List */;
  setPatterns(arg0: any /* java.util.List */): void;
  addPattern(arg0: org$bukkit$block$banner$Pattern): void;
  getPattern(arg0: number): org$bukkit$block$banner$Pattern;
  removePattern(arg0: number): org$bukkit$block$banner$Pattern;
  setPattern(arg0: number, arg1: org$bukkit$block$banner$Pattern): void;
  numberOfPatterns(): number;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$BlockDataMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasBlockData(): boolean;
  getBlockData(arg0: org$bukkit$Material): org$bukkit$block$data$BlockData;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
}

declare class org$bukkit$inventory$meta$BlockDataMeta
  implements $org$bukkit$inventory$meta$BlockDataMeta {
  hasBlockData(): boolean;
  getBlockData(arg0: org$bukkit$Material): org$bukkit$block$data$BlockData;
  setBlockData(arg0: org$bukkit$block$data$BlockData): void;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$BlockStateMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasBlockState(): boolean;
  getBlockState(): org$bukkit$block$BlockState;
  setBlockState(arg0: org$bukkit$block$BlockState): void;
}

declare class org$bukkit$inventory$meta$BlockStateMeta
  implements $org$bukkit$inventory$meta$BlockStateMeta {
  hasBlockState(): boolean;
  getBlockState(): org$bukkit$block$BlockState;
  setBlockState(arg0: org$bukkit$block$BlockState): void;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$CrossbowMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasChargedProjectiles(): boolean;
  getChargedProjectiles(): any /* java.util.List */;
  setChargedProjectiles(arg0: any /* java.util.List */): void;
  addChargedProjectile(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$meta$CrossbowMeta
  implements $org$bukkit$inventory$meta$CrossbowMeta {
  hasChargedProjectiles(): boolean;
  getChargedProjectiles(): any /* java.util.List */;
  setChargedProjectiles(arg0: any /* java.util.List */): void;
  addChargedProjectile(arg0: org$bukkit$inventory$ItemStack): void;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$Damageable {
  hasDamage(): boolean;
  getDamage(): number;
  setDamage(arg0: number): void;
  clone(): org$bukkit$inventory$meta$Damageable;
}

declare class org$bukkit$inventory$meta$Damageable
  implements $org$bukkit$inventory$meta$Damageable {
  hasDamage(): boolean;
  getDamage(): number;
  setDamage(arg0: number): void;
  clone(): org$bukkit$inventory$meta$Damageable;
}


declare interface $org$bukkit$inventory$meta$EnchantmentStorageMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasStoredEnchants(): boolean;
  hasStoredEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getStoredEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getStoredEnchants(): any /* java.util.Map */;
  addStoredEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeStoredEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingStoredEnchant(
    arg0: org$bukkit$enchantments$Enchantment
  ): boolean;
  clone(): org$bukkit$inventory$meta$EnchantmentStorageMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$EnchantmentStorageMeta
  implements $org$bukkit$inventory$meta$EnchantmentStorageMeta {
  hasStoredEnchants(): boolean;
  hasStoredEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getStoredEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getStoredEnchants(): any /* java.util.Map */;
  addStoredEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeStoredEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingStoredEnchant(
    arg0: org$bukkit$enchantments$Enchantment
  ): boolean;
  clone(): org$bukkit$inventory$meta$EnchantmentStorageMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$FireworkEffectMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  setEffect(arg0: org$bukkit$FireworkEffect): void;
  hasEffect(): boolean;
  getEffect(): org$bukkit$FireworkEffect;
  clone(): org$bukkit$inventory$meta$FireworkEffectMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$FireworkEffectMeta
  implements $org$bukkit$inventory$meta$FireworkEffectMeta {
  setEffect(arg0: org$bukkit$FireworkEffect): void;
  hasEffect(): boolean;
  getEffect(): org$bukkit$FireworkEffect;
  clone(): org$bukkit$inventory$meta$FireworkEffectMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$KnowledgeBookMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasRecipes(): boolean;
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  addRecipe(arg0: JavaArray<org$bukkit$NamespacedKey>): void;
  clone(): org$bukkit$inventory$meta$KnowledgeBookMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$KnowledgeBookMeta
  implements $org$bukkit$inventory$meta$KnowledgeBookMeta {
  hasRecipes(): boolean;
  getRecipes(): any /* java.util.List */;
  setRecipes(arg0: any /* java.util.List */): void;
  addRecipe(arg0: JavaArray<org$bukkit$NamespacedKey>): void;
  clone(): org$bukkit$inventory$meta$KnowledgeBookMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$LeatherArmorMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  clone(): org$bukkit$inventory$meta$LeatherArmorMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$LeatherArmorMeta
  implements $org$bukkit$inventory$meta$LeatherArmorMeta {
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  clone(): org$bukkit$inventory$meta$LeatherArmorMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$MapMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasMapId(): boolean;
  getMapId(): number;
  setMapId(arg0: number): void;
  hasMapView(): boolean;
  getMapView(): org$bukkit$map$MapView;
  setMapView(arg0: org$bukkit$map$MapView): void;
  isScaling(): boolean;
  setScaling(arg0: boolean): void;
  hasLocationName(): boolean;
  getLocationName(): string;
  setLocationName(arg0: string): void;
  hasColor(): boolean;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  clone(): org$bukkit$inventory$meta$MapMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$MapMeta
  implements $org$bukkit$inventory$meta$MapMeta {
  hasMapId(): boolean;
  getMapId(): number;
  setMapId(arg0: number): void;
  hasMapView(): boolean;
  getMapView(): org$bukkit$map$MapView;
  setMapView(arg0: org$bukkit$map$MapView): void;
  isScaling(): boolean;
  setScaling(arg0: boolean): void;
  hasLocationName(): boolean;
  getLocationName(): string;
  setLocationName(arg0: string): void;
  hasColor(): boolean;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  clone(): org$bukkit$inventory$meta$MapMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$PotionMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  setMainEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): boolean;
  hasColor(): boolean;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  clone(): org$bukkit$inventory$meta$PotionMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$PotionMeta
  implements $org$bukkit$inventory$meta$PotionMeta {
  setBasePotionData(arg0: org$bukkit$potion$PotionData): void;
  getBasePotionData(): org$bukkit$potion$PotionData;
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  setMainEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): boolean;
  hasColor(): boolean;
  getColor(): org$bukkit$Color;
  setColor(arg0: org$bukkit$Color): void;
  clone(): org$bukkit$inventory$meta$PotionMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$Repairable {
  hasRepairCost(): boolean;
  getRepairCost(): number;
  setRepairCost(arg0: number): void;
  clone(): org$bukkit$inventory$meta$Repairable;
}

declare class org$bukkit$inventory$meta$Repairable
  implements $org$bukkit$inventory$meta$Repairable {
  hasRepairCost(): boolean;
  getRepairCost(): number;
  setRepairCost(arg0: number): void;
  clone(): org$bukkit$inventory$meta$Repairable;
}


declare interface $org$bukkit$inventory$meta$SkullMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  getOwner(): string;
  hasOwner(): boolean;
  setOwner(arg0: string): boolean;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getOwningPlayer(): org$bukkit$OfflinePlayer;
  setOwningPlayer(arg0: org$bukkit$OfflinePlayer): boolean;
  clone(): org$bukkit$inventory$meta$SkullMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$SkullMeta
  implements $org$bukkit$inventory$meta$SkullMeta {
  getOwner(): string;
  hasOwner(): boolean;
  setOwner(arg0: string): boolean;
  setPlayerProfile(arg0: com$destroystokyo$paper$profile$PlayerProfile): void;
  getPlayerProfile(): com$destroystokyo$paper$profile$PlayerProfile;
  getOwningPlayer(): org$bukkit$OfflinePlayer;
  setOwningPlayer(arg0: org$bukkit$OfflinePlayer): boolean;
  clone(): org$bukkit$inventory$meta$SkullMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$SpawnEggMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  getSpawnedType(): org$bukkit$entity$EntityType;
  setSpawnedType(arg0: org$bukkit$entity$EntityType): void;
  clone(): org$bukkit$inventory$meta$SpawnEggMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$SpawnEggMeta
  implements $org$bukkit$inventory$meta$SpawnEggMeta {
  getSpawnedType(): org$bukkit$entity$EntityType;
  setSpawnedType(arg0: org$bukkit$entity$EntityType): void;
  clone(): org$bukkit$inventory$meta$SpawnEggMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$SuspiciousStewMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): boolean;
  clone(): org$bukkit$inventory$meta$SuspiciousStewMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$SuspiciousStewMeta
  implements $org$bukkit$inventory$meta$SuspiciousStewMeta {
  hasCustomEffects(): boolean;
  getCustomEffects(): any /* java.util.List */;
  addCustomEffect(arg0: org$bukkit$potion$PotionEffect, arg1: boolean): boolean;
  removeCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  hasCustomEffect(arg0: org$bukkit$potion$PotionEffectType): boolean;
  clearCustomEffects(): boolean;
  clone(): org$bukkit$inventory$meta$SuspiciousStewMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$meta$tags$ItemTagType$PrimitiveTagType
  extends $org$bukkit$inventory$meta$tags$ItemTagType {
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
}

declare class org$bukkit$inventory$meta$tags$ItemTagType$PrimitiveTagType
  implements $org$bukkit$inventory$meta$tags$ItemTagType$PrimitiveTagType {
  constructor(arg0: any /* java.lang.Class */);
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$inventory$meta$tags$ItemTagAdapterContext
  ): any;
  static BYTE: org$bukkit$inventory$meta$tags$ItemTagType;
  static SHORT: org$bukkit$inventory$meta$tags$ItemTagType;
  static INTEGER: org$bukkit$inventory$meta$tags$ItemTagType;
  static LONG: org$bukkit$inventory$meta$tags$ItemTagType;
  static FLOAT: org$bukkit$inventory$meta$tags$ItemTagType;
  static DOUBLE: org$bukkit$inventory$meta$tags$ItemTagType;
  static STRING: org$bukkit$inventory$meta$tags$ItemTagType;
  static BYTE_ARRAY: org$bukkit$inventory$meta$tags$ItemTagType;
  static INTEGER_ARRAY: org$bukkit$inventory$meta$tags$ItemTagType;
  static LONG_ARRAY: org$bukkit$inventory$meta$tags$ItemTagType;
  static TAG_CONTAINER: org$bukkit$inventory$meta$tags$ItemTagType;
}


declare interface $org$bukkit$inventory$meta$TropicalFishBucketMeta
  extends $org$bukkit$inventory$meta$ItemMeta {
  getPatternColor(): org$bukkit$DyeColor;
  setPatternColor(arg0: org$bukkit$DyeColor): void;
  getBodyColor(): org$bukkit$DyeColor;
  setBodyColor(arg0: org$bukkit$DyeColor): void;
  getPattern(): org$bukkit$entity$TropicalFish$Pattern;
  setPattern(arg0: org$bukkit$entity$TropicalFish$Pattern): void;
  hasVariant(): boolean;
  clone(): org$bukkit$inventory$meta$TropicalFishBucketMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
}

declare class org$bukkit$inventory$meta$TropicalFishBucketMeta
  implements $org$bukkit$inventory$meta$TropicalFishBucketMeta {
  getPatternColor(): org$bukkit$DyeColor;
  setPatternColor(arg0: org$bukkit$DyeColor): void;
  getBodyColor(): org$bukkit$DyeColor;
  setBodyColor(arg0: org$bukkit$DyeColor): void;
  getPattern(): org$bukkit$entity$TropicalFish$Pattern;
  setPattern(arg0: org$bukkit$entity$TropicalFish$Pattern): void;
  hasVariant(): boolean;
  clone(): org$bukkit$inventory$meta$TropicalFishBucketMeta;
  clone(): org$bukkit$inventory$meta$ItemMeta;
  serialize(): any /* java.util.Map */;
  hasDisplayName(): boolean;
  getDisplayName(): string;
  setDisplayName(arg0: string): void;
  hasLocalizedName(): boolean;
  getLocalizedName(): string;
  setLocalizedName(arg0: string): void;
  hasLore(): boolean;
  getLore(): any /* java.util.List */;
  setLore(arg0: any /* java.util.List */): void;
  hasCustomModelData(): boolean;
  getCustomModelData(): number;
  setCustomModelData(arg0: any /* java.lang.Integer */): void;
  hasEnchants(): boolean;
  hasEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  getEnchantLevel(arg0: org$bukkit$enchantments$Enchantment): number;
  getEnchants(): any /* java.util.Map */;
  addEnchant(
    arg0: org$bukkit$enchantments$Enchantment,
    arg1: number,
    arg2: boolean
  ): boolean;
  removeEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  hasConflictingEnchant(arg0: org$bukkit$enchantments$Enchantment): boolean;
  addItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  removeItemFlags(arg0: JavaArray<org$bukkit$inventory$ItemFlag>): void;
  getItemFlags(): any /* java.util.Set */;
  hasItemFlag(arg0: org$bukkit$inventory$ItemFlag): boolean;
  isUnbreakable(): boolean;
  setUnbreakable(arg0: boolean): void;
  hasAttributeModifiers(): boolean;
  getAttributeModifiers(): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$inventory$EquipmentSlot
  ): com$google$common$collect$Multimap;
  getAttributeModifiers(
    arg0: org$bukkit$attribute$Attribute
  ): java$util$Collection;
  addAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  setAttributeModifiers(arg0: com$google$common$collect$Multimap): void;
  removeAttributeModifier(arg0: org$bukkit$attribute$Attribute): boolean;
  removeAttributeModifier(arg0: org$bukkit$inventory$EquipmentSlot): boolean;
  removeAttributeModifier(
    arg0: org$bukkit$attribute$Attribute,
    arg1: org$bukkit$attribute$AttributeModifier
  ): boolean;
  getCustomTagContainer(): org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  setVersion(arg0: number): void;
  getCanDestroy(): any /* java.util.Set */;
  setCanDestroy(arg0: any /* java.util.Set */): void;
  getCanPlaceOn(): any /* java.util.Set */;
  setCanPlaceOn(arg0: any /* java.util.Set */): void;
  getDestroyableKeys(): any /* java.util.Set */;
  setDestroyableKeys(arg0: java$util$Collection): void;
  getPlaceableKeys(): any /* java.util.Set */;
  setPlaceableKeys(arg0: java$util$Collection): void;
  hasPlaceableKeys(): boolean;
  hasDestroyableKeys(): boolean;
  getPersistentDataContainer(): org$bukkit$persistence$PersistentDataContainer;
}


declare interface $org$bukkit$inventory$RecipeChoice$ExactChoice
  extends $org$bukkit$inventory$RecipeChoice {
  getItemStack(): org$bukkit$inventory$ItemStack;
  getChoices(): any /* java.util.List */;
  clone(): org$bukkit$inventory$RecipeChoice$ExactChoice;
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  clone(): any;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: any): boolean;
}

declare class org$bukkit$inventory$RecipeChoice$ExactChoice
  implements $org$bukkit$inventory$RecipeChoice$ExactChoice {
  constructor(arg0: org$bukkit$inventory$ItemStack);
  constructor(arg0: JavaArray<org$bukkit$inventory$ItemStack>);
  constructor(arg0: any /* java.util.List */);
  getItemStack(): org$bukkit$inventory$ItemStack;
  getChoices(): any /* java.util.List */;
  clone(): org$bukkit$inventory$RecipeChoice$ExactChoice;
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  clone(): any;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: any): boolean;
}


declare interface $org$bukkit$inventory$RecipeChoice$MaterialChoice
  extends $org$bukkit$inventory$RecipeChoice {
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getChoices(): any /* java.util.List */;
  clone(): org$bukkit$inventory$RecipeChoice$MaterialChoice;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  clone(): any;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: any): boolean;
}

declare class org$bukkit$inventory$RecipeChoice$MaterialChoice
  implements $org$bukkit$inventory$RecipeChoice$MaterialChoice {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: JavaArray<org$bukkit$Material>);
  constructor(arg0: org$bukkit$Tag);
  constructor(arg0: any /* java.util.List */);
  test(arg0: org$bukkit$inventory$ItemStack): boolean;
  getItemStack(): org$bukkit$inventory$ItemStack;
  getChoices(): any /* java.util.List */;
  clone(): org$bukkit$inventory$RecipeChoice$MaterialChoice;
  hashCode(): number;
  equals(arg0: any): boolean;
  toString(): string;
  clone(): any;
  clone(): org$bukkit$inventory$RecipeChoice;
  test(arg0: any): boolean;
}


declare interface $org$bukkit$inventory$ShapedRecipe
  extends $org$bukkit$inventory$Recipe,
    $org$bukkit$Keyed {
  shape(arg0: JavaArray<string>): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$Material,
    arg2: number
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapedRecipe;
  getIngredientMap(): any /* java.util.Map */;
  getChoiceMap(): any /* java.util.Map */;
  getShape(): JavaArray<string>;
  getResult(): org$bukkit$inventory$ItemStack;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}

declare class org$bukkit$inventory$ShapedRecipe
  implements $org$bukkit$inventory$ShapedRecipe {
  constructor(arg0: org$bukkit$inventory$ItemStack);
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack
  );
  shape(arg0: JavaArray<string>): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$Material,
    arg2: number
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$ShapedRecipe;
  setIngredient(
    arg0: string,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapedRecipe;
  getIngredientMap(): any /* java.util.Map */;
  getChoiceMap(): any /* java.util.Map */;
  getShape(): JavaArray<string>;
  getResult(): org$bukkit$inventory$ItemStack;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}


declare interface $org$bukkit$inventory$ShapelessRecipe
  extends $org$bukkit$inventory$Recipe,
    $org$bukkit$Keyed {
  addIngredient(
    arg0: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$Material,
    arg1: number
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$Material,
    arg2: number
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$Material,
    arg1: number
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$Material,
    arg2: number
  ): org$bukkit$inventory$ShapelessRecipe;
  getResult(): org$bukkit$inventory$ItemStack;
  getIngredientList(): any /* java.util.List */;
  getChoiceList(): any /* java.util.List */;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}

declare class org$bukkit$inventory$ShapelessRecipe
  implements $org$bukkit$inventory$ShapelessRecipe {
  constructor(arg0: org$bukkit$inventory$ItemStack);
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack
  );
  addIngredient(
    arg0: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$Material,
    arg1: number
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$Material,
    arg2: number
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  addIngredient(
    arg0: number,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$inventory$ItemStack
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$Material
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$material$MaterialData
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: org$bukkit$Material,
    arg1: number
  ): org$bukkit$inventory$ShapelessRecipe;
  removeIngredient(
    arg0: number,
    arg1: org$bukkit$Material,
    arg2: number
  ): org$bukkit$inventory$ShapelessRecipe;
  getResult(): org$bukkit$inventory$ItemStack;
  getIngredientList(): any /* java.util.List */;
  getChoiceList(): any /* java.util.List */;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}


declare interface $org$bukkit$inventory$SmokingRecipe {}

declare class org$bukkit$inventory$SmokingRecipe
  implements $org$bukkit$inventory$SmokingRecipe {
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material,
    arg3: number,
    arg4: number
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$RecipeChoice,
    arg3: number,
    arg4: number
  );
  getKey(): org$bukkit$NamespacedKey;
  getResult(): org$bukkit$inventory$ItemStack;
}


declare interface $org$bukkit$inventory$StonecutterInventory
  extends $org$bukkit$inventory$Inventory {
  getInputItem(): org$bukkit$inventory$ItemStack;
  setInputItem(arg0: org$bukkit$inventory$ItemStack): void;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
}

declare class org$bukkit$inventory$StonecutterInventory
  implements $org$bukkit$inventory$StonecutterInventory {
  getInputItem(): org$bukkit$inventory$ItemStack;
  setInputItem(arg0: org$bukkit$inventory$ItemStack): void;
  getResult(): org$bukkit$inventory$ItemStack;
  setResult(arg0: org$bukkit$inventory$ItemStack): void;
  getSize(): number;
  getMaxStackSize(): number;
  setMaxStackSize(arg0: number): void;
  getItem(arg0: number): org$bukkit$inventory$ItemStack;
  setItem(arg0: number, arg1: org$bukkit$inventory$ItemStack): void;
  addItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItem(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  removeItemAnySlot(
    arg0: JavaArray<org$bukkit$inventory$ItemStack>
  ): any /* java.util.HashMap */;
  getContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  getStorageContents(): JavaArray<org$bukkit$inventory$ItemStack>;
  setStorageContents(arg0: JavaArray<org$bukkit$inventory$ItemStack>): void;
  contains(arg0: org$bukkit$Material): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack): boolean;
  contains(arg0: org$bukkit$Material, arg1: number): boolean;
  contains(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  containsAtLeast(arg0: org$bukkit$inventory$ItemStack, arg1: number): boolean;
  all(arg0: org$bukkit$Material): any /* java.util.HashMap */;
  all(arg0: org$bukkit$inventory$ItemStack): any /* java.util.HashMap */;
  first(arg0: org$bukkit$Material): number;
  first(arg0: org$bukkit$inventory$ItemStack): number;
  firstEmpty(): number;
  remove(arg0: org$bukkit$Material): void;
  remove(arg0: org$bukkit$inventory$ItemStack): void;
  clear(arg0: number): void;
  clear(): void;
  getViewers(): any /* java.util.List */;
  getType(): org$bukkit$event$inventory$InventoryType;
  getHolder(): org$bukkit$inventory$InventoryHolder;
  getHolder(arg0: boolean): org$bukkit$inventory$InventoryHolder;
  iterator(): any /* java.util.ListIterator */;
  iterator(arg0: number): any /* java.util.ListIterator */;
  getLocation(): org$bukkit$Location;
  iterator(): any /* java.util.Iterator */;
}


declare interface $org$bukkit$inventory$StonecuttingRecipe
  extends $org$bukkit$inventory$Recipe,
    $org$bukkit$Keyed {
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$StonecuttingRecipe;
  getInput(): org$bukkit$inventory$ItemStack;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$StonecuttingRecipe;
  getInputChoice(): org$bukkit$inventory$RecipeChoice;
  getResult(): org$bukkit$inventory$ItemStack;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}

declare class org$bukkit$inventory$StonecuttingRecipe
  implements $org$bukkit$inventory$StonecuttingRecipe {
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$Material
  );
  constructor(
    arg0: org$bukkit$NamespacedKey,
    arg1: org$bukkit$inventory$ItemStack,
    arg2: org$bukkit$inventory$RecipeChoice
  );
  setInput(arg0: org$bukkit$Material): org$bukkit$inventory$StonecuttingRecipe;
  getInput(): org$bukkit$inventory$ItemStack;
  setInputChoice(
    arg0: org$bukkit$inventory$RecipeChoice
  ): org$bukkit$inventory$StonecuttingRecipe;
  getInputChoice(): org$bukkit$inventory$RecipeChoice;
  getResult(): org$bukkit$inventory$ItemStack;
  getKey(): org$bukkit$NamespacedKey;
  getGroup(): string;
  setGroup(arg0: string): void;
}


declare interface $org$bukkit$loot$LootContext$Builder {
  luck(arg0: number): org$bukkit$loot$LootContext$Builder;
  lootingModifier(arg0: number): org$bukkit$loot$LootContext$Builder;
  lootedEntity(
    arg0: org$bukkit$entity$Entity
  ): org$bukkit$loot$LootContext$Builder;
  killer(
    arg0: org$bukkit$entity$HumanEntity
  ): org$bukkit$loot$LootContext$Builder;
  build(): org$bukkit$loot$LootContext;
}

declare class org$bukkit$loot$LootContext$Builder
  implements $org$bukkit$loot$LootContext$Builder {
  constructor(arg0: org$bukkit$Location);
  luck(arg0: number): org$bukkit$loot$LootContext$Builder;
  lootingModifier(arg0: number): org$bukkit$loot$LootContext$Builder;
  lootedEntity(
    arg0: org$bukkit$entity$Entity
  ): org$bukkit$loot$LootContext$Builder;
  killer(
    arg0: org$bukkit$entity$HumanEntity
  ): org$bukkit$loot$LootContext$Builder;
  build(): org$bukkit$loot$LootContext;
}


declare interface $org$bukkit$loot$LootTables extends $org$bukkit$Keyed {
  getKey(): org$bukkit$NamespacedKey;
  getLootTable(): org$bukkit$loot$LootTable;
}

declare class org$bukkit$loot$LootTables
  implements $org$bukkit$loot$LootTables {
  static EMPTY: org$bukkit$loot$LootTables;
  static ABANDONED_MINESHAFT: org$bukkit$loot$LootTables;
  static BURIED_TREASURE: org$bukkit$loot$LootTables;
  static DESERT_PYRAMID: org$bukkit$loot$LootTables;
  static END_CITY_TREASURE: org$bukkit$loot$LootTables;
  static IGLOO_CHEST: org$bukkit$loot$LootTables;
  static JUNGLE_TEMPLE: org$bukkit$loot$LootTables;
  static JUNGLE_TEMPLE_DISPENSER: org$bukkit$loot$LootTables;
  static NETHER_BRIDGE: org$bukkit$loot$LootTables;
  static PILLAGER_OUTPOST: org$bukkit$loot$LootTables;
  static SHIPWRECK_MAP: org$bukkit$loot$LootTables;
  static SHIPWRECK_SUPPLY: org$bukkit$loot$LootTables;
  static SHIPWRECK_TREASURE: org$bukkit$loot$LootTables;
  static SIMPLE_DUNGEON: org$bukkit$loot$LootTables;
  static SPAWN_BONUS_CHEST: org$bukkit$loot$LootTables;
  static STRONGHOLD_CORRIDOR: org$bukkit$loot$LootTables;
  static STRONGHOLD_CROSSING: org$bukkit$loot$LootTables;
  static STRONGHOLD_LIBRARY: org$bukkit$loot$LootTables;
  static UNDERWATER_RUIN_BIG: org$bukkit$loot$LootTables;
  static UNDERWATER_RUIN_SMALL: org$bukkit$loot$LootTables;
  static VILLAGE_ARMORER: org$bukkit$loot$LootTables;
  static VILLAGE_BUTCHER: org$bukkit$loot$LootTables;
  static VILLAGE_CARTOGRAPHER: org$bukkit$loot$LootTables;
  static VILLAGE_DESERT_HOUSE: org$bukkit$loot$LootTables;
  static VILLAGE_FISHER: org$bukkit$loot$LootTables;
  static VILLAGE_FLETCHER: org$bukkit$loot$LootTables;
  static VILLAGE_MASON: org$bukkit$loot$LootTables;
  static VILLAGE_PLAINS_HOUSE: org$bukkit$loot$LootTables;
  static VILLAGE_SAVANNA_HOUSE: org$bukkit$loot$LootTables;
  static VILLAGE_SHEPHERD: org$bukkit$loot$LootTables;
  static VILLAGE_SNOWY_HOUSE: org$bukkit$loot$LootTables;
  static VILLAGE_TAIGA_HOUSE: org$bukkit$loot$LootTables;
  static VILLAGE_TANNERY: org$bukkit$loot$LootTables;
  static VILLAGE_TEMPLE: org$bukkit$loot$LootTables;
  static VILLAGE_TOOLSMITH: org$bukkit$loot$LootTables;
  static VILLAGE_WEAPONSMITH: org$bukkit$loot$LootTables;
  static WOODLAND_MANSION: org$bukkit$loot$LootTables;
  static ARMOR_STAND: org$bukkit$loot$LootTables;
  static BAT: org$bukkit$loot$LootTables;
  static BLAZE: org$bukkit$loot$LootTables;
  static CAT: org$bukkit$loot$LootTables;
  static CAVE_SPIDER: org$bukkit$loot$LootTables;
  static CHICKEN: org$bukkit$loot$LootTables;
  static COD: org$bukkit$loot$LootTables;
  static COW: org$bukkit$loot$LootTables;
  static CREEPER: org$bukkit$loot$LootTables;
  static DOLPHIN: org$bukkit$loot$LootTables;
  static DONKEY: org$bukkit$loot$LootTables;
  static DROWNED: org$bukkit$loot$LootTables;
  static ELDER_GUARDIAN: org$bukkit$loot$LootTables;
  static ENDERMAN: org$bukkit$loot$LootTables;
  static ENDERMITE: org$bukkit$loot$LootTables;
  static ENDER_DRAGON: org$bukkit$loot$LootTables;
  static EVOKER: org$bukkit$loot$LootTables;
  static FOX: org$bukkit$loot$LootTables;
  static GHAST: org$bukkit$loot$LootTables;
  static GIANT: org$bukkit$loot$LootTables;
  static GUARDIAN: org$bukkit$loot$LootTables;
  static HORSE: org$bukkit$loot$LootTables;
  static HUSK: org$bukkit$loot$LootTables;
  static ILLUSIONER: org$bukkit$loot$LootTables;
  static IRON_GOLEM: org$bukkit$loot$LootTables;
  static LLAMA: org$bukkit$loot$LootTables;
  static MAGMA_CUBE: org$bukkit$loot$LootTables;
  static MOOSHROOM: org$bukkit$loot$LootTables;
  static MULE: org$bukkit$loot$LootTables;
  static OCELOT: org$bukkit$loot$LootTables;
  static PANDA: org$bukkit$loot$LootTables;
  static PARROT: org$bukkit$loot$LootTables;
  static PHANTOM: org$bukkit$loot$LootTables;
  static PIG: org$bukkit$loot$LootTables;
  static PILLAGER: org$bukkit$loot$LootTables;
  static POLAR_BEAR: org$bukkit$loot$LootTables;
  static PUFFERFISH: org$bukkit$loot$LootTables;
  static RABBIT: org$bukkit$loot$LootTables;
  static RAVAGER: org$bukkit$loot$LootTables;
  static SALMON: org$bukkit$loot$LootTables;
  static SHULKER: org$bukkit$loot$LootTables;
  static SILVERFISH: org$bukkit$loot$LootTables;
  static SKELETON: org$bukkit$loot$LootTables;
  static SKELETON_HORSE: org$bukkit$loot$LootTables;
  static SLIME: org$bukkit$loot$LootTables;
  static SNOW_GOLEM: org$bukkit$loot$LootTables;
  static SPIDER: org$bukkit$loot$LootTables;
  static SQUID: org$bukkit$loot$LootTables;
  static STRAY: org$bukkit$loot$LootTables;
  static TRADER_LLAMA: org$bukkit$loot$LootTables;
  static TROPICAL_FISH: org$bukkit$loot$LootTables;
  static TURTLE: org$bukkit$loot$LootTables;
  static VEX: org$bukkit$loot$LootTables;
  static VILLAGER: org$bukkit$loot$LootTables;
  static VINDICATOR: org$bukkit$loot$LootTables;
  static WANDERING_TRADER: org$bukkit$loot$LootTables;
  static WITCH: org$bukkit$loot$LootTables;
  static WITHER: org$bukkit$loot$LootTables;
  static WITHER_SKELETON: org$bukkit$loot$LootTables;
  static WOLF: org$bukkit$loot$LootTables;
  static ZOMBIE: org$bukkit$loot$LootTables;
  static ZOMBIE_HORSE: org$bukkit$loot$LootTables;
  static ZOMBIE_PIGMAN: org$bukkit$loot$LootTables;
  static ZOMBIE_VILLAGER: org$bukkit$loot$LootTables;
  static ARMORER_GIFT: org$bukkit$loot$LootTables;
  static BUTCHER_GIFT: org$bukkit$loot$LootTables;
  static CARTOGRAPHER_GIFT: org$bukkit$loot$LootTables;
  static CAT_MORNING_GIFT: org$bukkit$loot$LootTables;
  static CLERIC_GIFT: org$bukkit$loot$LootTables;
  static FARMER_GIFT: org$bukkit$loot$LootTables;
  static FISHERMAN_GIFT: org$bukkit$loot$LootTables;
  static FISHING: org$bukkit$loot$LootTables;
  static FISHING_FISH: org$bukkit$loot$LootTables;
  static FISHING_JUNK: org$bukkit$loot$LootTables;
  static FISHING_TREASURE: org$bukkit$loot$LootTables;
  static FLETCHER_GIFT: org$bukkit$loot$LootTables;
  static LEATHERWORKER_GIFT: org$bukkit$loot$LootTables;
  static LIBRARIAN_GIFT: org$bukkit$loot$LootTables;
  static MASON_GIFT: org$bukkit$loot$LootTables;
  static SHEPHERD_GIFT: org$bukkit$loot$LootTables;
  static TOOLSMITH_GIFT: org$bukkit$loot$LootTables;
  static WEAPONSMITH_GIFT: org$bukkit$loot$LootTables;
  static SHEEP: org$bukkit$loot$LootTables;
  static SHEEP_BLACK: org$bukkit$loot$LootTables;
  static SHEEP_BLUE: org$bukkit$loot$LootTables;
  static SHEEP_BROWN: org$bukkit$loot$LootTables;
  static SHEEP_CYAN: org$bukkit$loot$LootTables;
  static SHEEP_GRAY: org$bukkit$loot$LootTables;
  static SHEEP_GREEN: org$bukkit$loot$LootTables;
  static SHEEP_LIGHT_BLUE: org$bukkit$loot$LootTables;
  static SHEEP_LIGHT_GRAY: org$bukkit$loot$LootTables;
  static SHEEP_LIME: org$bukkit$loot$LootTables;
  static SHEEP_MAGENTA: org$bukkit$loot$LootTables;
  static SHEEP_ORANGE: org$bukkit$loot$LootTables;
  static SHEEP_PINK: org$bukkit$loot$LootTables;
  static SHEEP_PURPLE: org$bukkit$loot$LootTables;
  static SHEEP_RED: org$bukkit$loot$LootTables;
  static SHEEP_WHITE: org$bukkit$loot$LootTables;
  static SHEEP_YELLOW: org$bukkit$loot$LootTables;
  static values(): JavaArray<org$bukkit$loot$LootTables>;
  static valueOf(arg0: string): org$bukkit$loot$LootTables;
  getKey(): org$bukkit$NamespacedKey;
  getLootTable(): org$bukkit$loot$LootTable;
}


declare interface $org$bukkit$map$MapPalette {}

declare class org$bukkit$map$MapPalette implements $org$bukkit$map$MapPalette {
  static TRANSPARENT: Buffer;
  static LIGHT_GREEN: Buffer;
  static LIGHT_BROWN: Buffer;
  static GRAY_1: Buffer;
  static RED: Buffer;
  static PALE_BLUE: Buffer;
  static GRAY_2: Buffer;
  static DARK_GREEN: Buffer;
  static WHITE: Buffer;
  static LIGHT_GRAY: Buffer;
  static BROWN: Buffer;
  static DARK_GRAY: Buffer;
  static BLUE: Buffer;
  static DARK_BROWN: Buffer;
  static resizeImage(
    arg0: any /* java.awt.Image */
  ): any /* java.awt.image.BufferedImage */;
  static imageToBytes(arg0: any /* java.awt.Image */): JavaArray<Buffer>;
  static matchColor(arg0: number, arg1: number, arg2: number): Buffer;
  static matchColor(arg0: any /* java.awt.Color */): Buffer;
  static getColor(arg0: Buffer): any /* java.awt.Color */;
}


declare interface $org$bukkit$map$MinecraftFont {}

declare class org$bukkit$map$MinecraftFont
  implements $org$bukkit$map$MinecraftFont {
  static Font: org$bukkit$map$MinecraftFont;
  constructor();
}


declare interface $org$bukkit$material$Banner
  extends $org$bukkit$material$Attachable {
  isWallBanner(): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  getFacing(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Banner;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Banner
  implements $org$bukkit$material$Banner {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isWallBanner(): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  getFacing(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Banner;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Banner$1 {}

declare class org$bukkit$material$Banner$1
  implements $org$bukkit$material$Banner$1 {}


declare interface $org$bukkit$material$Bed
  extends $org$bukkit$material$Directional {
  isHeadOfBed(): boolean;
  setHeadOfBed(arg0: boolean): void;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Bed;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Bed implements $org$bukkit$material$Bed {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isHeadOfBed(): boolean;
  setHeadOfBed(arg0: boolean): void;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Bed;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Bed$1 {}

declare class org$bukkit$material$Bed$1 implements $org$bukkit$material$Bed$1 {}


declare interface $org$bukkit$material$Button
  extends $org$bukkit$material$Redstone {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Button;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Button
  implements $org$bukkit$material$Button {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Button;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Redstone {
  isPowered(): boolean;
}

declare class org$bukkit$material$Redstone
  implements $org$bukkit$material$Redstone {
  isPowered(): boolean;
}


declare interface $org$bukkit$material$SimpleAttachableMaterialData
  extends $org$bukkit$material$Attachable {
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$SimpleAttachableMaterialData
  implements $org$bukkit$material$SimpleAttachableMaterialData {
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
}


declare interface $org$bukkit$material$Button$1 {}

declare class org$bukkit$material$Button$1
  implements $org$bukkit$material$Button$1 {}


declare interface $org$bukkit$material$Cake {
  getSlicesEaten(): number;
  getSlicesRemaining(): number;
  setSlicesEaten(arg0: number): void;
  setSlicesRemaining(arg0: number): void;
  toString(): string;
  clone(): org$bukkit$material$Cake;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Cake implements $org$bukkit$material$Cake {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getSlicesEaten(): number;
  getSlicesRemaining(): number;
  setSlicesEaten(arg0: number): void;
  setSlicesRemaining(arg0: number): void;
  toString(): string;
  clone(): org$bukkit$material$Cake;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Cauldron {
  isFull(): boolean;
  isEmpty(): boolean;
  toString(): string;
  clone(): org$bukkit$material$Cauldron;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Cauldron
  implements $org$bukkit$material$Cauldron {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: Buffer);
  isFull(): boolean;
  isEmpty(): boolean;
  toString(): string;
  clone(): org$bukkit$material$Cauldron;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Chest {
  clone(): org$bukkit$material$Chest;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Chest implements $org$bukkit$material$Chest {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  clone(): org$bukkit$material$Chest;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$DirectionalContainer
  extends $org$bukkit$material$Directional {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$DirectionalContainer
  implements $org$bukkit$material$DirectionalContainer {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Coal {
  getType(): org$bukkit$CoalType;
  setType(arg0: org$bukkit$CoalType): void;
  toString(): string;
  clone(): org$bukkit$material$Coal;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Coal implements $org$bukkit$material$Coal {
  constructor();
  constructor(arg0: org$bukkit$CoalType);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getType(): org$bukkit$CoalType;
  setType(arg0: org$bukkit$CoalType): void;
  toString(): string;
  clone(): org$bukkit$material$Coal;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$CocoaPlant
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Attachable {
  getSize(): org$bukkit$material$CocoaPlant$CocoaPlantSize;
  setSize(arg0: org$bukkit$material$CocoaPlant$CocoaPlantSize): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  clone(): org$bukkit$material$CocoaPlant;
  toString(): string;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$CocoaPlant
  implements $org$bukkit$material$CocoaPlant {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: org$bukkit$material$CocoaPlant$CocoaPlantSize);
  constructor(
    arg0: org$bukkit$material$CocoaPlant$CocoaPlantSize,
    arg1: org$bukkit$block$BlockFace
  );
  getSize(): org$bukkit$material$CocoaPlant$CocoaPlantSize;
  setSize(arg0: org$bukkit$material$CocoaPlant$CocoaPlantSize): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  clone(): org$bukkit$material$CocoaPlant;
  toString(): string;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$CocoaPlant$CocoaPlantSize {}

declare class org$bukkit$material$CocoaPlant$CocoaPlantSize
  implements $org$bukkit$material$CocoaPlant$CocoaPlantSize {
  static SMALL: org$bukkit$material$CocoaPlant$CocoaPlantSize;
  static MEDIUM: org$bukkit$material$CocoaPlant$CocoaPlantSize;
  static LARGE: org$bukkit$material$CocoaPlant$CocoaPlantSize;
  static values(): JavaArray<org$bukkit$material$CocoaPlant$CocoaPlantSize>;
  static valueOf(arg0: string): org$bukkit$material$CocoaPlant$CocoaPlantSize;
}


declare interface $org$bukkit$material$CocoaPlant$1 {}

declare class org$bukkit$material$CocoaPlant$1
  implements $org$bukkit$material$CocoaPlant$1 {}


declare interface $org$bukkit$material$Command
  extends $org$bukkit$material$Redstone {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Command;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Command
  implements $org$bukkit$material$Command {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Command;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Comparator
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Redstone {
  setSubtractionMode(arg0: boolean): void;
  isSubtractionMode(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Comparator;
  isPowered(): boolean;
  isBeingPowered(): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Comparator
  implements $org$bukkit$material$Comparator {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$block$BlockFace, arg1: boolean);
  constructor(arg0: org$bukkit$block$BlockFace, arg1: boolean, arg2: boolean);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setSubtractionMode(arg0: boolean): void;
  isSubtractionMode(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Comparator;
  isPowered(): boolean;
  isBeingPowered(): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Comparator$1 {}

declare class org$bukkit$material$Comparator$1
  implements $org$bukkit$material$Comparator$1 {}


declare interface $org$bukkit$material$Crops {
  getState(): org$bukkit$CropState;
  setState(arg0: org$bukkit$CropState): void;
  toString(): string;
  clone(): org$bukkit$material$Crops;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Crops implements $org$bukkit$material$Crops {
  constructor();
  constructor(arg0: org$bukkit$CropState);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$CropState);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getState(): org$bukkit$CropState;
  setState(arg0: org$bukkit$CropState): void;
  toString(): string;
  clone(): org$bukkit$material$Crops;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Crops$1 {}

declare class org$bukkit$material$Crops$1
  implements $org$bukkit$material$Crops$1 {}


declare interface $org$bukkit$material$DetectorRail
  extends $org$bukkit$material$PressureSensor {
  isPressed(): boolean;
  setPressed(arg0: boolean): void;
  clone(): org$bukkit$material$DetectorRail;
  clone(): org$bukkit$material$ExtendedRails;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$DetectorRail
  implements $org$bukkit$material$DetectorRail {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPressed(): boolean;
  setPressed(arg0: boolean): void;
  clone(): org$bukkit$material$DetectorRail;
  clone(): org$bukkit$material$ExtendedRails;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$PressureSensor {
  isPressed(): boolean;
}

declare class org$bukkit$material$PressureSensor
  implements $org$bukkit$material$PressureSensor {
  isPressed(): boolean;
}


declare interface $org$bukkit$material$ExtendedRails {
  isCurve(): boolean;
  getConvertedData(): Buffer;
  setDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  clone(): org$bukkit$material$ExtendedRails;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$ExtendedRails
  implements $org$bukkit$material$ExtendedRails {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isCurve(): boolean;
  getConvertedData(): Buffer;
  setDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  clone(): org$bukkit$material$ExtendedRails;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Rails {
  isOnSlope(): boolean;
  isCurve(): boolean;
  getDirection(): org$bukkit$block$BlockFace;
  toString(): string;
  getConvertedData(): Buffer;
  setDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Rails implements $org$bukkit$material$Rails {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isOnSlope(): boolean;
  isCurve(): boolean;
  getDirection(): org$bukkit$block$BlockFace;
  toString(): string;
  getConvertedData(): Buffer;
  setDirection(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Diode
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Redstone {
  setDelay(arg0: number): void;
  getDelay(): number;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Diode;
  isPowered(): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Diode implements $org$bukkit$material$Diode {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$block$BlockFace, arg1: number);
  constructor(arg0: org$bukkit$block$BlockFace, arg1: number, arg2: boolean);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setDelay(arg0: number): void;
  getDelay(): number;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Diode;
  isPowered(): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Diode$1 {}

declare class org$bukkit$material$Diode$1
  implements $org$bukkit$material$Diode$1 {}


declare interface $org$bukkit$material$DirectionalContainer$1 {}

declare class org$bukkit$material$DirectionalContainer$1
  implements $org$bukkit$material$DirectionalContainer$1 {}


declare interface $org$bukkit$material$Dispenser {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  clone(): org$bukkit$material$Dispenser;
  clone(): org$bukkit$material$FurnaceAndDispenser;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Dispenser
  implements $org$bukkit$material$Dispenser {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  clone(): org$bukkit$material$Dispenser;
  clone(): org$bukkit$material$FurnaceAndDispenser;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$FurnaceAndDispenser {
  clone(): org$bukkit$material$FurnaceAndDispenser;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$FurnaceAndDispenser
  implements $org$bukkit$material$FurnaceAndDispenser {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  clone(): org$bukkit$material$FurnaceAndDispenser;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Dispenser$1 {}

declare class org$bukkit$material$Dispenser$1
  implements $org$bukkit$material$Dispenser$1 {}


declare interface $org$bukkit$material$Door
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Openable {
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isTopHalf(): boolean;
  setTopHalf(arg0: boolean): void;
  getHingeCorner(): org$bukkit$block$BlockFace;
  toString(): string;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  getHinge(): boolean;
  setHinge(arg0: boolean): void;
  clone(): org$bukkit$material$Door;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Door implements $org$bukkit$material$Door {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$block$BlockFace);
  constructor(
    arg0: org$bukkit$Material,
    arg1: org$bukkit$block$BlockFace,
    arg2: boolean
  );
  constructor(arg0: org$bukkit$Material, arg1: boolean);
  constructor(arg0: org$bukkit$TreeSpecies, arg1: org$bukkit$block$BlockFace);
  constructor(
    arg0: org$bukkit$TreeSpecies,
    arg1: org$bukkit$block$BlockFace,
    arg2: boolean
  );
  constructor(arg0: org$bukkit$TreeSpecies, arg1: boolean);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  static getWoodDoorOfSpecies(
    arg0: org$bukkit$TreeSpecies
  ): org$bukkit$Material;
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isTopHalf(): boolean;
  setTopHalf(arg0: boolean): void;
  getHingeCorner(): org$bukkit$block$BlockFace;
  toString(): string;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  getHinge(): boolean;
  setHinge(arg0: boolean): void;
  clone(): org$bukkit$material$Door;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Openable {
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
}

declare class org$bukkit$material$Openable
  implements $org$bukkit$material$Openable {
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
}


declare interface $org$bukkit$material$Door$1 {}

declare class org$bukkit$material$Door$1
  implements $org$bukkit$material$Door$1 {}


declare interface $org$bukkit$material$Dye
  extends $org$bukkit$material$Colorable {
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  toString(): string;
  clone(): org$bukkit$material$Dye;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Dye implements $org$bukkit$material$Dye {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: org$bukkit$DyeColor);
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  toString(): string;
  clone(): org$bukkit$material$Dye;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$EnderChest {
  clone(): org$bukkit$material$EnderChest;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$EnderChest
  implements $org$bukkit$material$EnderChest {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  clone(): org$bukkit$material$EnderChest;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$FlowerPot {
  getContents(): org$bukkit$material$MaterialData;
  setContents(arg0: org$bukkit$material$MaterialData): void;
  toString(): string;
  clone(): org$bukkit$material$FlowerPot;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$FlowerPot
  implements $org$bukkit$material$FlowerPot {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getContents(): org$bukkit$material$MaterialData;
  setContents(arg0: org$bukkit$material$MaterialData): void;
  toString(): string;
  clone(): org$bukkit$material$FlowerPot;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Furnace {
  clone(): org$bukkit$material$Furnace;
  clone(): org$bukkit$material$FurnaceAndDispenser;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Furnace
  implements $org$bukkit$material$Furnace {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  clone(): org$bukkit$material$Furnace;
  clone(): org$bukkit$material$FurnaceAndDispenser;
  clone(): org$bukkit$material$DirectionalContainer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Gate
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Openable {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Gate;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Gate implements $org$bukkit$material$Gate {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: Buffer);
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Gate;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Gate$1 {}

declare class org$bukkit$material$Gate$1
  implements $org$bukkit$material$Gate$1 {}


declare interface $org$bukkit$material$Hopper
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Redstone {
  setActive(arg0: boolean): void;
  isActive(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Hopper;
  isPowered(): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Hopper
  implements $org$bukkit$material$Hopper {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$block$BlockFace, arg1: boolean);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setActive(arg0: boolean): void;
  isActive(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Hopper;
  isPowered(): boolean;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Hopper$1 {}

declare class org$bukkit$material$Hopper$1
  implements $org$bukkit$material$Hopper$1 {}


declare interface $org$bukkit$material$Ladder {
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  clone(): org$bukkit$material$Ladder;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Ladder
  implements $org$bukkit$material$Ladder {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  clone(): org$bukkit$material$Ladder;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Ladder$1 {}

declare class org$bukkit$material$Ladder$1
  implements $org$bukkit$material$Ladder$1 {}


declare interface $org$bukkit$material$Leaves {
  isDecaying(): boolean;
  setDecaying(arg0: boolean): void;
  isDecayable(): boolean;
  setDecayable(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Leaves;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Leaves
  implements $org$bukkit$material$Leaves {
  constructor();
  constructor(arg0: org$bukkit$TreeSpecies);
  constructor(arg0: org$bukkit$TreeSpecies, arg1: boolean);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$TreeSpecies);
  constructor(
    arg0: org$bukkit$Material,
    arg1: org$bukkit$TreeSpecies,
    arg2: boolean
  );
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isDecaying(): boolean;
  setDecaying(arg0: boolean): void;
  isDecayable(): boolean;
  setDecayable(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Leaves;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Wood {
  getSpecies(): org$bukkit$TreeSpecies;
  setSpecies(arg0: org$bukkit$TreeSpecies): void;
  toString(): string;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Wood implements $org$bukkit$material$Wood {
  constructor();
  constructor(arg0: org$bukkit$TreeSpecies);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$TreeSpecies);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getSpecies(): org$bukkit$TreeSpecies;
  setSpecies(arg0: org$bukkit$TreeSpecies): void;
  toString(): string;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Lever
  extends $org$bukkit$material$Redstone {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Lever;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Lever implements $org$bukkit$material$Lever {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Lever;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Lever$1 {}

declare class org$bukkit$material$Lever$1
  implements $org$bukkit$material$Lever$1 {}


declare interface $org$bukkit$material$LongGrass {
  getSpecies(): org$bukkit$GrassSpecies;
  setSpecies(arg0: org$bukkit$GrassSpecies): void;
  toString(): string;
  clone(): org$bukkit$material$LongGrass;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$LongGrass
  implements $org$bukkit$material$LongGrass {
  constructor();
  constructor(arg0: org$bukkit$GrassSpecies);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getSpecies(): org$bukkit$GrassSpecies;
  setSpecies(arg0: org$bukkit$GrassSpecies): void;
  toString(): string;
  clone(): org$bukkit$material$LongGrass;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$MonsterEggs {
  getTextures(): any /* java.util.List */;
  clone(): org$bukkit$material$MonsterEggs;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$MonsterEggs
  implements $org$bukkit$material$MonsterEggs {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getTextures(): any /* java.util.List */;
  clone(): org$bukkit$material$MonsterEggs;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$TexturedMaterial {
  getTextures(): any /* java.util.List */;
  getMaterial(): org$bukkit$Material;
  setMaterial(arg0: org$bukkit$Material): void;
  getTextureIndex(): number;
  setTextureIndex(arg0: number): void;
  toString(): string;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$TexturedMaterial
  implements $org$bukkit$material$TexturedMaterial {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getTextures(): any /* java.util.List */;
  getMaterial(): org$bukkit$Material;
  setMaterial(arg0: org$bukkit$Material): void;
  getTextureIndex(): number;
  setTextureIndex(arg0: number): void;
  toString(): string;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Mushroom {
  isStem(): boolean;
  setStem(): void;
  getBlockTexture(): org$bukkit$material$types$MushroomBlockTexture;
  setBlockTexture(arg0: org$bukkit$material$types$MushroomBlockTexture): void;
  isFacePainted(arg0: org$bukkit$block$BlockFace): boolean;
  setFacePainted(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getPaintedFaces(): any /* java.util.Set */;
  toString(): string;
  clone(): org$bukkit$material$Mushroom;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Mushroom
  implements $org$bukkit$material$Mushroom {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$block$BlockFace);
  constructor(
    arg0: org$bukkit$Material,
    arg1: org$bukkit$material$types$MushroomBlockTexture
  );
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isStem(): boolean;
  setStem(): void;
  getBlockTexture(): org$bukkit$material$types$MushroomBlockTexture;
  setBlockTexture(arg0: org$bukkit$material$types$MushroomBlockTexture): void;
  isFacePainted(arg0: org$bukkit$block$BlockFace): boolean;
  setFacePainted(arg0: org$bukkit$block$BlockFace, arg1: boolean): void;
  getPaintedFaces(): any /* java.util.Set */;
  toString(): string;
  clone(): org$bukkit$material$Mushroom;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$types$MushroomBlockTexture {
  getData(): Buffer;
  getCapFace(): org$bukkit$block$BlockFace;
}

declare class org$bukkit$material$types$MushroomBlockTexture
  implements $org$bukkit$material$types$MushroomBlockTexture {
  static ALL_PORES: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_NORTH_WEST: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_NORTH: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_NORTH_EAST: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_WEST: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_TOP: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_EAST: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_SOUTH_WEST: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_SOUTH: org$bukkit$material$types$MushroomBlockTexture;
  static CAP_SOUTH_EAST: org$bukkit$material$types$MushroomBlockTexture;
  static STEM_SIDES: org$bukkit$material$types$MushroomBlockTexture;
  static ALL_CAP: org$bukkit$material$types$MushroomBlockTexture;
  static ALL_STEM: org$bukkit$material$types$MushroomBlockTexture;
  static values(): JavaArray<org$bukkit$material$types$MushroomBlockTexture>;
  static valueOf(arg0: string): org$bukkit$material$types$MushroomBlockTexture;
  getData(): Buffer;
  getCapFace(): org$bukkit$block$BlockFace;
  static getByData(
    arg0: Buffer
  ): org$bukkit$material$types$MushroomBlockTexture;
  static getCapByFace(
    arg0: org$bukkit$block$BlockFace
  ): org$bukkit$material$types$MushroomBlockTexture;
}


declare interface $org$bukkit$material$Mushroom$1 {}

declare class org$bukkit$material$Mushroom$1
  implements $org$bukkit$material$Mushroom$1 {}


declare interface $org$bukkit$material$NetherWarts {
  getState(): org$bukkit$NetherWartsState;
  setState(arg0: org$bukkit$NetherWartsState): void;
  toString(): string;
  clone(): org$bukkit$material$NetherWarts;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$NetherWarts
  implements $org$bukkit$material$NetherWarts {
  constructor();
  constructor(arg0: org$bukkit$NetherWartsState);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getState(): org$bukkit$NetherWartsState;
  setState(arg0: org$bukkit$NetherWartsState): void;
  toString(): string;
  clone(): org$bukkit$material$NetherWarts;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$NetherWartsState {}

declare class org$bukkit$NetherWartsState
  implements $org$bukkit$NetherWartsState {
  static SEEDED: org$bukkit$NetherWartsState;
  static STAGE_ONE: org$bukkit$NetherWartsState;
  static STAGE_TWO: org$bukkit$NetherWartsState;
  static RIPE: org$bukkit$NetherWartsState;
  static values(): JavaArray<org$bukkit$NetherWartsState>;
  static valueOf(arg0: string): org$bukkit$NetherWartsState;
}


declare interface $org$bukkit$material$NetherWarts$1 {}

declare class org$bukkit$material$NetherWarts$1
  implements $org$bukkit$material$NetherWarts$1 {}


declare interface $org$bukkit$material$Observer
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Redstone {
  isPowered(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Observer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Observer
  implements $org$bukkit$material$Observer {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Observer;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Observer$1 {}

declare class org$bukkit$material$Observer$1
  implements $org$bukkit$material$Observer$1 {}


declare interface $org$bukkit$material$PistonBaseMaterial
  extends $org$bukkit$material$Directional,
    $org$bukkit$material$Redstone {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  isSticky(): boolean;
  clone(): org$bukkit$material$PistonBaseMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$PistonBaseMaterial
  implements $org$bukkit$material$PistonBaseMaterial {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  isSticky(): boolean;
  clone(): org$bukkit$material$PistonBaseMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$PistonBaseMaterial$1 {}

declare class org$bukkit$material$PistonBaseMaterial$1
  implements $org$bukkit$material$PistonBaseMaterial$1 {}


declare interface $org$bukkit$material$PistonExtensionMaterial
  extends $org$bukkit$material$Attachable {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isSticky(): boolean;
  setSticky(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  clone(): org$bukkit$material$PistonExtensionMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$PistonExtensionMaterial
  implements $org$bukkit$material$PistonExtensionMaterial {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isSticky(): boolean;
  setSticky(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  clone(): org$bukkit$material$PistonExtensionMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$PistonExtensionMaterial$1 {}

declare class org$bukkit$material$PistonExtensionMaterial$1
  implements $org$bukkit$material$PistonExtensionMaterial$1 {}


declare interface $org$bukkit$material$PoweredRail
  extends $org$bukkit$material$Redstone {
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  clone(): org$bukkit$material$PoweredRail;
  clone(): org$bukkit$material$ExtendedRails;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$PoweredRail
  implements $org$bukkit$material$PoweredRail {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  setPowered(arg0: boolean): void;
  clone(): org$bukkit$material$PoweredRail;
  clone(): org$bukkit$material$ExtendedRails;
  clone(): org$bukkit$material$Rails;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$PressurePlate
  extends $org$bukkit$material$PressureSensor {
  isPressed(): boolean;
  toString(): string;
  clone(): org$bukkit$material$PressurePlate;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$PressurePlate
  implements $org$bukkit$material$PressurePlate {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPressed(): boolean;
  toString(): string;
  clone(): org$bukkit$material$PressurePlate;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Pumpkin
  extends $org$bukkit$material$Directional {
  isLit(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Pumpkin;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Pumpkin
  implements $org$bukkit$material$Pumpkin {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isLit(): boolean;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Pumpkin;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Pumpkin$1 {}

declare class org$bukkit$material$Pumpkin$1
  implements $org$bukkit$material$Pumpkin$1 {}


declare interface $org$bukkit$material$Rails$1 {}

declare class org$bukkit$material$Rails$1
  implements $org$bukkit$material$Rails$1 {}


declare interface $org$bukkit$material$RedstoneTorch
  extends $org$bukkit$material$Redstone {
  isPowered(): boolean;
  toString(): string;
  clone(): org$bukkit$material$RedstoneTorch;
  clone(): org$bukkit$material$Torch;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$RedstoneTorch
  implements $org$bukkit$material$RedstoneTorch {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  toString(): string;
  clone(): org$bukkit$material$RedstoneTorch;
  clone(): org$bukkit$material$Torch;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$Torch {
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  clone(): org$bukkit$material$Torch;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Torch implements $org$bukkit$material$Torch {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  clone(): org$bukkit$material$Torch;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$RedstoneWire
  extends $org$bukkit$material$Redstone {
  isPowered(): boolean;
  toString(): string;
  clone(): org$bukkit$material$RedstoneWire;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$RedstoneWire
  implements $org$bukkit$material$RedstoneWire {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isPowered(): boolean;
  toString(): string;
  clone(): org$bukkit$material$RedstoneWire;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Sandstone {
  getType(): org$bukkit$SandstoneType;
  setType(arg0: org$bukkit$SandstoneType): void;
  toString(): string;
  clone(): org$bukkit$material$Sandstone;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Sandstone
  implements $org$bukkit$material$Sandstone {
  constructor();
  constructor(arg0: org$bukkit$SandstoneType);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getType(): org$bukkit$SandstoneType;
  setType(arg0: org$bukkit$SandstoneType): void;
  toString(): string;
  clone(): org$bukkit$material$Sandstone;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$SandstoneType {
  getData(): Buffer;
}

declare class org$bukkit$SandstoneType implements $org$bukkit$SandstoneType {
  static CRACKED: org$bukkit$SandstoneType;
  static GLYPHED: org$bukkit$SandstoneType;
  static SMOOTH: org$bukkit$SandstoneType;
  static values(): JavaArray<org$bukkit$SandstoneType>;
  static valueOf(arg0: string): org$bukkit$SandstoneType;
  getData(): Buffer;
  static getByData(arg0: Buffer): org$bukkit$SandstoneType;
}


declare interface $org$bukkit$material$Sapling {
  isInstantGrowable(): boolean;
  setIsInstantGrowable(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Sapling;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Sapling
  implements $org$bukkit$material$Sapling {
  constructor();
  constructor(arg0: org$bukkit$TreeSpecies);
  constructor(arg0: org$bukkit$TreeSpecies, arg1: boolean);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$TreeSpecies);
  constructor(
    arg0: org$bukkit$Material,
    arg1: org$bukkit$TreeSpecies,
    arg2: boolean
  );
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isInstantGrowable(): boolean;
  setIsInstantGrowable(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Sapling;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Sign
  extends $org$bukkit$material$Attachable {
  isWallSign(): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  getFacing(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Sign;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Sign implements $org$bukkit$material$Sign {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isWallSign(): boolean;
  getAttachedFace(): org$bukkit$block$BlockFace;
  getFacing(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Sign;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Sign$1 {}

declare class org$bukkit$material$Sign$1
  implements $org$bukkit$material$Sign$1 {}


declare interface $org$bukkit$material$Skull
  extends $org$bukkit$material$Directional {
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Skull;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Skull implements $org$bukkit$material$Skull {
  constructor();
  constructor(arg0: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  toString(): string;
  clone(): org$bukkit$material$Skull;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Skull$1 {}

declare class org$bukkit$material$Skull$1
  implements $org$bukkit$material$Skull$1 {}


declare interface $org$bukkit$material$SmoothBrick {
  getTextures(): any /* java.util.List */;
  clone(): org$bukkit$material$SmoothBrick;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$SmoothBrick
  implements $org$bukkit$material$SmoothBrick {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getTextures(): any /* java.util.List */;
  clone(): org$bukkit$material$SmoothBrick;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$SpawnEgg {
  getSpawnedType(): org$bukkit$entity$EntityType;
  setSpawnedType(arg0: org$bukkit$entity$EntityType): void;
  toString(): string;
  clone(): org$bukkit$material$SpawnEgg;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$SpawnEgg
  implements $org$bukkit$material$SpawnEgg {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: Buffer);
  constructor(arg0: org$bukkit$entity$EntityType);
  getSpawnedType(): org$bukkit$entity$EntityType;
  setSpawnedType(arg0: org$bukkit$entity$EntityType): void;
  toString(): string;
  clone(): org$bukkit$material$SpawnEgg;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Stairs
  extends $org$bukkit$material$Directional {
  getAscendingDirection(): org$bukkit$block$BlockFace;
  getDescendingDirection(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Stairs;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Stairs
  implements $org$bukkit$material$Stairs {
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getAscendingDirection(): org$bukkit$block$BlockFace;
  getDescendingDirection(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getFacing(): org$bukkit$block$BlockFace;
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  toString(): string;
  clone(): org$bukkit$material$Stairs;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Stairs$1 {}

declare class org$bukkit$material$Stairs$1
  implements $org$bukkit$material$Stairs$1 {}


declare interface $org$bukkit$material$Step {
  getTextures(): any /* java.util.List */;
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  getTextureIndex(): number;
  setTextureIndex(arg0: number): void;
  clone(): org$bukkit$material$Step;
  toString(): string;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Step implements $org$bukkit$material$Step {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getTextures(): any /* java.util.List */;
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  getTextureIndex(): number;
  setTextureIndex(arg0: number): void;
  clone(): org$bukkit$material$Step;
  toString(): string;
  clone(): org$bukkit$material$TexturedMaterial;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Torch$1 {}

declare class org$bukkit$material$Torch$1
  implements $org$bukkit$material$Torch$1 {}


declare interface $org$bukkit$material$TrapDoor
  extends $org$bukkit$material$Openable {
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$TrapDoor;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$TrapDoor
  implements $org$bukkit$material$TrapDoor {
  constructor();
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isOpen(): boolean;
  setOpen(arg0: boolean): void;
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$TrapDoor;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$TrapDoor$1 {}

declare class org$bukkit$material$TrapDoor$1
  implements $org$bukkit$material$TrapDoor$1 {}


declare interface $org$bukkit$material$Tree {
  getDirection(): org$bukkit$block$BlockFace;
  setDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Tree;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Tree implements $org$bukkit$material$Tree {
  constructor();
  constructor(arg0: org$bukkit$TreeSpecies);
  constructor(arg0: org$bukkit$TreeSpecies, arg1: org$bukkit$block$BlockFace);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: org$bukkit$TreeSpecies);
  constructor(
    arg0: org$bukkit$Material,
    arg1: org$bukkit$TreeSpecies,
    arg2: org$bukkit$block$BlockFace
  );
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getDirection(): org$bukkit$block$BlockFace;
  setDirection(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Tree;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Tree$1 {}

declare class org$bukkit$material$Tree$1
  implements $org$bukkit$material$Tree$1 {}


declare interface $org$bukkit$material$Tripwire {
  isActivated(): boolean;
  setActivated(arg0: boolean): void;
  isObjectTriggering(): boolean;
  setObjectTriggering(arg0: boolean): void;
  clone(): org$bukkit$material$Tripwire;
  toString(): string;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Tripwire
  implements $org$bukkit$material$Tripwire {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isActivated(): boolean;
  setActivated(arg0: boolean): void;
  isObjectTriggering(): boolean;
  setObjectTriggering(arg0: boolean): void;
  clone(): org$bukkit$material$Tripwire;
  toString(): string;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$TripwireHook
  extends $org$bukkit$material$Redstone {
  isConnected(): boolean;
  setConnected(arg0: boolean): void;
  isActivated(): boolean;
  setActivated(arg0: boolean): void;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  isPowered(): boolean;
  clone(): org$bukkit$material$TripwireHook;
  toString(): string;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$TripwireHook
  implements $org$bukkit$material$TripwireHook {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: org$bukkit$block$BlockFace);
  isConnected(): boolean;
  setConnected(arg0: boolean): void;
  isActivated(): boolean;
  setActivated(arg0: boolean): void;
  setFacingDirection(arg0: org$bukkit$block$BlockFace): void;
  getAttachedFace(): org$bukkit$block$BlockFace;
  isPowered(): boolean;
  clone(): org$bukkit$material$TripwireHook;
  toString(): string;
  clone(): org$bukkit$material$SimpleAttachableMaterialData;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
  getFacing(): org$bukkit$block$BlockFace;
}


declare interface $org$bukkit$material$TripwireHook$1 {}

declare class org$bukkit$material$TripwireHook$1
  implements $org$bukkit$material$TripwireHook$1 {}


declare interface $org$bukkit$material$Vine {
  isOnFace(arg0: org$bukkit$block$BlockFace): boolean;
  putOnFace(arg0: org$bukkit$block$BlockFace): void;
  removeFromFace(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Vine;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Vine implements $org$bukkit$material$Vine {
  constructor();
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  constructor(arg0: Buffer);
  constructor(arg0: JavaArray<org$bukkit$block$BlockFace>);
  constructor(arg0: any /* java.util.EnumSet */);
  isOnFace(arg0: org$bukkit$block$BlockFace): boolean;
  putOnFace(arg0: org$bukkit$block$BlockFace): void;
  removeFromFace(arg0: org$bukkit$block$BlockFace): void;
  toString(): string;
  clone(): org$bukkit$material$Vine;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Vine$1 {}

declare class org$bukkit$material$Vine$1
  implements $org$bukkit$material$Vine$1 {}


declare interface $org$bukkit$material$Wood$1 {}

declare class org$bukkit$material$Wood$1
  implements $org$bukkit$material$Wood$1 {}


declare interface $org$bukkit$material$WoodenStep {
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  clone(): org$bukkit$material$WoodenStep;
  toString(): string;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$WoodenStep
  implements $org$bukkit$material$WoodenStep {
  constructor();
  constructor(arg0: org$bukkit$TreeSpecies);
  constructor(arg0: org$bukkit$TreeSpecies, arg1: boolean);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  isInverted(): boolean;
  setInverted(arg0: boolean): void;
  clone(): org$bukkit$material$WoodenStep;
  toString(): string;
  clone(): org$bukkit$material$Wood;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$material$Wool
  extends $org$bukkit$material$Colorable {
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  toString(): string;
  clone(): org$bukkit$material$Wool;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}

declare class org$bukkit$material$Wool implements $org$bukkit$material$Wool {
  constructor();
  constructor(arg0: org$bukkit$DyeColor);
  constructor(arg0: org$bukkit$Material);
  constructor(arg0: org$bukkit$Material, arg1: Buffer);
  getColor(): org$bukkit$DyeColor;
  setColor(arg0: org$bukkit$DyeColor): void;
  toString(): string;
  clone(): org$bukkit$material$Wool;
  clone(): org$bukkit$material$MaterialData;
  clone(): any;
}


declare interface $org$bukkit$Material$1 {}

declare class org$bukkit$Material$1 implements $org$bukkit$Material$1 {}


declare interface $org$bukkit$metadata$FixedMetadataValue {
  invalidate(): void;
  value(): any;
}

declare class org$bukkit$metadata$FixedMetadataValue
  implements $org$bukkit$metadata$FixedMetadataValue {
  constructor(arg0: org$bukkit$plugin$Plugin, arg1: any);
  invalidate(): void;
  value(): any;
  asInt(): number;
  asFloat(): number;
  asDouble(): number;
  asLong(): number;
  asShort(): unknown;
  asByte(): Buffer;
  asBoolean(): boolean;
  asString(): string;
  getOwningPlugin(): org$bukkit$plugin$Plugin;
}


declare interface $org$bukkit$metadata$LazyMetadataValue {
  value(): any;
  invalidate(): void;
}

declare class org$bukkit$metadata$LazyMetadataValue
  implements $org$bukkit$metadata$LazyMetadataValue {
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: any /* java.util.concurrent.Callable */
  );
  constructor(
    arg0: org$bukkit$plugin$Plugin,
    arg1: org$bukkit$metadata$LazyMetadataValue$CacheStrategy,
    arg2: any /* java.util.concurrent.Callable */
  );
  constructor(arg0: org$bukkit$plugin$Plugin);
  value(): any;
  invalidate(): void;
  asInt(): number;
  asFloat(): number;
  asDouble(): number;
  asLong(): number;
  asShort(): unknown;
  asByte(): Buffer;
  asBoolean(): boolean;
  asString(): string;
  getOwningPlugin(): org$bukkit$plugin$Plugin;
}


declare interface $org$bukkit$metadata$LazyMetadataValue$CacheStrategy {}

declare class org$bukkit$metadata$LazyMetadataValue$CacheStrategy
  implements $org$bukkit$metadata$LazyMetadataValue$CacheStrategy {
  static CACHE_AFTER_FIRST_EVAL: org$bukkit$metadata$LazyMetadataValue$CacheStrategy;
  static NEVER_CACHE: org$bukkit$metadata$LazyMetadataValue$CacheStrategy;
  static CACHE_ETERNALLY: org$bukkit$metadata$LazyMetadataValue$CacheStrategy;
  static values(): JavaArray<
    org$bukkit$metadata$LazyMetadataValue$CacheStrategy
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$metadata$LazyMetadataValue$CacheStrategy;
}


declare interface $org$bukkit$metadata$MetadataConversionException {}

declare class org$bukkit$metadata$MetadataConversionException
  implements $org$bukkit$metadata$MetadataConversionException {
  constructor(arg0: string);
}


declare interface $org$bukkit$metadata$MetadataEvaluationException {}

declare class org$bukkit$metadata$MetadataEvaluationException
  implements $org$bukkit$metadata$MetadataEvaluationException {
  constructor(arg0: any /* java.lang.Throwable */);
}


declare interface $org$bukkit$metadata$MetadataStore {
  setMetadata(
    arg0: any,
    arg1: string,
    arg2: org$bukkit$metadata$MetadataValue
  ): void;
  getMetadata(arg0: any, arg1: string): any /* java.util.List */;
  hasMetadata(arg0: any, arg1: string): boolean;
  removeMetadata(arg0: any, arg1: string, arg2: org$bukkit$plugin$Plugin): void;
  invalidateAll(arg0: org$bukkit$plugin$Plugin): void;
}

declare class org$bukkit$metadata$MetadataStore
  implements $org$bukkit$metadata$MetadataStore {
  setMetadata(
    arg0: any,
    arg1: string,
    arg2: org$bukkit$metadata$MetadataValue
  ): void;
  getMetadata(arg0: any, arg1: string): any /* java.util.List */;
  hasMetadata(arg0: any, arg1: string): boolean;
  removeMetadata(arg0: any, arg1: string, arg2: org$bukkit$plugin$Plugin): void;
  invalidateAll(arg0: org$bukkit$plugin$Plugin): void;
}


declare interface $org$bukkit$metadata$MetadataStoreBase {
  setMetadata(
    arg0: any,
    arg1: string,
    arg2: org$bukkit$metadata$MetadataValue
  ): void;
  getMetadata(arg0: any, arg1: string): any /* java.util.List */;
  hasMetadata(arg0: any, arg1: string): boolean;
  removeMetadata(arg0: any, arg1: string, arg2: org$bukkit$plugin$Plugin): void;
  invalidateAll(arg0: org$bukkit$plugin$Plugin): void;
  removeAll(arg0: org$bukkit$plugin$Plugin): void;
  disambiguate(arg0: any, arg1: string): string;
}

declare class org$bukkit$metadata$MetadataStoreBase
  implements $org$bukkit$metadata$MetadataStoreBase {
  constructor();
  setMetadata(
    arg0: any,
    arg1: string,
    arg2: org$bukkit$metadata$MetadataValue
  ): void;
  getMetadata(arg0: any, arg1: string): any /* java.util.List */;
  hasMetadata(arg0: any, arg1: string): boolean;
  removeMetadata(arg0: any, arg1: string, arg2: org$bukkit$plugin$Plugin): void;
  invalidateAll(arg0: org$bukkit$plugin$Plugin): void;
  removeAll(arg0: org$bukkit$plugin$Plugin): void;
  disambiguate(arg0: any, arg1: string): string;
}


declare interface $org$bukkit$metadata$MetadataValueAdapter
  extends $org$bukkit$metadata$MetadataValue {
  getOwningPlugin(): org$bukkit$plugin$Plugin;
  asInt(): number;
  asFloat(): number;
  asDouble(): number;
  asLong(): number;
  asShort(): unknown;
  asByte(): Buffer;
  asBoolean(): boolean;
  asString(): string;
}

declare class org$bukkit$metadata$MetadataValueAdapter
  implements $org$bukkit$metadata$MetadataValueAdapter {
  constructor(arg0: org$bukkit$plugin$Plugin);
  getOwningPlugin(): org$bukkit$plugin$Plugin;
  asInt(): number;
  asFloat(): number;
  asDouble(): number;
  asLong(): number;
  asShort(): unknown;
  asByte(): Buffer;
  asBoolean(): boolean;
  asString(): string;
  value(): any;
  invalidate(): void;
}


declare interface $org$bukkit$Particle$DustOptions {
  getColor(): org$bukkit$Color;
  getSize(): number;
}

declare class org$bukkit$Particle$DustOptions
  implements $org$bukkit$Particle$DustOptions {
  constructor(arg0: org$bukkit$Color, arg1: number);
  getColor(): org$bukkit$Color;
  getSize(): number;
}


declare interface $org$bukkit$permissions$PermissibleBase
  extends $org$bukkit$permissions$Permissible {
  isOp(): boolean;
  setOp(arg0: boolean): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  clearPermissions(): void;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  getEffectivePermissions(): any /* java.util.Set */;
}

declare class org$bukkit$permissions$PermissibleBase
  implements $org$bukkit$permissions$PermissibleBase {
  constructor(arg0: org$bukkit$permissions$ServerOperator);
  isOp(): boolean;
  setOp(arg0: boolean): void;
  isPermissionSet(arg0: string): boolean;
  isPermissionSet(arg0: org$bukkit$permissions$Permission): boolean;
  hasPermission(arg0: string): boolean;
  hasPermission(arg0: org$bukkit$permissions$Permission): boolean;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin
  ): org$bukkit$permissions$PermissionAttachment;
  removeAttachment(arg0: org$bukkit$permissions$PermissionAttachment): void;
  recalculatePermissions(): void;
  clearPermissions(): void;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: boolean,
    arg3: number
  ): org$bukkit$permissions$PermissionAttachment;
  addAttachment(
    arg0: org$bukkit$plugin$Plugin,
    arg1: number
  ): org$bukkit$permissions$PermissionAttachment;
  getEffectivePermissions(): any /* java.util.Set */;
}


declare interface $org$bukkit$permissions$PermissibleBase$RemoveAttachmentRunnable {
  run(): void;
}

declare class org$bukkit$permissions$PermissibleBase$RemoveAttachmentRunnable
  implements $org$bukkit$permissions$PermissibleBase$RemoveAttachmentRunnable {
  constructor(arg0: org$bukkit$permissions$PermissionAttachment);
  run(): void;
}


declare interface $org$bukkit$permissions$PermissionAttachmentInfo {
  getPermissible(): org$bukkit$permissions$Permissible;
  getPermission(): string;
  getAttachment(): org$bukkit$permissions$PermissionAttachment;
  getValue(): boolean;
}

declare class org$bukkit$permissions$PermissionAttachmentInfo
  implements $org$bukkit$permissions$PermissionAttachmentInfo {
  constructor(
    arg0: org$bukkit$permissions$Permissible,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionAttachment,
    arg3: boolean
  );
  getPermissible(): org$bukkit$permissions$Permissible;
  getPermission(): string;
  getAttachment(): org$bukkit$permissions$PermissionAttachment;
  getValue(): boolean;
}


declare interface $org$bukkit$permissions$PermissionDefault$1 {}

declare class org$bukkit$permissions$PermissionDefault$1
  implements $org$bukkit$permissions$PermissionDefault$1 {}


declare interface $org$bukkit$persistence$PersistentDataType$PrimitivePersistentDataType
  extends $org$bukkit$persistence$PersistentDataType {
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
}

declare class org$bukkit$persistence$PersistentDataType$PrimitivePersistentDataType
  implements
    $org$bukkit$persistence$PersistentDataType$PrimitivePersistentDataType {
  constructor(arg0: any /* java.lang.Class */);
  getPrimitiveType(): any /* java.lang.Class */;
  getComplexType(): any /* java.lang.Class */;
  toPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
  fromPrimitive(
    arg0: any,
    arg1: org$bukkit$persistence$PersistentDataAdapterContext
  ): any;
  static BYTE: org$bukkit$persistence$PersistentDataType;
  static SHORT: org$bukkit$persistence$PersistentDataType;
  static INTEGER: org$bukkit$persistence$PersistentDataType;
  static LONG: org$bukkit$persistence$PersistentDataType;
  static FLOAT: org$bukkit$persistence$PersistentDataType;
  static DOUBLE: org$bukkit$persistence$PersistentDataType;
  static STRING: org$bukkit$persistence$PersistentDataType;
  static BYTE_ARRAY: org$bukkit$persistence$PersistentDataType;
  static INTEGER_ARRAY: org$bukkit$persistence$PersistentDataType;
  static LONG_ARRAY: org$bukkit$persistence$PersistentDataType;
  static TAG_CONTAINER: org$bukkit$persistence$PersistentDataType;
}


declare interface $org$bukkit$plugin$AuthorNagException {
  getMessage(): string;
}

declare class org$bukkit$plugin$AuthorNagException
  implements $org$bukkit$plugin$AuthorNagException {
  constructor(arg0: string);
  getMessage(): string;
}


declare interface $org$bukkit$plugin$EventExecutor$1 {
  computeIfAbsent(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.util.function.Function */
  ): any /* java.lang.Class */;
  computeIfAbsent(arg0: any, arg1: any /* java.util.function.Function */): any;
}

declare class org$bukkit$plugin$EventExecutor$1
  implements $org$bukkit$plugin$EventExecutor$1 {
  constructor();
  computeIfAbsent(
    arg0: any /* java.lang.reflect.Method */,
    arg1: any /* java.util.function.Function */
  ): any /* java.lang.Class */;
  computeIfAbsent(arg0: any, arg1: any /* java.util.function.Function */): any;
}


declare interface $org$bukkit$plugin$IllegalPluginAccessException {}

declare class org$bukkit$plugin$IllegalPluginAccessException
  implements $org$bukkit$plugin$IllegalPluginAccessException {
  constructor();
  constructor(arg0: string);
}


declare interface $org$bukkit$plugin$InvalidDescriptionException {}

declare class org$bukkit$plugin$InvalidDescriptionException
  implements $org$bukkit$plugin$InvalidDescriptionException {
  constructor(arg0: any /* java.lang.Throwable */, arg1: string);
  constructor(arg0: any /* java.lang.Throwable */);
  constructor(arg0: string);
  constructor();
}


declare interface $org$bukkit$plugin$InvalidPluginException {}

declare class org$bukkit$plugin$InvalidPluginException
  implements $org$bukkit$plugin$InvalidPluginException {
  constructor(arg0: any /* java.lang.Throwable */);
  constructor();
  constructor(arg0: string, arg1: any /* java.lang.Throwable */);
  constructor(arg0: string);
}


declare interface $org$bukkit$plugin$java$JavaPlugin {
  getDataFolder(): any /* java.io.File */;
  getPluginLoader(): org$bukkit$plugin$PluginLoader;
  getServer(): org$bukkit$Server;
  isEnabled(): boolean;
  getFile(): any /* java.io.File */;
  getDescription(): org$bukkit$plugin$PluginDescriptionFile;
  getConfig(): org$bukkit$configuration$file$FileConfiguration;
  getTextResource(arg0: string): any /* java.io.Reader */;
  reloadConfig(): void;
  saveConfig(): void;
  saveDefaultConfig(): void;
  saveResource(arg0: string, arg1: boolean): void;
  getResource(arg0: string): any /* java.io.InputStream */;
  getClassLoader(): any /* java.lang.ClassLoader */;
  setEnabled(arg0: boolean): void;
  init(
    arg0: org$bukkit$plugin$PluginLoader,
    arg1: org$bukkit$Server,
    arg2: org$bukkit$plugin$PluginDescriptionFile,
    arg3: any /* java.io.File */,
    arg4: any /* java.io.File */,
    arg5: any /* java.lang.ClassLoader */
  ): void;
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
  getCommand(arg0: string): org$bukkit$command$PluginCommand;
  onLoad(): void;
  onDisable(): void;
  onEnable(): void;
  getDefaultWorldGenerator(
    arg0: string,
    arg1: string
  ): org$bukkit$generator$ChunkGenerator;
  isNaggable(): boolean;
  setNaggable(arg0: boolean): void;
  getLogger(): any /* java.util.logging.Logger */;
  toString(): string;
}

declare class org$bukkit$plugin$java$JavaPlugin
  implements $org$bukkit$plugin$java$JavaPlugin {
  constructor();
  constructor(
    arg0: org$bukkit$plugin$java$JavaPluginLoader,
    arg1: org$bukkit$plugin$PluginDescriptionFile,
    arg2: any /* java.io.File */,
    arg3: any /* java.io.File */
  );
  getDataFolder(): any /* java.io.File */;
  getPluginLoader(): org$bukkit$plugin$PluginLoader;
  getServer(): org$bukkit$Server;
  isEnabled(): boolean;
  getFile(): any /* java.io.File */;
  getDescription(): org$bukkit$plugin$PluginDescriptionFile;
  getConfig(): org$bukkit$configuration$file$FileConfiguration;
  getTextResource(arg0: string): any /* java.io.Reader */;
  reloadConfig(): void;
  saveConfig(): void;
  saveDefaultConfig(): void;
  saveResource(arg0: string, arg1: boolean): void;
  getResource(arg0: string): any /* java.io.InputStream */;
  getClassLoader(): any /* java.lang.ClassLoader */;
  setEnabled(arg0: boolean): void;
  init(
    arg0: org$bukkit$plugin$PluginLoader,
    arg1: org$bukkit$Server,
    arg2: org$bukkit$plugin$PluginDescriptionFile,
    arg3: any /* java.io.File */,
    arg4: any /* java.io.File */,
    arg5: any /* java.lang.ClassLoader */
  ): void;
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
  getCommand(arg0: string): org$bukkit$command$PluginCommand;
  onLoad(): void;
  onDisable(): void;
  onEnable(): void;
  getDefaultWorldGenerator(
    arg0: string,
    arg1: string
  ): org$bukkit$generator$ChunkGenerator;
  isNaggable(): boolean;
  setNaggable(arg0: boolean): void;
  getLogger(): any /* java.util.logging.Logger */;
  toString(): string;
  static getPlugin(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$java$JavaPlugin;
  static getProvidingPlugin(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$java$JavaPlugin;
  getSLF4JLogger(): unknown;
  getName(): string;
}


declare interface $org$bukkit$plugin$java$JavaPluginLoader
  extends $org$bukkit$plugin$PluginLoader {
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  getPluginDescription(
    arg0: any /* java.io.File */
  ): org$bukkit$plugin$PluginDescriptionFile;
  getPluginFileFilters(): JavaArray<any /* java.util.regex.Pattern */>;
  getClassByName(arg0: string): any /* java.lang.Class */;
  getClassByName(
    arg0: string,
    arg1: org$bukkit$plugin$java$PluginClassLoader
  ): any /* java.lang.Class */;
  setClass(arg0: string, arg1: any /* java.lang.Class */): void;
  createRegisteredListeners(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): any /* java.util.Map */;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
}

declare class org$bukkit$plugin$java$JavaPluginLoader
  implements $org$bukkit$plugin$java$JavaPluginLoader {
  constructor(arg0: org$bukkit$Server);
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  getPluginDescription(
    arg0: any /* java.io.File */
  ): org$bukkit$plugin$PluginDescriptionFile;
  getPluginFileFilters(): JavaArray<any /* java.util.regex.Pattern */>;
  getClassByName(arg0: string): any /* java.lang.Class */;
  getClassByName(
    arg0: string,
    arg1: org$bukkit$plugin$java$PluginClassLoader
  ): any /* java.lang.Class */;
  setClass(arg0: string, arg1: any /* java.lang.Class */): void;
  createRegisteredListeners(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): any /* java.util.Map */;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
}


declare interface $org$bukkit$plugin$java$PluginClassLoader {
  getPlugin(): org$bukkit$plugin$java$JavaPlugin;

  getResource(arg0: string): any /* java.net.URL */;
  getResources(arg0: string): any /* java.util.Enumeration */;
  findClass(arg0: string): any /* java.lang.Class */;
  findClass(arg0: string, arg1: boolean): any /* java.lang.Class */;
  close(): void;
  getClasses(): any /* java.util.Set */;
  initialize(arg0: org$bukkit$plugin$java$JavaPlugin): void;
  toString(): string;
}

declare class org$bukkit$plugin$java$PluginClassLoader
  implements $org$bukkit$plugin$java$PluginClassLoader {
  getPlugin(): org$bukkit$plugin$java$JavaPlugin;
  constructor(
    arg0: org$bukkit$plugin$java$JavaPluginLoader,
    arg1: any /* java.lang.ClassLoader */,
    arg2: org$bukkit$plugin$PluginDescriptionFile,
    arg3: any /* java.io.File */,
    arg4: any /* java.io.File */
  );
  getResource(arg0: string): any /* java.net.URL */;
  getResources(arg0: string): any /* java.util.Enumeration */;
  findClass(arg0: string): any /* java.lang.Class */;
  findClass(arg0: string, arg1: boolean): any /* java.lang.Class */;
  close(): void;
  getClasses(): any /* java.util.Set */;
  initialize(arg0: org$bukkit$plugin$java$JavaPlugin): void;
  toString(): string;
}


declare interface $org$bukkit$plugin$messaging$ChannelNameTooLongException {}

declare class org$bukkit$plugin$messaging$ChannelNameTooLongException
  implements $org$bukkit$plugin$messaging$ChannelNameTooLongException {
  constructor();
  constructor(arg0: string);
}


declare interface $org$bukkit$plugin$messaging$ChannelNotRegisteredException {}

declare class org$bukkit$plugin$messaging$ChannelNotRegisteredException
  implements $org$bukkit$plugin$messaging$ChannelNotRegisteredException {
  constructor();
  constructor(arg0: string);
}


declare interface $org$bukkit$plugin$messaging$MessageTooLargeException {}

declare class org$bukkit$plugin$messaging$MessageTooLargeException
  implements $org$bukkit$plugin$messaging$MessageTooLargeException {
  constructor();
  constructor(arg0: JavaArray<Buffer>);
  constructor(arg0: number);
  constructor(arg0: string);
}


declare interface $org$bukkit$plugin$messaging$PluginChannelDirection {}

declare class org$bukkit$plugin$messaging$PluginChannelDirection
  implements $org$bukkit$plugin$messaging$PluginChannelDirection {
  static INCOMING: org$bukkit$plugin$messaging$PluginChannelDirection;
  static OUTGOING: org$bukkit$plugin$messaging$PluginChannelDirection;
  static values(): JavaArray<
    org$bukkit$plugin$messaging$PluginChannelDirection
  >;
  static valueOf(
    arg0: string
  ): org$bukkit$plugin$messaging$PluginChannelDirection;
}


declare interface $org$bukkit$plugin$messaging$ReservedChannelException {}

declare class org$bukkit$plugin$messaging$ReservedChannelException
  implements $org$bukkit$plugin$messaging$ReservedChannelException {
  constructor();
  constructor(arg0: string);
}


declare interface $org$bukkit$plugin$messaging$StandardMessenger
  extends $org$bukkit$plugin$messaging$Messenger {
  isReservedChannel(arg0: string): boolean;
  registerOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  registerIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): org$bukkit$plugin$messaging$PluginMessageListenerRegistration;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): void;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterIncomingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  getOutgoingChannels(): any /* java.util.Set */;
  getOutgoingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannels(): any /* java.util.Set */;
  getIncomingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin
  ): any /* java.util.Set */;
  getIncomingChannelRegistrations(arg0: string): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): any /* java.util.Set */;
  isRegistrationValid(
    arg0: org$bukkit$plugin$messaging$PluginMessageListenerRegistration
  ): boolean;
  isIncomingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  isOutgoingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  dispatchIncomingMessage(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
}

declare class org$bukkit$plugin$messaging$StandardMessenger
  implements $org$bukkit$plugin$messaging$StandardMessenger {
  constructor();
  isReservedChannel(arg0: string): boolean;
  registerOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterOutgoingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  registerIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): org$bukkit$plugin$messaging$PluginMessageListenerRegistration;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string,
    arg2: org$bukkit$plugin$messaging$PluginMessageListener
  ): void;
  unregisterIncomingPluginChannel(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): void;
  unregisterIncomingPluginChannel(arg0: org$bukkit$plugin$Plugin): void;
  getOutgoingChannels(): any /* java.util.Set */;
  getOutgoingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannels(): any /* java.util.Set */;
  getIncomingChannels(arg0: org$bukkit$plugin$Plugin): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin
  ): any /* java.util.Set */;
  getIncomingChannelRegistrations(arg0: string): any /* java.util.Set */;
  getIncomingChannelRegistrations(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): any /* java.util.Set */;
  isRegistrationValid(
    arg0: org$bukkit$plugin$messaging$PluginMessageListenerRegistration
  ): boolean;
  isIncomingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  isOutgoingChannelRegistered(
    arg0: org$bukkit$plugin$Plugin,
    arg1: string
  ): boolean;
  dispatchIncomingMessage(
    arg0: org$bukkit$entity$Player,
    arg1: string,
    arg2: JavaArray<Buffer>
  ): void;
  static validateChannel(arg0: string): void;
  static validateAndCorrectChannel(arg0: string): string;
  static validatePluginMessage(
    arg0: org$bukkit$plugin$messaging$Messenger,
    arg1: org$bukkit$plugin$Plugin,
    arg2: string,
    arg3: JavaArray<Buffer>
  ): void;
  static MAX_MESSAGE_SIZE: number;
  static MAX_CHANNEL_SIZE: number;
}


declare interface $org$bukkit$plugin$PluginAwareness {}

declare class org$bukkit$plugin$PluginAwareness
  implements $org$bukkit$plugin$PluginAwareness {}


declare interface $org$bukkit$plugin$PluginAwareness$Flags
  extends $org$bukkit$plugin$PluginAwareness {}

declare class org$bukkit$plugin$PluginAwareness$Flags
  implements $org$bukkit$plugin$PluginAwareness$Flags {
  static UTF8: org$bukkit$plugin$PluginAwareness$Flags;
  static values(): JavaArray<org$bukkit$plugin$PluginAwareness$Flags>;
  static valueOf(arg0: string): org$bukkit$plugin$PluginAwareness$Flags;
}


declare interface $org$bukkit$plugin$PluginBase
  extends $org$bukkit$plugin$Plugin {
  hashCode(): number;
  equals(arg0: any): boolean;
  getName(): string;
}

declare class org$bukkit$plugin$PluginBase
  implements $org$bukkit$plugin$PluginBase {
  constructor();
  hashCode(): number;
  equals(arg0: any): boolean;
  getName(): string;
  onCommand(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): boolean;
  onTabComplete(
    arg0: org$bukkit$command$CommandSender,
    arg1: org$bukkit$command$Command,
    arg2: string,
    arg3: JavaArray<string>
  ): any /* java.util.List */;
  getDataFolder(): any /* java.io.File */;
  getDescription(): org$bukkit$plugin$PluginDescriptionFile;
  getConfig(): org$bukkit$configuration$file$FileConfiguration;
  getResource(arg0: string): any /* java.io.InputStream */;
  saveConfig(): void;
  saveDefaultConfig(): void;
  saveResource(arg0: string, arg1: boolean): void;
  reloadConfig(): void;
  getPluginLoader(): org$bukkit$plugin$PluginLoader;
  getServer(): org$bukkit$Server;
  isEnabled(): boolean;
  onDisable(): void;
  onLoad(): void;
  onEnable(): void;
  isNaggable(): boolean;
  setNaggable(arg0: boolean): void;
  getDefaultWorldGenerator(
    arg0: string,
    arg1: string
  ): org$bukkit$generator$ChunkGenerator;
  getLogger(): any /* java.util.logging.Logger */;
  getSLF4JLogger(): unknown;
}


declare interface $org$bukkit$plugin$PluginDescriptionFile$1 {
  initialValue(): unknown;
  initialValue(): any;
}

declare class org$bukkit$plugin$PluginDescriptionFile$1
  implements $org$bukkit$plugin$PluginDescriptionFile$1 {
  constructor();
  initialValue(): unknown;
  initialValue(): any;
}


declare interface $org$bukkit$plugin$PluginDescriptionFile$1$1 {}

declare class org$bukkit$plugin$PluginDescriptionFile$1$1
  implements $org$bukkit$plugin$PluginDescriptionFile$1$1 {
  constructor(arg0: org$bukkit$plugin$PluginDescriptionFile$1);
}


declare interface $org$bukkit$plugin$PluginDescriptionFile$1$1$1 {
  construct(arg0: unknown): any;
}

declare class org$bukkit$plugin$PluginDescriptionFile$1$1$1
  implements $org$bukkit$plugin$PluginDescriptionFile$1$1$1 {
  constructor(arg0: org$bukkit$plugin$PluginDescriptionFile$1$1);
  construct(arg0: unknown): any;
}


declare interface $org$bukkit$plugin$PluginDescriptionFile$1$1$1$1
  extends $org$bukkit$plugin$PluginAwareness {
  toString(): string;
}

declare class org$bukkit$plugin$PluginDescriptionFile$1$1$1$1
  implements $org$bukkit$plugin$PluginDescriptionFile$1$1$1$1 {
  constructor(
    arg0: org$bukkit$plugin$PluginDescriptionFile$1$1$1,
    arg1: unknown
  );
  toString(): string;
}


declare interface $org$bukkit$plugin$PluginDescriptionFile$1$1$2 {
  construct(arg0: unknown): org$bukkit$plugin$PluginAwareness$Flags;
  construct(arg0: unknown): any;
}

declare class org$bukkit$plugin$PluginDescriptionFile$1$1$2
  implements $org$bukkit$plugin$PluginDescriptionFile$1$1$2 {
  constructor(
    arg0: org$bukkit$plugin$PluginDescriptionFile$1$1,
    arg1: org$bukkit$plugin$PluginAwareness$Flags
  );
  construct(arg0: unknown): org$bukkit$plugin$PluginAwareness$Flags;
  construct(arg0: unknown): any;
}


declare interface $org$bukkit$plugin$PluginLogger {
  log(arg0: any /* java.util.logging.LogRecord */): void;
}

declare class org$bukkit$plugin$PluginLogger
  implements $org$bukkit$plugin$PluginLogger {
  constructor(arg0: org$bukkit$plugin$Plugin);
  log(arg0: any /* java.util.logging.LogRecord */): void;
}


declare interface $org$bukkit$plugin$SimplePluginManager
  extends $org$bukkit$plugin$PluginManager {
  registerInterface(arg0: any /* java.lang.Class */): void;
  loadPlugins(
    arg0: any /* java.io.File */
  ): JavaArray<org$bukkit$plugin$Plugin>;
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  getPlugin(arg0: string): org$bukkit$plugin$Plugin;
  getPlugins(): JavaArray<org$bukkit$plugin$Plugin>;
  isPluginEnabled(arg0: string): boolean;
  isPluginEnabled(arg0: org$bukkit$plugin$Plugin): boolean;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugins(): void;
  disablePlugins(arg0: boolean): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
  clearPlugins(): void;
  callEvent(arg0: org$bukkit$event$Event): void;
  registerEvents(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin,
    arg5: boolean
  ): void;
  getPermission(arg0: string): org$bukkit$permissions$Permission;
  addPermission(arg0: org$bukkit$permissions$Permission): void;
  addPermission(arg0: org$bukkit$permissions$Permission, arg1: boolean): void;
  getDefaultPermissions(arg0: boolean): any /* java.util.Set */;
  removePermission(arg0: org$bukkit$permissions$Permission): void;
  removePermission(arg0: string): void;
  recalculatePermissionDefaults(arg0: org$bukkit$permissions$Permission): void;
  dirtyPermissibles(): void;
  subscribeToPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getPermissionSubscriptions(arg0: string): any /* java.util.Set */;
  subscribeToDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getDefaultPermSubscriptions(arg0: boolean): any /* java.util.Set */;
  getPermissions(): any /* java.util.Set */;
  isTransitiveDepend(
    arg0: org$bukkit$plugin$PluginDescriptionFile,
    arg1: org$bukkit$plugin$PluginDescriptionFile
  ): boolean;
  useTimings(): boolean;
  useTimings(arg0: boolean): void;
  clearPermissions(): void;
}

declare class org$bukkit$plugin$SimplePluginManager
  implements $org$bukkit$plugin$SimplePluginManager {
  constructor(
    arg0: org$bukkit$Server,
    arg1: org$bukkit$command$SimpleCommandMap
  );
  registerInterface(arg0: any /* java.lang.Class */): void;
  loadPlugins(
    arg0: any /* java.io.File */
  ): JavaArray<org$bukkit$plugin$Plugin>;
  loadPlugin(arg0: any /* java.io.File */): org$bukkit$plugin$Plugin;
  getPlugin(arg0: string): org$bukkit$plugin$Plugin;
  getPlugins(): JavaArray<org$bukkit$plugin$Plugin>;
  isPluginEnabled(arg0: string): boolean;
  isPluginEnabled(arg0: org$bukkit$plugin$Plugin): boolean;
  enablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugins(): void;
  disablePlugins(arg0: boolean): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin): void;
  disablePlugin(arg0: org$bukkit$plugin$Plugin, arg1: boolean): void;
  clearPlugins(): void;
  callEvent(arg0: org$bukkit$event$Event): void;
  registerEvents(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin
  ): void;
  registerEvent(
    arg0: any /* java.lang.Class */,
    arg1: org$bukkit$event$Listener,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$EventExecutor,
    arg4: org$bukkit$plugin$Plugin,
    arg5: boolean
  ): void;
  getPermission(arg0: string): org$bukkit$permissions$Permission;
  addPermission(arg0: org$bukkit$permissions$Permission): void;
  addPermission(arg0: org$bukkit$permissions$Permission, arg1: boolean): void;
  getDefaultPermissions(arg0: boolean): any /* java.util.Set */;
  removePermission(arg0: org$bukkit$permissions$Permission): void;
  removePermission(arg0: string): void;
  recalculatePermissionDefaults(arg0: org$bukkit$permissions$Permission): void;
  dirtyPermissibles(): void;
  subscribeToPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromPermission(
    arg0: string,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getPermissionSubscriptions(arg0: string): any /* java.util.Set */;
  subscribeToDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  unsubscribeFromDefaultPerms(
    arg0: boolean,
    arg1: org$bukkit$permissions$Permissible
  ): void;
  getDefaultPermSubscriptions(arg0: boolean): any /* java.util.Set */;
  getPermissions(): any /* java.util.Set */;
  isTransitiveDepend(
    arg0: org$bukkit$plugin$PluginDescriptionFile,
    arg1: org$bukkit$plugin$PluginDescriptionFile
  ): boolean;
  useTimings(): boolean;
  useTimings(arg0: boolean): void;
  clearPermissions(): void;
}


declare interface $com$google$common$graph$MutableGraph
  extends $com$google$common$graph$Graph {
  addNode(arg0: any): boolean;
  putEdge(arg0: any, arg1: any): boolean;
  removeNode(arg0: any): boolean;
  removeEdge(arg0: any, arg1: any): boolean;
}

declare class com$google$common$graph$MutableGraph
  implements $com$google$common$graph$MutableGraph {
  addNode(arg0: any): boolean;
  putEdge(arg0: any, arg1: any): boolean;
  removeNode(arg0: any): boolean;
  removeEdge(arg0: any, arg1: any): boolean;
  nodes(): any /* java.util.Set */;
  edges(): any /* java.util.Set */;
  isDirected(): boolean;
  allowsSelfLoops(): boolean;
  nodeOrder(): com$google$common$graph$ElementOrder;
  adjacentNodes(arg0: any): any /* java.util.Set */;
  predecessors(arg0: any): any /* java.util.Set */;
  successors(arg0: any): any /* java.util.Set */;
  degree(arg0: any): number;
  inDegree(arg0: any): number;
  outDegree(arg0: any): number;
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $com$google$common$graph$Graph {
  nodes(): any /* java.util.Set */;
  edges(): any /* java.util.Set */;
  isDirected(): boolean;
  allowsSelfLoops(): boolean;
  nodeOrder(): com$google$common$graph$ElementOrder;
  adjacentNodes(arg0: any): any /* java.util.Set */;
  predecessors(arg0: any): any /* java.util.Set */;
  successors(arg0: any): any /* java.util.Set */;
  degree(arg0: any): number;
  inDegree(arg0: any): number;
  outDegree(arg0: any): number;
  equals(arg0: any): boolean;
  hashCode(): number;
}

declare class com$google$common$graph$Graph
  implements $com$google$common$graph$Graph {
  nodes(): any /* java.util.Set */;
  edges(): any /* java.util.Set */;
  isDirected(): boolean;
  allowsSelfLoops(): boolean;
  nodeOrder(): com$google$common$graph$ElementOrder;
  adjacentNodes(arg0: any): any /* java.util.Set */;
  predecessors(arg0: any): any /* java.util.Set */;
  successors(arg0: any): any /* java.util.Set */;
  degree(arg0: any): number;
  inDegree(arg0: any): number;
  outDegree(arg0: any): number;
  equals(arg0: any): boolean;
  hashCode(): number;
}


declare interface $com$google$common$graph$ElementOrder {
  type(): com$google$common$graph$ElementOrder$Type;
  comparator(): any /* java.util.Comparator */;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  createMap(arg0: number): any /* java.util.Map */;
  cast(): com$google$common$graph$ElementOrder;
}

declare class com$google$common$graph$ElementOrder
  implements $com$google$common$graph$ElementOrder {
  static unordered(): com$google$common$graph$ElementOrder;
  static insertion(): com$google$common$graph$ElementOrder;
  static natural(): com$google$common$graph$ElementOrder;
  static sorted(
    arg0: any /* java.util.Comparator */
  ): com$google$common$graph$ElementOrder;
  type(): com$google$common$graph$ElementOrder$Type;
  comparator(): any /* java.util.Comparator */;
  equals(arg0: any): boolean;
  hashCode(): number;
  toString(): string;
  createMap(arg0: number): any /* java.util.Map */;
  cast(): com$google$common$graph$ElementOrder;
}


declare interface $com$google$common$graph$ElementOrder$Type {}

declare class com$google$common$graph$ElementOrder$Type
  implements $com$google$common$graph$ElementOrder$Type {
  static UNORDERED: com$google$common$graph$ElementOrder$Type;
  static INSERTION: com$google$common$graph$ElementOrder$Type;
  static SORTED: com$google$common$graph$ElementOrder$Type;
  static values(): JavaArray<com$google$common$graph$ElementOrder$Type>;
  static valueOf(arg0: string): com$google$common$graph$ElementOrder$Type;
}


declare interface $org$bukkit$plugin$SimpleServicesManager
  extends $org$bukkit$plugin$ServicesManager {
  register(
    arg0: any /* java.lang.Class */,
    arg1: any,
    arg2: org$bukkit$plugin$Plugin,
    arg3: org$bukkit$plugin$ServicePriority
  ): void;
  unregisterAll(arg0: org$bukkit$plugin$Plugin): void;
  unregister(arg0: any /* java.lang.Class */, arg1: any): void;
  unregister(arg0: any): void;
  load(arg0: any /* java.lang.Class */): any;
  getRegistration(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$RegisteredServiceProvider;
  getRegistrations(arg0: org$bukkit$plugin$Plugin): any /* java.util.List */;
  getRegistrations(arg0: any /* java.lang.Class */): any /* java.util.List */;
  getKnownServices(): any /* java.util.Set */;
  isProvidedFor(arg0: any /* java.lang.Class */): boolean;
  getKnownServices(): java$util$Collection;
  getRegistrations(arg0: any /* java.lang.Class */): java$util$Collection;
}

declare class org$bukkit$plugin$SimpleServicesManager
  implements $org$bukkit$plugin$SimpleServicesManager {
  constructor();
  register(
    arg0: any /* java.lang.Class */,
    arg1: any,
    arg2: org$bukkit$plugin$Plugin,
    arg3: org$bukkit$plugin$ServicePriority
  ): void;
  unregisterAll(arg0: org$bukkit$plugin$Plugin): void;
  unregister(arg0: any /* java.lang.Class */, arg1: any): void;
  unregister(arg0: any): void;
  load(arg0: any /* java.lang.Class */): any;
  getRegistration(
    arg0: any /* java.lang.Class */
  ): org$bukkit$plugin$RegisteredServiceProvider;
  getRegistrations(arg0: org$bukkit$plugin$Plugin): any /* java.util.List */;
  getRegistrations(arg0: any /* java.lang.Class */): any /* java.util.List */;
  getKnownServices(): any /* java.util.Set */;
  isProvidedFor(arg0: any /* java.lang.Class */): boolean;
  getKnownServices(): java$util$Collection;
  getRegistrations(arg0: any /* java.lang.Class */): java$util$Collection;
}


declare interface $org$bukkit$plugin$TimedRegisteredListener {
  callEvent(arg0: org$bukkit$event$Event): void;
  reset(): void;
  getCount(): number;
  getTotalTime(): number;
  getEventClass(): any /* java.lang.Class */;
  hasMultiple(): boolean;
}

declare class org$bukkit$plugin$TimedRegisteredListener
  implements $org$bukkit$plugin$TimedRegisteredListener {
  constructor(
    arg0: org$bukkit$event$Listener,
    arg1: org$bukkit$plugin$EventExecutor,
    arg2: org$bukkit$event$EventPriority,
    arg3: org$bukkit$plugin$Plugin,
    arg4: boolean
  );
  callEvent(arg0: org$bukkit$event$Event): void;
  reset(): void;
  getCount(): number;
  getTotalTime(): number;
  getEventClass(): any /* java.lang.Class */;
  hasMultiple(): boolean;
}


declare interface $org$bukkit$plugin$UnknownDependencyException {}

declare class org$bukkit$plugin$UnknownDependencyException
  implements $org$bukkit$plugin$UnknownDependencyException {
  constructor(arg0: any /* java.lang.Throwable */);
  constructor(arg0: string);
  constructor(arg0: any /* java.lang.Throwable */, arg1: string);
  constructor();
}


declare interface $org$bukkit$potion$Potion {
  splash(): org$bukkit$potion$Potion;
  extend(): org$bukkit$potion$Potion;
  apply(arg0: org$bukkit$inventory$ItemStack): void;
  apply(arg0: org$bukkit$entity$LivingEntity): void;
  equals(arg0: any): boolean;
  getEffects(): java$util$Collection;
  getLevel(): number;
  getType(): org$bukkit$potion$PotionType;
  hasExtendedDuration(): boolean;
  hashCode(): number;
  isSplash(): boolean;
  setHasExtendedDuration(arg0: boolean): void;
  setSplash(arg0: boolean): void;
  setType(arg0: org$bukkit$potion$PotionType): void;
  setLevel(arg0: number): void;
  toDamageValue(): unknown;
  toItemStack(arg0: number): org$bukkit$inventory$ItemStack;
  getNameId(): number;
}

declare class org$bukkit$potion$Potion implements $org$bukkit$potion$Potion {
  constructor(arg0: org$bukkit$potion$PotionType);
  constructor(arg0: org$bukkit$potion$PotionType, arg1: number);
  constructor(arg0: org$bukkit$potion$PotionType, arg1: number, arg2: boolean);
  constructor(
    arg0: org$bukkit$potion$PotionType,
    arg1: number,
    arg2: boolean,
    arg3: boolean
  );
  splash(): org$bukkit$potion$Potion;
  extend(): org$bukkit$potion$Potion;
  apply(arg0: org$bukkit$inventory$ItemStack): void;
  apply(arg0: org$bukkit$entity$LivingEntity): void;
  equals(arg0: any): boolean;
  getEffects(): java$util$Collection;
  getLevel(): number;
  getType(): org$bukkit$potion$PotionType;
  hasExtendedDuration(): boolean;
  hashCode(): number;
  isSplash(): boolean;
  setHasExtendedDuration(arg0: boolean): void;
  setSplash(arg0: boolean): void;
  setType(arg0: org$bukkit$potion$PotionType): void;
  setLevel(arg0: number): void;
  toDamageValue(): unknown;
  toItemStack(arg0: number): org$bukkit$inventory$ItemStack;
  static fromDamage(arg0: number): org$bukkit$potion$Potion;
  static fromItemStack(
    arg0: org$bukkit$inventory$ItemStack
  ): org$bukkit$potion$Potion;
  static getBrewer(): org$bukkit$potion$PotionBrewer;
  static setPotionBrewer(arg0: org$bukkit$potion$PotionBrewer): void;
  getNameId(): number;
}


declare interface $org$bukkit$potion$PotionBrewer {
  createEffect(
    arg0: org$bukkit$potion$PotionEffectType,
    arg1: number,
    arg2: number
  ): org$bukkit$potion$PotionEffect;
  getEffectsFromDamage(arg0: number): java$util$Collection;
  getEffects(
    arg0: org$bukkit$potion$PotionType,
    arg1: boolean,
    arg2: boolean
  ): java$util$Collection;
}

declare class org$bukkit$potion$PotionBrewer
  implements $org$bukkit$potion$PotionBrewer {
  createEffect(
    arg0: org$bukkit$potion$PotionEffectType,
    arg1: number,
    arg2: number
  ): org$bukkit$potion$PotionEffect;
  getEffectsFromDamage(arg0: number): java$util$Collection;
  getEffects(
    arg0: org$bukkit$potion$PotionType,
    arg1: boolean,
    arg2: boolean
  ): java$util$Collection;
}


declare interface $org$bukkit$potion$PotionEffectTypeWrapper {
  getDurationModifier(): number;
  getName(): string;
  getType(): org$bukkit$potion$PotionEffectType;
  isInstant(): boolean;
  getColor(): org$bukkit$Color;
}

declare class org$bukkit$potion$PotionEffectTypeWrapper
  implements $org$bukkit$potion$PotionEffectTypeWrapper {
  constructor(arg0: number);
  getDurationModifier(): number;
  getName(): string;
  getType(): org$bukkit$potion$PotionEffectType;
  isInstant(): boolean;
  getColor(): org$bukkit$Color;
}


declare interface $org$bukkit$Registry {
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}

declare class org$bukkit$Registry implements $org$bukkit$Registry {
  static ADVANCEMENT: org$bukkit$Registry;
  static ART: org$bukkit$Registry;
  static BIOME: org$bukkit$Registry;
  static BOSS_BARS: org$bukkit$Registry;
  static ENCHANTMENT: org$bukkit$Registry;
  static ENTITY_TYPE: org$bukkit$Registry;
  static LOOT_TABLES: org$bukkit$Registry;
  static MATERIAL: org$bukkit$Registry;
  static STATISTIC: org$bukkit$Registry;
  static VILLAGER_PROFESSION: org$bukkit$Registry;
  static VILLAGER_TYPE: org$bukkit$Registry;
  static MEMORY_MODULE_TYPE: org$bukkit$Registry;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}


declare interface $org$bukkit$Registry$1 extends $org$bukkit$Registry {
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$advancement$Advancement;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}

declare class org$bukkit$Registry$1 implements $org$bukkit$Registry$1 {
  constructor();
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$advancement$Advancement;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
  static ADVANCEMENT: org$bukkit$Registry;
  static ART: org$bukkit$Registry;
  static BIOME: org$bukkit$Registry;
  static BOSS_BARS: org$bukkit$Registry;
  static ENCHANTMENT: org$bukkit$Registry;
  static ENTITY_TYPE: org$bukkit$Registry;
  static LOOT_TABLES: org$bukkit$Registry;
  static MATERIAL: org$bukkit$Registry;
  static STATISTIC: org$bukkit$Registry;
  static VILLAGER_PROFESSION: org$bukkit$Registry;
  static VILLAGER_TYPE: org$bukkit$Registry;
  static MEMORY_MODULE_TYPE: org$bukkit$Registry;
}


declare interface $org$bukkit$Registry$2 extends $org$bukkit$Registry {
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$boss$KeyedBossBar;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}

declare class org$bukkit$Registry$2 implements $org$bukkit$Registry$2 {
  constructor();
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$boss$KeyedBossBar;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
  static ADVANCEMENT: org$bukkit$Registry;
  static ART: org$bukkit$Registry;
  static BIOME: org$bukkit$Registry;
  static BOSS_BARS: org$bukkit$Registry;
  static ENCHANTMENT: org$bukkit$Registry;
  static ENTITY_TYPE: org$bukkit$Registry;
  static LOOT_TABLES: org$bukkit$Registry;
  static MATERIAL: org$bukkit$Registry;
  static STATISTIC: org$bukkit$Registry;
  static VILLAGER_PROFESSION: org$bukkit$Registry;
  static VILLAGER_TYPE: org$bukkit$Registry;
  static MEMORY_MODULE_TYPE: org$bukkit$Registry;
}


declare interface $org$bukkit$Registry$3 extends $org$bukkit$Registry {
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$enchantments$Enchantment;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}

declare class org$bukkit$Registry$3 implements $org$bukkit$Registry$3 {
  constructor();
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$enchantments$Enchantment;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
  static ADVANCEMENT: org$bukkit$Registry;
  static ART: org$bukkit$Registry;
  static BIOME: org$bukkit$Registry;
  static BOSS_BARS: org$bukkit$Registry;
  static ENCHANTMENT: org$bukkit$Registry;
  static ENTITY_TYPE: org$bukkit$Registry;
  static LOOT_TABLES: org$bukkit$Registry;
  static MATERIAL: org$bukkit$Registry;
  static STATISTIC: org$bukkit$Registry;
  static VILLAGER_PROFESSION: org$bukkit$Registry;
  static VILLAGER_TYPE: org$bukkit$Registry;
  static MEMORY_MODULE_TYPE: org$bukkit$Registry;
}


declare interface $org$bukkit$Registry$4 extends $org$bukkit$Registry {
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$entity$memory$MemoryKey;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}

declare class org$bukkit$Registry$4 implements $org$bukkit$Registry$4 {
  constructor();
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$entity$memory$MemoryKey;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
  static ADVANCEMENT: org$bukkit$Registry;
  static ART: org$bukkit$Registry;
  static BIOME: org$bukkit$Registry;
  static BOSS_BARS: org$bukkit$Registry;
  static ENCHANTMENT: org$bukkit$Registry;
  static ENTITY_TYPE: org$bukkit$Registry;
  static LOOT_TABLES: org$bukkit$Registry;
  static MATERIAL: org$bukkit$Registry;
  static STATISTIC: org$bukkit$Registry;
  static VILLAGER_PROFESSION: org$bukkit$Registry;
  static VILLAGER_TYPE: org$bukkit$Registry;
  static MEMORY_MODULE_TYPE: org$bukkit$Registry;
}


declare interface $org$bukkit$Registry$SimpleRegistry
  extends $org$bukkit$Registry {
  get(arg0: org$bukkit$NamespacedKey): any /* java.lang.Enum */;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
}

declare class org$bukkit$Registry$SimpleRegistry
  implements $org$bukkit$Registry$SimpleRegistry {
  constructor(arg0: any /* java.lang.Class */);
  constructor(
    arg0: any /* java.lang.Class */,
    arg1: any /* java.util.function.Predicate */
  );
  get(arg0: org$bukkit$NamespacedKey): any /* java.lang.Enum */;
  iterator(): any /* java.util.Iterator */;
  get(arg0: org$bukkit$NamespacedKey): org$bukkit$Keyed;
  static ADVANCEMENT: org$bukkit$Registry;
  static ART: org$bukkit$Registry;
  static BIOME: org$bukkit$Registry;
  static BOSS_BARS: org$bukkit$Registry;
  static ENCHANTMENT: org$bukkit$Registry;
  static ENTITY_TYPE: org$bukkit$Registry;
  static LOOT_TABLES: org$bukkit$Registry;
  static MATERIAL: org$bukkit$Registry;
  static STATISTIC: org$bukkit$Registry;
  static VILLAGER_PROFESSION: org$bukkit$Registry;
  static VILLAGER_TYPE: org$bukkit$Registry;
  static MEMORY_MODULE_TYPE: org$bukkit$Registry;
}


declare interface $org$bukkit$scheduler$BukkitWorker {
  getTaskId(): number;
  getOwner(): org$bukkit$plugin$Plugin;
  getThread(): any /* java.lang.Thread */;
}

declare class org$bukkit$scheduler$BukkitWorker
  implements $org$bukkit$scheduler$BukkitWorker {
  getTaskId(): number;
  getOwner(): org$bukkit$plugin$Plugin;
  getThread(): any /* java.lang.Thread */;
}


declare interface $org$bukkit$scoreboard$Criterias {}

declare class org$bukkit$scoreboard$Criterias
  implements $org$bukkit$scoreboard$Criterias {
  static HEALTH: string;
  static PLAYER_KILLS: string;
  static TOTAL_KILLS: string;
  static DEATHS: string;
}


declare interface $org$bukkit$UndefinedNullability {
  value(): string;
}

declare class org$bukkit$UndefinedNullability
  implements $org$bukkit$UndefinedNullability {
  value(): string;
}


declare interface $org$bukkit$util$BlockIterator {
  hasNext(): boolean;
  next(): org$bukkit$block$Block;
  remove(): void;
  next(): any;
}

declare class org$bukkit$util$BlockIterator
  implements $org$bukkit$util$BlockIterator {
  constructor(
    arg0: org$bukkit$World,
    arg1: org$bukkit$util$Vector,
    arg2: org$bukkit$util$Vector,
    arg3: number,
    arg4: number
  );
  constructor(arg0: org$bukkit$Location, arg1: number, arg2: number);
  constructor(arg0: org$bukkit$Location, arg1: number);
  constructor(arg0: org$bukkit$Location);
  constructor(arg0: org$bukkit$entity$LivingEntity, arg1: number);
  constructor(arg0: org$bukkit$entity$LivingEntity);
  hasNext(): boolean;
  next(): org$bukkit$block$Block;
  remove(): void;
  next(): any;
}


declare interface $org$bukkit$util$ChatPaginator {}

declare class org$bukkit$util$ChatPaginator
  implements $org$bukkit$util$ChatPaginator {
  static GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH: number;
  static AVERAGE_CHAT_PAGE_WIDTH: number;
  static UNBOUNDED_PAGE_WIDTH: number;
  static OPEN_CHAT_PAGE_HEIGHT: number;
  static CLOSED_CHAT_PAGE_HEIGHT: number;
  static UNBOUNDED_PAGE_HEIGHT: number;
  constructor();
  static paginate(
    arg0: string,
    arg1: number
  ): org$bukkit$util$ChatPaginator$ChatPage;
  static paginate(
    arg0: string,
    arg1: number,
    arg2: number,
    arg3: number
  ): org$bukkit$util$ChatPaginator$ChatPage;
  static wordWrap(arg0: string, arg1: number): JavaArray<string>;
}


declare interface $org$bukkit$util$ChatPaginator$ChatPage {
  getPageNumber(): number;
  getTotalPages(): number;
  getLines(): JavaArray<string>;
}

declare class org$bukkit$util$ChatPaginator$ChatPage
  implements $org$bukkit$util$ChatPaginator$ChatPage {
  constructor(arg0: JavaArray<string>, arg1: number, arg2: number);
  getPageNumber(): number;
  getTotalPages(): number;
  getLines(): JavaArray<string>;
}


declare interface $org$bukkit$util$FileUtil {}

declare class org$bukkit$util$FileUtil implements $org$bukkit$util$FileUtil {
  constructor();
  static copy(
    arg0: any /* java.io.File */,
    arg1: any /* java.io.File */
  ): boolean;
}


declare interface $org$bukkit$util$io$BukkitObjectInputStream {
  resolveObject(arg0: any): any;
}

declare class org$bukkit$util$io$BukkitObjectInputStream
  implements $org$bukkit$util$io$BukkitObjectInputStream {
  constructor();
  constructor(arg0: any /* java.io.InputStream */);
  resolveObject(arg0: any): any;
}


declare interface $org$bukkit$util$io$BukkitObjectOutputStream {
  replaceObject(arg0: any): any;
}

declare class org$bukkit$util$io$BukkitObjectOutputStream
  implements $org$bukkit$util$io$BukkitObjectOutputStream {
  constructor();
  constructor(arg0: any /* java.io.OutputStream */);
  replaceObject(arg0: any): any;
}


declare interface $org$bukkit$util$io$Wrapper {}

declare class org$bukkit$util$io$Wrapper
  implements $org$bukkit$util$io$Wrapper {
  static newWrapper(
    arg0: org$bukkit$configuration$serialization$ConfigurationSerializable
  ): org$bukkit$util$io$Wrapper;
}


declare interface $org$bukkit$util$noise$NoiseGenerator {
  noise(arg0: number): number;
  noise(arg0: number, arg1: number): number;
  noise(arg0: number, arg1: number, arg2: number): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: number): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: boolean
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: boolean
  ): number;
}

declare class org$bukkit$util$noise$NoiseGenerator
  implements $org$bukkit$util$noise$NoiseGenerator {
  constructor();
  static floor(arg0: number): number;
  static fade(arg0: number): number;
  static lerp(arg0: number, arg1: number, arg2: number): number;
  static grad(arg0: number, arg1: number, arg2: number, arg3: number): number;
  noise(arg0: number): number;
  noise(arg0: number, arg1: number): number;
  noise(arg0: number, arg1: number, arg2: number): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: number): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: boolean
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: boolean
  ): number;
}


declare interface $org$bukkit$util$noise$OctaveGenerator {
  setScale(arg0: number): void;
  getXScale(): number;
  setXScale(arg0: number): void;
  getYScale(): number;
  setYScale(arg0: number): void;
  getZScale(): number;
  setZScale(arg0: number): void;
  getOctaves(): JavaArray<org$bukkit$util$noise$NoiseGenerator>;
  noise(arg0: number, arg1: number, arg2: number): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: boolean): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: number): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: boolean
  ): number;
}

declare class org$bukkit$util$noise$OctaveGenerator
  implements $org$bukkit$util$noise$OctaveGenerator {
  constructor(arg0: JavaArray<org$bukkit$util$noise$NoiseGenerator>);
  setScale(arg0: number): void;
  getXScale(): number;
  setXScale(arg0: number): void;
  getYScale(): number;
  setYScale(arg0: number): void;
  getZScale(): number;
  setZScale(arg0: number): void;
  getOctaves(): JavaArray<org$bukkit$util$noise$NoiseGenerator>;
  noise(arg0: number, arg1: number, arg2: number): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: boolean): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: number): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: boolean
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: boolean
  ): number;
}


declare interface $org$bukkit$util$noise$PerlinNoiseGenerator {
  noise(arg0: number, arg1: number, arg2: number): number;
}

declare class org$bukkit$util$noise$PerlinNoiseGenerator
  implements $org$bukkit$util$noise$PerlinNoiseGenerator {
  constructor();
  constructor(arg0: org$bukkit$World);
  constructor(arg0: number);
  constructor(arg0: any /* java.util.Random */);
  static getNoise(arg0: number): number;
  static getNoise(arg0: number, arg1: number): number;
  static getNoise(arg0: number, arg1: number, arg2: number): number;
  static getInstance(): org$bukkit$util$noise$PerlinNoiseGenerator;
  noise(arg0: number, arg1: number, arg2: number): number;
  static getNoise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number
  ): number;
  static getNoise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): number;
  static getNoise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): number;
}


declare interface $org$bukkit$util$noise$PerlinOctaveGenerator {}

declare class org$bukkit$util$noise$PerlinOctaveGenerator
  implements $org$bukkit$util$noise$PerlinOctaveGenerator {
  constructor(arg0: org$bukkit$World, arg1: number);
  constructor(arg0: number, arg1: number);
  constructor(arg0: any /* java.util.Random */, arg1: number);
}


declare interface $org$bukkit$util$noise$SimplexNoiseGenerator {
  noise(arg0: number, arg1: number, arg2: number): number;
  noise(arg0: number, arg1: number): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: number): number;
}

declare class org$bukkit$util$noise$SimplexNoiseGenerator
  implements $org$bukkit$util$noise$SimplexNoiseGenerator {
  constructor();
  constructor(arg0: org$bukkit$World);
  constructor(arg0: number);
  constructor(arg0: any /* java.util.Random */);
  static dot(arg0: JavaArray<number>, arg1: number, arg2: number): number;
  static dot(
    arg0: JavaArray<number>,
    arg1: number,
    arg2: number,
    arg3: number
  ): number;
  static dot(
    arg0: JavaArray<number>,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number
  ): number;
  static getNoise(arg0: number): number;
  static getNoise(arg0: number, arg1: number): number;
  static getNoise(arg0: number, arg1: number, arg2: number): number;
  static getNoise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number
  ): number;
  noise(arg0: number, arg1: number, arg2: number): number;
  noise(arg0: number, arg1: number): number;
  noise(arg0: number, arg1: number, arg2: number, arg3: number): number;
  static getInstance(): org$bukkit$util$noise$SimplexNoiseGenerator;
}


declare interface $org$bukkit$util$noise$SimplexOctaveGenerator {
  setScale(arg0: number): void;
  getWScale(): number;
  setWScale(arg0: number): void;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: boolean
  ): number;
}

declare class org$bukkit$util$noise$SimplexOctaveGenerator
  implements $org$bukkit$util$noise$SimplexOctaveGenerator {
  constructor(arg0: org$bukkit$World, arg1: number);
  constructor(arg0: number, arg1: number);
  constructor(arg0: any /* java.util.Random */, arg1: number);
  setScale(arg0: number): void;
  getWScale(): number;
  setWScale(arg0: number): void;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number
  ): number;
  noise(
    arg0: number,
    arg1: number,
    arg2: number,
    arg3: number,
    arg4: number,
    arg5: number,
    arg6: boolean
  ): number;
}


declare interface $org$bukkit$util$NumberConversions {}

declare class org$bukkit$util$NumberConversions
  implements $org$bukkit$util$NumberConversions {
  static floor(arg0: number): number;
  static ceil(arg0: number): number;
  static round(arg0: number): number;
  static square(arg0: number): number;
  static toInt(arg0: any): number;
  static toFloat(arg0: any): number;
  static toDouble(arg0: any): number;
  static toLong(arg0: any): number;
  static toShort(arg0: any): unknown;
  static toByte(arg0: any): Buffer;
  static isFinite(arg0: number): boolean;
  static checkFinite(arg0: number, arg1: string): void;
}


declare interface $org$bukkit$util$permissions$BroadcastPermissions {}

declare class org$bukkit$util$permissions$BroadcastPermissions
  implements $org$bukkit$util$permissions$BroadcastPermissions {
  static registerPermissions(
    arg0: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
}


declare interface $org$bukkit$util$permissions$CommandPermissions {}

declare class org$bukkit$util$permissions$CommandPermissions
  implements $org$bukkit$util$permissions$CommandPermissions {
  static registerPermissions(
    arg0: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
}


declare interface $org$bukkit$util$permissions$DefaultPermissions {}

declare class org$bukkit$util$permissions$DefaultPermissions
  implements $org$bukkit$util$permissions$DefaultPermissions {
  static registerPermission(
    arg0: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: org$bukkit$permissions$Permission,
    arg1: boolean
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: org$bukkit$permissions$Permission,
    arg1: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: string,
    arg1: string
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault,
    arg3: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault,
    arg3: any /* java.util.Map */
  ): org$bukkit$permissions$Permission;
  static registerPermission(
    arg0: string,
    arg1: string,
    arg2: org$bukkit$permissions$PermissionDefault,
    arg3: any /* java.util.Map */,
    arg4: org$bukkit$permissions$Permission
  ): org$bukkit$permissions$Permission;
  static registerCorePermissions(): void;
}


declare interface $org$bukkit$util$StringUtil {}

declare class org$bukkit$util$StringUtil
  implements $org$bukkit$util$StringUtil {
  constructor();
  static copyPartialMatches(
    arg0: string,
    arg1: any /* java.lang.Iterable */,
    arg2: java$util$Collection
  ): java$util$Collection;
  static startsWithIgnoreCase(arg0: string, arg1: string): boolean;
}


declare interface $org$bukkit$Utility {}

declare class org$bukkit$Utility implements $org$bukkit$Utility {}


declare interface $org$spigotmc$CustomTimingsHandler {
  startTiming(): void;
  stopTiming(): void;
}

declare class org$spigotmc$CustomTimingsHandler
  implements $org$spigotmc$CustomTimingsHandler {
  constructor(arg0: string);
  startTiming(): void;
  stopTiming(): void;
}


declare interface $org$spigotmc$event$entity$EntityDismountEvent
  extends $org$bukkit$event$Cancellable {
  getDismounted(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isCancellable(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$spigotmc$event$entity$EntityDismountEvent
  implements $org$spigotmc$event$entity$EntityDismountEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$entity$Entity);
  constructor(
    arg0: org$bukkit$entity$Entity,
    arg1: org$bukkit$entity$Entity,
    arg2: boolean
  );
  getDismounted(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  isCancellable(): boolean;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$spigotmc$event$entity$EntityMountEvent
  extends $org$bukkit$event$Cancellable {
  getMount(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$spigotmc$event$entity$EntityMountEvent
  implements $org$spigotmc$event$entity$EntityMountEvent {
  constructor(arg0: org$bukkit$entity$Entity, arg1: org$bukkit$entity$Entity);
  getMount(): org$bukkit$entity$Entity;
  isCancelled(): boolean;
  setCancelled(arg0: boolean): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare interface $org$spigotmc$event$player$PlayerSpawnLocationEvent {
  getSpawnLocation(): org$bukkit$Location;
  setSpawnLocation(arg0: org$bukkit$Location): void;
  getHandlers(): org$bukkit$event$HandlerList;
}

declare class org$spigotmc$event$player$PlayerSpawnLocationEvent
  implements $org$spigotmc$event$player$PlayerSpawnLocationEvent {
  constructor(arg0: org$bukkit$entity$Player, arg1: org$bukkit$Location);
  getSpawnLocation(): org$bukkit$Location;
  setSpawnLocation(arg0: org$bukkit$Location): void;
  getHandlers(): org$bukkit$event$HandlerList;
  static getHandlerList(): org$bukkit$event$HandlerList;
}


declare type JavaArray<Element> = {
  isJavaArray: true;
};

declare let Java: {
  from<T>(array: JavaArray<T>): T[];

  type(
    classname: "co.aikar.timings.FullServerTickHandler"
  ): typeof co$aikar$timings$FullServerTickHandler;
  type(classname: "co.aikar.timings.Timing"): typeof co$aikar$timings$Timing;
  type(
    classname: "co.aikar.timings.TimingHandler"
  ): typeof co$aikar$timings$TimingHandler;
  type(
    classname: "co.aikar.timings.TimingIdentifier"
  ): typeof co$aikar$timings$TimingIdentifier;
  type(
    classname: "co.aikar.timings.TimingIdentifier$TimingGroup"
  ): typeof co$aikar$timings$TimingIdentifier$TimingGroup;
  type(
    classname: "co.aikar.timings.TimingIdentifier$1"
  ): typeof co$aikar$timings$TimingIdentifier$1;
  type(
    classname: "co.aikar.timings.TimingData"
  ): typeof co$aikar$timings$TimingData;
  type(
    classname: "co.aikar.timings.NullTimingHandler"
  ): typeof co$aikar$timings$NullTimingHandler;
  type(
    classname: "co.aikar.timings.TimedEventExecutor"
  ): typeof co$aikar$timings$TimedEventExecutor;
  type(
    classname: "org.bukkit.plugin.EventExecutor"
  ): typeof org$bukkit$plugin$EventExecutor;
  type(
    classname: "org.bukkit.event.Listener"
  ): typeof org$bukkit$event$Listener;
  type(classname: "org.bukkit.event.Event"): typeof org$bukkit$event$Event;
  type(
    classname: "org.bukkit.event.HandlerList"
  ): typeof org$bukkit$event$HandlerList;
  type(classname: "org.bukkit.plugin.Plugin"): typeof org$bukkit$plugin$Plugin;
  type(
    classname: "org.bukkit.command.CommandExecutor"
  ): typeof org$bukkit$command$CommandExecutor;
  type(
    classname: "org.bukkit.command.CommandSender"
  ): typeof org$bukkit$command$CommandSender;
  type(
    classname: "org.bukkit.permissions.Permissible"
  ): typeof org$bukkit$permissions$Permissible;
  type(
    classname: "org.bukkit.permissions.ServerOperator"
  ): typeof org$bukkit$permissions$ServerOperator;
  type(
    classname: "org.bukkit.permissions.Permission"
  ): typeof org$bukkit$permissions$Permission;
  type(
    classname: "org.bukkit.permissions.PermissionDefault"
  ): typeof org$bukkit$permissions$PermissionDefault;
  type(
    classname: "org.bukkit.permissions.PermissionAttachment"
  ): typeof org$bukkit$permissions$PermissionAttachment;
  type(
    classname: "org.bukkit.permissions.PermissionRemovedExecutor"
  ): typeof org$bukkit$permissions$PermissionRemovedExecutor;
  type(classname: "org.bukkit.Server"): typeof org$bukkit$Server;
  type(
    classname: "org.bukkit.plugin.messaging.PluginMessageRecipient"
  ): typeof org$bukkit$plugin$messaging$PluginMessageRecipient;
  type(classname: "java.util.Collection"): typeof java$util$Collection;
  type(classname: "org.bukkit.entity.Player"): typeof org$bukkit$entity$Player;
  type(
    classname: "com.destroystokyo.paper.network.NetworkClient"
  ): typeof com$destroystokyo$paper$network$NetworkClient;
  type(classname: "org.bukkit.Nameable"): typeof org$bukkit$Nameable;
  type(classname: "org.bukkit.OfflinePlayer"): typeof org$bukkit$OfflinePlayer;
  type(
    classname: "org.bukkit.configuration.serialization.ConfigurationSerializable"
  ): typeof org$bukkit$configuration$serialization$ConfigurationSerializable;
  type(
    classname: "org.bukkit.entity.AnimalTamer"
  ): typeof org$bukkit$entity$AnimalTamer;
  type(classname: "org.bukkit.BanEntry"): typeof org$bukkit$BanEntry;
  type(classname: "org.bukkit.Location"): typeof org$bukkit$Location;
  type(classname: "org.bukkit.World"): typeof org$bukkit$World;
  type(
    classname: "org.bukkit.metadata.Metadatable"
  ): typeof org$bukkit$metadata$Metadatable;
  type(
    classname: "org.bukkit.metadata.MetadataValue"
  ): typeof org$bukkit$metadata$MetadataValue;
  type(classname: "org.bukkit.block.Block"): typeof org$bukkit$block$Block;
  type(
    classname: "org.bukkit.block.data.BlockData"
  ): typeof org$bukkit$block$data$BlockData;
  type(classname: "org.bukkit.Material"): typeof org$bukkit$Material;
  type(classname: "org.bukkit.Keyed"): typeof org$bukkit$Keyed;
  type(classname: "org.bukkit.NamespacedKey"): typeof org$bukkit$NamespacedKey;
  type(
    classname: "com.destroystokyo.paper.Namespaced"
  ): typeof com$destroystokyo$paper$Namespaced;
  type(
    classname: "org.bukkit.material.MaterialData"
  ): typeof org$bukkit$material$MaterialData;
  type(
    classname: "org.bukkit.inventory.ItemStack"
  ): typeof org$bukkit$inventory$ItemStack;
  type(
    classname: "org.bukkit.enchantments.Enchantment"
  ): typeof org$bukkit$enchantments$Enchantment;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget"
  ): typeof org$bukkit$enchantments$EnchantmentTarget;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$1"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$1;
  type(
    classname: "org.bukkit.inventory.meta.ItemMeta"
  ): typeof org$bukkit$inventory$meta$ItemMeta;
  type(
    classname: "org.bukkit.persistence.PersistentDataHolder"
  ): typeof org$bukkit$persistence$PersistentDataHolder;
  type(
    classname: "org.bukkit.persistence.PersistentDataContainer"
  ): typeof org$bukkit$persistence$PersistentDataContainer;
  type(
    classname: "org.bukkit.persistence.PersistentDataType"
  ): typeof org$bukkit$persistence$PersistentDataType;
  type(
    classname: "org.bukkit.persistence.PersistentDataAdapterContext"
  ): typeof org$bukkit$persistence$PersistentDataAdapterContext;
  type(
    classname: "org.bukkit.inventory.ItemFlag"
  ): typeof org$bukkit$inventory$ItemFlag;
  type(
    classname: "com.google.common.collect.Multimap"
  ): typeof com$google$common$collect$Multimap;
  type(
    classname: "com.google.common.collect.Multiset"
  ): typeof com$google$common$collect$Multiset;
  type(
    classname: "org.bukkit.inventory.EquipmentSlot"
  ): typeof org$bukkit$inventory$EquipmentSlot;
  type(
    classname: "org.bukkit.attribute.Attribute"
  ): typeof org$bukkit$attribute$Attribute;
  type(
    classname: "org.bukkit.attribute.AttributeModifier"
  ): typeof org$bukkit$attribute$AttributeModifier;
  type(
    classname: "org.bukkit.attribute.AttributeModifier$Operation"
  ): typeof org$bukkit$attribute$AttributeModifier$Operation;
  type(
    classname: "org.bukkit.inventory.meta.tags.CustomItemTagContainer"
  ): typeof org$bukkit$inventory$meta$tags$CustomItemTagContainer;
  type(
    classname: "org.bukkit.inventory.meta.tags.ItemTagType"
  ): typeof org$bukkit$inventory$meta$tags$ItemTagType;
  type(
    classname: "org.bukkit.inventory.meta.tags.ItemTagAdapterContext"
  ): typeof org$bukkit$inventory$meta$tags$ItemTagAdapterContext;
  type(
    classname: "org.bukkit.block.BlockFace"
  ): typeof org$bukkit$block$BlockFace;
  type(classname: "org.bukkit.util.Vector"): typeof org$bukkit$util$Vector;
  type(
    classname: "org.bukkit.util.BlockVector"
  ): typeof org$bukkit$util$BlockVector;
  type(classname: "org.bukkit.Chunk"): typeof org$bukkit$Chunk;
  type(classname: "org.bukkit.ChunkSnapshot"): typeof org$bukkit$ChunkSnapshot;
  type(classname: "org.bukkit.block.Biome"): typeof org$bukkit$block$Biome;
  type(classname: "org.bukkit.entity.Entity"): typeof org$bukkit$entity$Entity;
  type(
    classname: "org.bukkit.util.BoundingBox"
  ): typeof org$bukkit$util$BoundingBox;
  type(
    classname: "org.bukkit.util.RayTraceResult"
  ): typeof org$bukkit$util$RayTraceResult;
  type(
    classname: "org.bukkit.event.player.PlayerTeleportEvent$TeleportCause"
  ): typeof org$bukkit$event$player$PlayerTeleportEvent$TeleportCause;
  type(
    classname: "org.bukkit.event.entity.EntityDamageEvent"
  ): typeof org$bukkit$event$entity$EntityDamageEvent;
  type(
    classname: "org.bukkit.event.Cancellable"
  ): typeof org$bukkit$event$Cancellable;
  type(
    classname: "org.bukkit.event.entity.EntityDamageEvent$DamageCause"
  ): typeof org$bukkit$event$entity$EntityDamageEvent$DamageCause;
  type(
    classname: "org.bukkit.event.entity.EntityDamageEvent$DamageModifier"
  ): typeof org$bukkit$event$entity$EntityDamageEvent$DamageModifier;
  type(
    classname: "com.google.common.base.Function"
  ): typeof com$google$common$base$Function;
  type(classname: "org.bukkit.EntityEffect"): typeof org$bukkit$EntityEffect;
  type(
    classname: "org.bukkit.entity.EntityType"
  ): typeof org$bukkit$entity$EntityType;
  type(
    classname: "org.bukkit.block.PistonMoveReaction"
  ): typeof org$bukkit$block$PistonMoveReaction;
  type(classname: "org.bukkit.entity.Pose"): typeof org$bukkit$entity$Pose;
  type(
    classname: "org.bukkit.entity.Entity$Spigot"
  ): typeof org$bukkit$entity$Entity$Spigot;
  type(
    classname: "org.bukkit.event.entity.CreatureSpawnEvent$SpawnReason"
  ): typeof org$bukkit$event$entity$CreatureSpawnEvent$SpawnReason;
  type(
    classname: "org.bukkit.command.CommandSender$Spigot"
  ): typeof org$bukkit$command$CommandSender$Spigot;
  type(
    classname: "org.bukkit.block.BlockState"
  ): typeof org$bukkit$block$BlockState;
  type(
    classname: "org.bukkit.FluidCollisionMode"
  ): typeof org$bukkit$FluidCollisionMode;
  type(
    classname: "com.destroystokyo.paper.block.BlockSoundGroup"
  ): typeof com$destroystokyo$paper$block$BlockSoundGroup;
  type(classname: "org.bukkit.Sound"): typeof org$bukkit$Sound;
  type(
    classname: "com.destroystokyo.paper.HeightmapType"
  ): typeof com$destroystokyo$paper$HeightmapType;
  type(classname: "org.bukkit.HeightMap"): typeof org$bukkit$HeightMap;
  type(
    classname: "org.bukkit.World$ChunkLoadCallback"
  ): typeof org$bukkit$World$ChunkLoadCallback;
  type(classname: "org.bukkit.entity.Item"): typeof org$bukkit$entity$Item;
  type(classname: "org.bukkit.entity.Arrow"): typeof org$bukkit$entity$Arrow;
  type(
    classname: "org.bukkit.entity.AbstractArrow"
  ): typeof org$bukkit$entity$AbstractArrow;
  type(
    classname: "org.bukkit.entity.Projectile"
  ): typeof org$bukkit$entity$Projectile;
  type(
    classname: "org.bukkit.projectiles.ProjectileSource"
  ): typeof org$bukkit$projectiles$ProjectileSource;
  type(
    classname: "org.bukkit.entity.AbstractArrow$PickupStatus"
  ): typeof org$bukkit$entity$AbstractArrow$PickupStatus;
  type(
    classname: "org.bukkit.entity.AbstractArrow$PickupRule"
  ): typeof org$bukkit$entity$AbstractArrow$PickupRule;
  type(
    classname: "org.bukkit.potion.PotionData"
  ): typeof org$bukkit$potion$PotionData;
  type(
    classname: "org.bukkit.potion.PotionType"
  ): typeof org$bukkit$potion$PotionType;
  type(
    classname: "org.bukkit.potion.PotionEffectType"
  ): typeof org$bukkit$potion$PotionEffectType;
  type(
    classname: "org.bukkit.potion.PotionEffect"
  ): typeof org$bukkit$potion$PotionEffect;
  type(
    classname: "org.bukkit.entity.LivingEntity"
  ): typeof org$bukkit$entity$LivingEntity;
  type(
    classname: "org.bukkit.attribute.Attributable"
  ): typeof org$bukkit$attribute$Attributable;
  type(
    classname: "org.bukkit.attribute.AttributeInstance"
  ): typeof org$bukkit$attribute$AttributeInstance;
  type(
    classname: "org.bukkit.entity.Damageable"
  ): typeof org$bukkit$entity$Damageable;
  type(
    classname: "com.destroystokyo.paper.block.TargetBlockInfo$FluidMode"
  ): typeof com$destroystokyo$paper$block$TargetBlockInfo$FluidMode;
  type(
    classname: "com.destroystokyo.paper.block.TargetBlockInfo"
  ): typeof com$destroystokyo$paper$block$TargetBlockInfo;
  type(
    classname: "com.destroystokyo.paper.entity.TargetEntityInfo"
  ): typeof com$destroystokyo$paper$entity$TargetEntityInfo;
  type(
    classname: "org.bukkit.inventory.EntityEquipment"
  ): typeof org$bukkit$inventory$EntityEquipment;
  type(
    classname: "org.bukkit.entity.memory.MemoryKey"
  ): typeof org$bukkit$entity$memory$MemoryKey;
  type(classname: "org.bukkit.Color"): typeof org$bukkit$Color;
  type(classname: "org.bukkit.DyeColor"): typeof org$bukkit$DyeColor;
  type(classname: "org.bukkit.TreeType"): typeof org$bukkit$TreeType;
  type(
    classname: "org.bukkit.BlockChangeDelegate"
  ): typeof org$bukkit$BlockChangeDelegate;
  type(
    classname: "org.bukkit.entity.LightningStrike"
  ): typeof org$bukkit$entity$LightningStrike;
  type(
    classname: "org.bukkit.entity.LightningStrike$Spigot"
  ): typeof org$bukkit$entity$LightningStrike$Spigot;
  type(
    classname: "org.bukkit.World$Environment"
  ): typeof org$bukkit$World$Environment;
  type(
    classname: "org.bukkit.generator.ChunkGenerator"
  ): typeof org$bukkit$generator$ChunkGenerator;
  type(
    classname: "org.bukkit.generator.ChunkGenerator$ChunkData"
  ): typeof org$bukkit$generator$ChunkGenerator$ChunkData;
  type(
    classname: "org.bukkit.generator.ChunkGenerator$BiomeGrid"
  ): typeof org$bukkit$generator$ChunkGenerator$BiomeGrid;
  type(classname: "org.bukkit.util.Consumer"): typeof org$bukkit$util$Consumer;
  type(
    classname: "org.bukkit.entity.FallingBlock"
  ): typeof org$bukkit$entity$FallingBlock;
  type(classname: "org.bukkit.Effect"): typeof org$bukkit$Effect;
  type(classname: "org.bukkit.Effect$Type"): typeof org$bukkit$Effect$Type;
  type(classname: "org.bukkit.Difficulty"): typeof org$bukkit$Difficulty;
  type(classname: "org.bukkit.WorldType"): typeof org$bukkit$WorldType;
  type(classname: "org.bukkit.SoundCategory"): typeof org$bukkit$SoundCategory;
  type(classname: "org.bukkit.GameRule"): typeof org$bukkit$GameRule;
  type(classname: "org.bukkit.WorldBorder"): typeof org$bukkit$WorldBorder;
  type(classname: "org.bukkit.Particle"): typeof org$bukkit$Particle;
  type(
    classname: "com.destroystokyo.paper.ParticleBuilder"
  ): typeof com$destroystokyo$paper$ParticleBuilder;
  type(classname: "org.bukkit.StructureType"): typeof org$bukkit$StructureType;
  type(
    classname: "org.bukkit.map.MapCursor$Type"
  ): typeof org$bukkit$map$MapCursor$Type;
  type(classname: "org.bukkit.World$Spigot"): typeof org$bukkit$World$Spigot;
  type(classname: "org.bukkit.Raid"): typeof org$bukkit$Raid;
  type(
    classname: "org.bukkit.Raid$RaidStatus"
  ): typeof org$bukkit$Raid$RaidStatus;
  type(
    classname: "org.bukkit.boss.DragonBattle"
  ): typeof org$bukkit$boss$DragonBattle;
  type(
    classname: "org.bukkit.entity.EnderDragon"
  ): typeof org$bukkit$entity$EnderDragon;
  type(classname: "org.bukkit.entity.Boss"): typeof org$bukkit$entity$Boss;
  type(classname: "org.bukkit.boss.BossBar"): typeof org$bukkit$boss$BossBar;
  type(classname: "org.bukkit.boss.BarColor"): typeof org$bukkit$boss$BarColor;
  type(classname: "org.bukkit.boss.BarStyle"): typeof org$bukkit$boss$BarStyle;
  type(classname: "org.bukkit.boss.BarFlag"): typeof org$bukkit$boss$BarFlag;
  type(
    classname: "org.bukkit.entity.ComplexLivingEntity"
  ): typeof org$bukkit$entity$ComplexLivingEntity;
  type(classname: "org.bukkit.entity.Mob"): typeof org$bukkit$entity$Mob;
  type(classname: "org.bukkit.loot.Lootable"): typeof org$bukkit$loot$Lootable;
  type(
    classname: "org.bukkit.loot.LootTable"
  ): typeof org$bukkit$loot$LootTable;
  type(
    classname: "org.bukkit.loot.LootContext"
  ): typeof org$bukkit$loot$LootContext;
  type(
    classname: "org.bukkit.entity.HumanEntity"
  ): typeof org$bukkit$entity$HumanEntity;
  type(
    classname: "org.bukkit.inventory.InventoryHolder"
  ): typeof org$bukkit$inventory$InventoryHolder;
  type(
    classname: "org.bukkit.inventory.Inventory"
  ): typeof org$bukkit$inventory$Inventory;
  type(
    classname: "org.bukkit.event.inventory.InventoryType"
  ): typeof org$bukkit$event$inventory$InventoryType;
  type(
    classname: "org.bukkit.inventory.PlayerInventory"
  ): typeof org$bukkit$inventory$PlayerInventory;
  type(
    classname: "org.bukkit.inventory.MainHand"
  ): typeof org$bukkit$inventory$MainHand;
  type(
    classname: "org.bukkit.inventory.InventoryView$Property"
  ): typeof org$bukkit$inventory$InventoryView$Property;
  type(
    classname: "org.bukkit.inventory.InventoryView"
  ): typeof org$bukkit$inventory$InventoryView;
  type(
    classname: "org.bukkit.event.inventory.InventoryType$SlotType"
  ): typeof org$bukkit$event$inventory$InventoryType$SlotType;
  type(
    classname: "org.bukkit.entity.Villager"
  ): typeof org$bukkit$entity$Villager;
  type(
    classname: "org.bukkit.entity.AbstractVillager"
  ): typeof org$bukkit$entity$AbstractVillager;
  type(
    classname: "org.bukkit.entity.Ageable"
  ): typeof org$bukkit$entity$Ageable;
  type(
    classname: "org.bukkit.entity.Creature"
  ): typeof org$bukkit$entity$Creature;
  type(classname: "org.bukkit.entity.NPC"): typeof org$bukkit$entity$NPC;
  type(
    classname: "org.bukkit.inventory.Merchant"
  ): typeof org$bukkit$inventory$Merchant;
  type(
    classname: "org.bukkit.inventory.MerchantRecipe"
  ): typeof org$bukkit$inventory$MerchantRecipe;
  type(
    classname: "org.bukkit.inventory.Recipe"
  ): typeof org$bukkit$inventory$Recipe;
  type(
    classname: "org.bukkit.entity.Villager$Profession"
  ): typeof org$bukkit$entity$Villager$Profession;
  type(
    classname: "org.bukkit.entity.Villager$Type"
  ): typeof org$bukkit$entity$Villager$Type;
  type(
    classname: "com.destroystokyo.paper.entity.villager.Reputation"
  ): typeof com$destroystokyo$paper$entity$villager$Reputation;
  type(
    classname: "com.destroystokyo.paper.entity.villager.ReputationType"
  ): typeof com$destroystokyo$paper$entity$villager$ReputationType;
  type(
    classname: "org.bukkit.event.inventory.InventoryCloseEvent$Reason"
  ): typeof org$bukkit$event$inventory$InventoryCloseEvent$Reason;
  type(classname: "org.bukkit.GameMode"): typeof org$bukkit$GameMode;
  type(classname: "org.bukkit.block.Sign"): typeof org$bukkit$block$Sign;
  type(
    classname: "org.bukkit.block.TileState"
  ): typeof org$bukkit$block$TileState;
  type(
    classname: "org.bukkit.material.Colorable"
  ): typeof org$bukkit$material$Colorable;
  type(
    classname: "org.bukkit.loot.LootContext$1"
  ): typeof org$bukkit$loot$LootContext$1;
  type(
    classname: "com.destroystokyo.paper.entity.Pathfinder"
  ): typeof com$destroystokyo$paper$entity$Pathfinder;
  type(
    classname: "com.destroystokyo.paper.entity.Pathfinder$PathResult"
  ): typeof com$destroystokyo$paper$entity$Pathfinder$PathResult;
  type(
    classname: "org.bukkit.entity.EnderDragon$Phase"
  ): typeof org$bukkit$entity$EnderDragon$Phase;
  type(
    classname: "org.bukkit.boss.DragonBattle$RespawnPhase"
  ): typeof org$bukkit$boss$DragonBattle$RespawnPhase;
  type(classname: "org.bukkit.Statistic"): typeof org$bukkit$Statistic;
  type(
    classname: "org.bukkit.Statistic$Type"
  ): typeof org$bukkit$Statistic$Type;
  type(
    classname: "org.bukkit.conversations.Conversable"
  ): typeof org$bukkit$conversations$Conversable;
  type(
    classname: "org.bukkit.conversations.Conversation"
  ): typeof org$bukkit$conversations$Conversation;
  type(
    classname: "org.bukkit.conversations.Prompt"
  ): typeof org$bukkit$conversations$Prompt;
  type(
    classname: "org.bukkit.conversations.ConversationContext"
  ): typeof org$bukkit$conversations$ConversationContext;
  type(
    classname: "org.bukkit.conversations.ConversationPrefix"
  ): typeof org$bukkit$conversations$ConversationPrefix;
  type(
    classname: "org.bukkit.conversations.ConversationCanceller"
  ): typeof org$bukkit$conversations$ConversationCanceller;
  type(
    classname: "org.bukkit.conversations.Conversation$ConversationState"
  ): typeof org$bukkit$conversations$Conversation$ConversationState;
  type(
    classname: "org.bukkit.conversations.ConversationAbandonedListener"
  ): typeof org$bukkit$conversations$ConversationAbandonedListener;
  type(
    classname: "org.bukkit.conversations.ConversationAbandonedEvent"
  ): typeof org$bukkit$conversations$ConversationAbandonedEvent;
  type(classname: "org.bukkit.Instrument"): typeof org$bukkit$Instrument;
  type(classname: "org.bukkit.Note"): typeof org$bukkit$Note;
  type(classname: "org.bukkit.Note$Tone"): typeof org$bukkit$Note$Tone;
  type(classname: "org.bukkit.map.MapView"): typeof org$bukkit$map$MapView;
  type(
    classname: "org.bukkit.map.MapView$Scale"
  ): typeof org$bukkit$map$MapView$Scale;
  type(
    classname: "org.bukkit.map.MapRenderer"
  ): typeof org$bukkit$map$MapRenderer;
  type(classname: "org.bukkit.map.MapCanvas"): typeof org$bukkit$map$MapCanvas;
  type(
    classname: "org.bukkit.map.MapCursorCollection"
  ): typeof org$bukkit$map$MapCursorCollection;
  type(classname: "org.bukkit.map.MapCursor"): typeof org$bukkit$map$MapCursor;
  type(classname: "org.bukkit.map.MapFont"): typeof org$bukkit$map$MapFont;
  type(
    classname: "org.bukkit.map.MapFont$CharacterSprite"
  ): typeof org$bukkit$map$MapFont$CharacterSprite;
  type(
    classname: "com.destroystokyo.paper.Title"
  ): typeof com$destroystokyo$paper$Title;
  type(
    classname: "com.destroystokyo.paper.Title$Builder"
  ): typeof com$destroystokyo$paper$Title$Builder;
  type(classname: "org.bukkit.WeatherType"): typeof org$bukkit$WeatherType;
  type(
    classname: "org.bukkit.scoreboard.Scoreboard"
  ): typeof org$bukkit$scoreboard$Scoreboard;
  type(
    classname: "org.bukkit.scoreboard.Objective"
  ): typeof org$bukkit$scoreboard$Objective;
  type(
    classname: "org.bukkit.scoreboard.DisplaySlot"
  ): typeof org$bukkit$scoreboard$DisplaySlot;
  type(
    classname: "org.bukkit.scoreboard.RenderType"
  ): typeof org$bukkit$scoreboard$RenderType;
  type(
    classname: "org.bukkit.scoreboard.Score"
  ): typeof org$bukkit$scoreboard$Score;
  type(
    classname: "org.bukkit.scoreboard.Team"
  ): typeof org$bukkit$scoreboard$Team;
  type(classname: "org.bukkit.ChatColor"): typeof org$bukkit$ChatColor;
  type(classname: "org.bukkit.ChatColor$1"): typeof org$bukkit$ChatColor$1;
  type(
    classname: "org.bukkit.scoreboard.NameTagVisibility"
  ): typeof org$bukkit$scoreboard$NameTagVisibility;
  type(
    classname: "org.bukkit.scoreboard.Team$OptionStatus"
  ): typeof org$bukkit$scoreboard$Team$OptionStatus;
  type(
    classname: "org.bukkit.scoreboard.Team$Option"
  ): typeof org$bukkit$scoreboard$Team$Option;
  type(
    classname: "org.bukkit.advancement.AdvancementProgress"
  ): typeof org$bukkit$advancement$AdvancementProgress;
  type(
    classname: "org.bukkit.advancement.Advancement"
  ): typeof org$bukkit$advancement$Advancement;
  type(
    classname: "org.bukkit.event.player.PlayerResourcePackStatusEvent$Status"
  ): typeof org$bukkit$event$player$PlayerResourcePackStatusEvent$Status;
  type(
    classname: "com.destroystokyo.paper.profile.PlayerProfile"
  ): typeof com$destroystokyo$paper$profile$PlayerProfile;
  type(
    classname: "com.destroystokyo.paper.profile.ProfileProperty"
  ): typeof com$destroystokyo$paper$profile$ProfileProperty;
  type(
    classname: "com.destroystokyo.paper.ClientOption"
  ): typeof com$destroystokyo$paper$ClientOption;
  type(
    classname: "org.bukkit.entity.Player$Spigot"
  ): typeof org$bukkit$entity$Player$Spigot;
  type(
    classname: "org.bukkit.plugin.PluginManager"
  ): typeof org$bukkit$plugin$PluginManager;
  type(
    classname: "org.bukkit.event.EventPriority"
  ): typeof org$bukkit$event$EventPriority;
  type(
    classname: "org.bukkit.scheduler.BukkitScheduler"
  ): typeof org$bukkit$scheduler$BukkitScheduler;
  type(
    classname: "org.bukkit.scheduler.BukkitRunnable"
  ): typeof org$bukkit$scheduler$BukkitRunnable;
  type(
    classname: "org.bukkit.scheduler.BukkitTask"
  ): typeof org$bukkit$scheduler$BukkitTask;
  type(
    classname: "org.bukkit.plugin.ServicesManager"
  ): typeof org$bukkit$plugin$ServicesManager;
  type(
    classname: "org.bukkit.plugin.ServicePriority"
  ): typeof org$bukkit$plugin$ServicePriority;
  type(
    classname: "org.bukkit.plugin.RegisteredServiceProvider"
  ): typeof org$bukkit$plugin$RegisteredServiceProvider;
  type(classname: "org.bukkit.WorldCreator"): typeof org$bukkit$WorldCreator;
  type(
    classname: "org.bukkit.command.PluginCommand"
  ): typeof org$bukkit$command$PluginCommand;
  type(
    classname: "org.bukkit.command.PluginIdentifiableCommand"
  ): typeof org$bukkit$command$PluginIdentifiableCommand;
  type(
    classname: "org.bukkit.command.TabCompleter"
  ): typeof org$bukkit$command$TabCompleter;
  type(
    classname: "org.bukkit.command.Command"
  ): typeof org$bukkit$command$Command;
  type(
    classname: "org.bukkit.command.CommandMap"
  ): typeof org$bukkit$command$CommandMap;
  type(classname: "org.bukkit.BanList"): typeof org$bukkit$BanList;
  type(classname: "org.bukkit.BanList$Type"): typeof org$bukkit$BanList$Type;
  type(
    classname: "org.bukkit.command.ConsoleCommandSender"
  ): typeof org$bukkit$command$ConsoleCommandSender;
  type(
    classname: "org.bukkit.plugin.messaging.Messenger"
  ): typeof org$bukkit$plugin$messaging$Messenger;
  type(
    classname: "org.bukkit.plugin.messaging.PluginMessageListenerRegistration"
  ): typeof org$bukkit$plugin$messaging$PluginMessageListenerRegistration;
  type(
    classname: "org.bukkit.plugin.messaging.PluginMessageListener"
  ): typeof org$bukkit$plugin$messaging$PluginMessageListener;
  type(classname: "org.bukkit.help.HelpMap"): typeof org$bukkit$help$HelpMap;
  type(
    classname: "org.bukkit.help.HelpTopic"
  ): typeof org$bukkit$help$HelpTopic;
  type(
    classname: "org.bukkit.help.HelpTopicFactory"
  ): typeof org$bukkit$help$HelpTopicFactory;
  type(
    classname: "org.bukkit.Warning$WarningState"
  ): typeof org$bukkit$Warning$WarningState;
  type(classname: "org.bukkit.Warning"): typeof org$bukkit$Warning;
  type(
    classname: "org.bukkit.inventory.ItemFactory"
  ): typeof org$bukkit$inventory$ItemFactory;
  type(
    classname: "org.bukkit.scoreboard.ScoreboardManager"
  ): typeof org$bukkit$scoreboard$ScoreboardManager;
  type(
    classname: "org.bukkit.util.CachedServerIcon"
  ): typeof org$bukkit$util$CachedServerIcon;
  type(
    classname: "org.bukkit.boss.KeyedBossBar"
  ): typeof org$bukkit$boss$KeyedBossBar;
  type(classname: "org.bukkit.Tag"): typeof org$bukkit$Tag;
  type(classname: "org.bukkit.UnsafeValues"): typeof org$bukkit$UnsafeValues;
  type(
    classname: "org.bukkit.plugin.PluginDescriptionFile"
  ): typeof org$bukkit$plugin$PluginDescriptionFile;
  type(
    classname: "org.bukkit.plugin.PluginLoadOrder"
  ): typeof org$bukkit$plugin$PluginLoadOrder;
  type(
    classname: "com.destroystokyo.paper.util.VersionFetcher"
  ): typeof com$destroystokyo$paper$util$VersionFetcher;
  type(classname: "org.bukkit.Server$Spigot"): typeof org$bukkit$Server$Spigot;
  type(
    classname: "org.bukkit.configuration.file.YamlConfiguration"
  ): typeof org$bukkit$configuration$file$YamlConfiguration;
  type(
    classname: "org.bukkit.configuration.Configuration"
  ): typeof org$bukkit$configuration$Configuration;
  type(
    classname: "org.bukkit.configuration.ConfigurationSection"
  ): typeof org$bukkit$configuration$ConfigurationSection;
  type(
    classname: "org.bukkit.configuration.ConfigurationOptions"
  ): typeof org$bukkit$configuration$ConfigurationOptions;
  type(
    classname: "org.bukkit.configuration.file.YamlConfigurationOptions"
  ): typeof org$bukkit$configuration$file$YamlConfigurationOptions;
  type(
    classname: "org.bukkit.configuration.file.FileConfigurationOptions"
  ): typeof org$bukkit$configuration$file$FileConfigurationOptions;
  type(
    classname: "org.bukkit.configuration.MemoryConfiguration"
  ): typeof org$bukkit$configuration$MemoryConfiguration;
  type(
    classname: "org.bukkit.configuration.MemoryConfigurationOptions"
  ): typeof org$bukkit$configuration$MemoryConfigurationOptions;
  type(
    classname: "org.bukkit.configuration.file.FileConfiguration"
  ): typeof org$bukkit$configuration$file$FileConfiguration;
  type(
    classname: "com.destroystokyo.paper.entity.ai.MobGoals"
  ): typeof com$destroystokyo$paper$entity$ai$MobGoals;
  type(
    classname: "com.destroystokyo.paper.entity.ai.Goal"
  ): typeof com$destroystokyo$paper$entity$ai$Goal;
  type(
    classname: "com.destroystokyo.paper.entity.ai.GoalKey"
  ): typeof com$destroystokyo$paper$entity$ai$GoalKey;
  type(
    classname: "com.destroystokyo.paper.entity.ai.GoalType"
  ): typeof com$destroystokyo$paper$entity$ai$GoalType;
  type(
    classname: "org.bukkit.command.TabExecutor"
  ): typeof org$bukkit$command$TabExecutor;
  type(
    classname: "org.bukkit.plugin.PluginLoader"
  ): typeof org$bukkit$plugin$PluginLoader;
  type(
    classname: "org.bukkit.plugin.RegisteredListener"
  ): typeof org$bukkit$plugin$RegisteredListener;
  type(
    classname: "co.aikar.timings.TimingHistory"
  ): typeof co$aikar$timings$TimingHistory;
  type(
    classname: "co.aikar.timings.TimingHistory$MinuteReport"
  ): typeof co$aikar$timings$TimingHistory$MinuteReport;
  type(
    classname: "co.aikar.timings.TimingHistory$TicksRecord"
  ): typeof co$aikar$timings$TimingHistory$TicksRecord;
  type(
    classname: "co.aikar.timings.TimingHistory$PingRecord"
  ): typeof co$aikar$timings$TimingHistory$PingRecord;
  type(
    classname: "co.aikar.timings.TimingHistoryEntry"
  ): typeof co$aikar$timings$TimingHistoryEntry;
  type(
    classname: "co.aikar.timings.TimingHistory$1"
  ): typeof co$aikar$timings$TimingHistory$1;
  type(
    classname: "co.aikar.timings.TimingHistory$2"
  ): typeof co$aikar$timings$TimingHistory$2;
  type(
    classname: "co.aikar.util.JSONUtil$JSONPair"
  ): typeof co$aikar$util$JSONUtil$JSONPair;
  type(
    classname: "co.aikar.timings.TimingHistory$2$1"
  ): typeof co$aikar$timings$TimingHistory$2$1;
  type(
    classname: "co.aikar.timings.TimingHistory$RegionData"
  ): typeof co$aikar$timings$TimingHistory$RegionData;
  type(
    classname: "co.aikar.timings.TimingHistory$RegionData$RegionId"
  ): typeof co$aikar$timings$TimingHistory$RegionData$RegionId;
  type(
    classname: "co.aikar.timings.TimingHistory$2$1$1"
  ): typeof co$aikar$timings$TimingHistory$2$1$1;
  type(
    classname: "co.aikar.timings.TimingHistory$2$1$2"
  ): typeof co$aikar$timings$TimingHistory$2$1$2;
  type(
    classname: "co.aikar.timings.TimingHistory$3"
  ): typeof co$aikar$timings$TimingHistory$3;
  type(
    classname: "co.aikar.timings.TimingHistory$4"
  ): typeof co$aikar$timings$TimingHistory$4;
  type(
    classname: "co.aikar.timings.TimingHistory$Counter"
  ): typeof co$aikar$timings$TimingHistory$Counter;
  type(
    classname: "co.aikar.timings.TimingHistory$RegionData$1"
  ): typeof co$aikar$timings$TimingHistory$RegionData$1;
  type(
    classname: "co.aikar.timings.TimingHistoryEntry$1"
  ): typeof co$aikar$timings$TimingHistoryEntry$1;
  type(classname: "co.aikar.timings.Timings"): typeof co$aikar$timings$Timings;
  type(
    classname: "co.aikar.timings.TimingsReportListener"
  ): typeof co$aikar$timings$TimingsReportListener;
  type(
    classname: "org.bukkit.command.MessageCommandSender"
  ): typeof org$bukkit$command$MessageCommandSender;
  type(
    classname: "co.aikar.timings.TimingsCommand"
  ): typeof co$aikar$timings$TimingsCommand;
  type(
    classname: "co.aikar.timings.TimingsManager"
  ): typeof co$aikar$timings$TimingsManager;
  type(
    classname: "com.google.common.collect.EvictingQueue"
  ): typeof com$google$common$collect$EvictingQueue;
  type(
    classname: "co.aikar.timings.UnsafeTimingHandler"
  ): typeof co$aikar$timings$UnsafeTimingHandler;
  type(classname: "co.aikar.util.Counter"): typeof co$aikar$util$Counter;
  type(classname: "co.aikar.util.JSONUtil"): typeof co$aikar$util$JSONUtil;
  type(
    classname: "co.aikar.util.LoadingIntMap"
  ): typeof co$aikar$util$LoadingIntMap;
  type(
    classname: "co.aikar.util.LoadingIntMap$Feeder"
  ): typeof co$aikar$util$LoadingIntMap$Feeder;
  type(classname: "co.aikar.util.LoadingMap"): typeof co$aikar$util$LoadingMap;
  type(
    classname: "co.aikar.util.LoadingMap$AutoInstantiatingLoader"
  ): typeof co$aikar$util$LoadingMap$AutoInstantiatingLoader;
  type(
    classname: "co.aikar.util.LoadingMap$Feeder"
  ): typeof co$aikar$util$LoadingMap$Feeder;
  type(
    classname: "co.aikar.util.MRUMapCache"
  ): typeof co$aikar$util$MRUMapCache;
  type(
    classname: "com.destroystokyo.paper.ClientOption$ChatVisibility"
  ): typeof com$destroystokyo$paper$ClientOption$ChatVisibility;
  type(
    classname: "com.destroystokyo.paper.entity.ai.VanillaGoal"
  ): typeof com$destroystokyo$paper$entity$ai$VanillaGoal;
  type(
    classname: "com.destroystokyo.paper.entity.RangedEntity"
  ): typeof com$destroystokyo$paper$entity$RangedEntity;
  type(
    classname: "com.destroystokyo.paper.event.block.AnvilDamagedEvent"
  ): typeof com$destroystokyo$paper$event$block$AnvilDamagedEvent;
  type(
    classname: "org.bukkit.inventory.AnvilInventory"
  ): typeof org$bukkit$inventory$AnvilInventory;
  type(
    classname: "com.destroystokyo.paper.event.block.AnvilDamagedEvent$DamageState"
  ): typeof com$destroystokyo$paper$event$block$AnvilDamagedEvent$DamageState;
  type(
    classname: "com.destroystokyo.paper.event.block.BeaconEffectEvent"
  ): typeof com$destroystokyo$paper$event$block$BeaconEffectEvent;
  type(
    classname: "com.destroystokyo.paper.event.block.BlockDestroyEvent"
  ): typeof com$destroystokyo$paper$event$block$BlockDestroyEvent;
  type(
    classname: "com.destroystokyo.paper.event.block.TNTPrimeEvent"
  ): typeof com$destroystokyo$paper$event$block$TNTPrimeEvent;
  type(
    classname: "com.destroystokyo.paper.event.block.TNTPrimeEvent$PrimeReason"
  ): typeof com$destroystokyo$paper$event$block$TNTPrimeEvent$PrimeReason;
  type(
    classname: "com.destroystokyo.paper.event.entity.CreeperIgniteEvent"
  ): typeof com$destroystokyo$paper$event$entity$CreeperIgniteEvent;
  type(
    classname: "org.bukkit.entity.Creeper"
  ): typeof org$bukkit$entity$Creeper;
  type(
    classname: "org.bukkit.entity.Monster"
  ): typeof org$bukkit$entity$Monster;
  type(
    classname: "com.destroystokyo.paper.event.entity.EnderDragonFireballHitEvent"
  ): typeof com$destroystokyo$paper$event$entity$EnderDragonFireballHitEvent;
  type(
    classname: "org.bukkit.entity.DragonFireball"
  ): typeof org$bukkit$entity$DragonFireball;
  type(
    classname: "org.bukkit.entity.Explosive"
  ): typeof org$bukkit$entity$Explosive;
  type(
    classname: "org.bukkit.entity.Fireball"
  ): typeof org$bukkit$entity$Fireball;
  type(
    classname: "org.bukkit.entity.AreaEffectCloud"
  ): typeof org$bukkit$entity$AreaEffectCloud;
  type(
    classname: "com.destroystokyo.paper.event.entity.EnderDragonFlameEvent"
  ): typeof com$destroystokyo$paper$event$entity$EnderDragonFlameEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EnderDragonShootFireballEvent"
  ): typeof com$destroystokyo$paper$event$entity$EnderDragonShootFireballEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent"
  ): typeof com$destroystokyo$paper$event$entity$EndermanAttackPlayerEvent;
  type(
    classname: "org.bukkit.entity.Enderman"
  ): typeof org$bukkit$entity$Enderman;
  type(
    classname: "com.destroystokyo.paper.event.entity.EndermanEscapeEvent"
  ): typeof com$destroystokyo$paper$event$entity$EndermanEscapeEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EndermanEscapeEvent$Reason"
  ): typeof com$destroystokyo$paper$event$entity$EndermanEscapeEvent$Reason;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityAddToWorldEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityAddToWorldEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityJumpEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityJumpEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityKnockbackByEntityEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityKnockbackByEntityEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityPathfindEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityPathfindEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityRemoveFromWorldEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityTeleportEndGatewayEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityTeleportEndGatewayEvent;
  type(
    classname: "org.bukkit.block.EndGateway"
  ): typeof org$bukkit$block$EndGateway;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityTransformedEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityTransformedEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityTransformedEvent$TransformedReason"
  ): typeof com$destroystokyo$paper$event$entity$EntityTransformedEvent$TransformedReason;
  type(
    classname: "com.destroystokyo.paper.event.entity.EntityZapEvent"
  ): typeof com$destroystokyo$paper$event$entity$EntityZapEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.ExperienceOrbMergeEvent"
  ): typeof com$destroystokyo$paper$event$entity$ExperienceOrbMergeEvent;
  type(
    classname: "org.bukkit.entity.ExperienceOrb"
  ): typeof org$bukkit$entity$ExperienceOrb;
  type(
    classname: "org.bukkit.entity.ExperienceOrb$SpawnReason"
  ): typeof org$bukkit$entity$ExperienceOrb$SpawnReason;
  type(
    classname: "com.destroystokyo.paper.event.entity.PhantomPreSpawnEvent"
  ): typeof com$destroystokyo$paper$event$entity$PhantomPreSpawnEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent"
  ): typeof com$destroystokyo$paper$event$entity$PlayerNaturallySpawnCreaturesEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.PreCreatureSpawnEvent"
  ): typeof com$destroystokyo$paper$event$entity$PreCreatureSpawnEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.PreSpawnerSpawnEvent"
  ): typeof com$destroystokyo$paper$event$entity$PreSpawnerSpawnEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.ProjectileCollideEvent"
  ): typeof com$destroystokyo$paper$event$entity$ProjectileCollideEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.SkeletonHorseTrapEvent"
  ): typeof com$destroystokyo$paper$event$entity$SkeletonHorseTrapEvent;
  type(
    classname: "org.bukkit.entity.SkeletonHorse"
  ): typeof org$bukkit$entity$SkeletonHorse;
  type(
    classname: "org.bukkit.entity.AbstractHorse"
  ): typeof org$bukkit$entity$AbstractHorse;
  type(
    classname: "org.bukkit.entity.Animals"
  ): typeof org$bukkit$entity$Animals;
  type(
    classname: "org.bukkit.entity.Tameable"
  ): typeof org$bukkit$entity$Tameable;
  type(
    classname: "org.bukkit.entity.Vehicle"
  ): typeof org$bukkit$entity$Vehicle;
  type(
    classname: "org.bukkit.entity.Horse$Variant"
  ): typeof org$bukkit$entity$Horse$Variant;
  type(
    classname: "org.bukkit.inventory.AbstractHorseInventory"
  ): typeof org$bukkit$inventory$AbstractHorseInventory;
  type(
    classname: "com.destroystokyo.paper.event.entity.SlimeChangeDirectionEvent"
  ): typeof com$destroystokyo$paper$event$entity$SlimeChangeDirectionEvent;
  type(classname: "org.bukkit.entity.Slime"): typeof org$bukkit$entity$Slime;
  type(
    classname: "com.destroystokyo.paper.event.entity.SlimePathfindEvent"
  ): typeof com$destroystokyo$paper$event$entity$SlimePathfindEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.SlimeSwimEvent"
  ): typeof com$destroystokyo$paper$event$entity$SlimeSwimEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.SlimeTargetLivingEntityEvent"
  ): typeof com$destroystokyo$paper$event$entity$SlimeTargetLivingEntityEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.SlimeWanderEvent"
  ): typeof com$destroystokyo$paper$event$entity$SlimeWanderEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.ThrownEggHatchEvent"
  ): typeof com$destroystokyo$paper$event$entity$ThrownEggHatchEvent;
  type(classname: "org.bukkit.entity.Egg"): typeof org$bukkit$entity$Egg;
  type(
    classname: "org.bukkit.entity.ThrowableProjectile"
  ): typeof org$bukkit$entity$ThrowableProjectile;
  type(
    classname: "com.destroystokyo.paper.event.entity.TurtleGoHomeEvent"
  ): typeof com$destroystokyo$paper$event$entity$TurtleGoHomeEvent;
  type(classname: "org.bukkit.entity.Turtle"): typeof org$bukkit$entity$Turtle;
  type(
    classname: "com.destroystokyo.paper.event.entity.TurtleLayEggEvent"
  ): typeof com$destroystokyo$paper$event$entity$TurtleLayEggEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.TurtleStartDiggingEvent"
  ): typeof com$destroystokyo$paper$event$entity$TurtleStartDiggingEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.WitchConsumePotionEvent"
  ): typeof com$destroystokyo$paper$event$entity$WitchConsumePotionEvent;
  type(classname: "org.bukkit.entity.Witch"): typeof org$bukkit$entity$Witch;
  type(classname: "org.bukkit.entity.Raider"): typeof org$bukkit$entity$Raider;
  type(
    classname: "com.destroystokyo.paper.event.entity.WitchReadyPotionEvent"
  ): typeof com$destroystokyo$paper$event$entity$WitchReadyPotionEvent;
  type(
    classname: "com.destroystokyo.paper.event.entity.WitchThrowPotionEvent"
  ): typeof com$destroystokyo$paper$event$entity$WitchThrowPotionEvent;
  type(
    classname: "com.destroystokyo.paper.event.executor.asm.ASMEventExecutorGenerator"
  ): typeof com$destroystokyo$paper$event$executor$asm$ASMEventExecutorGenerator;
  type(
    classname: "com.destroystokyo.paper.event.executor.asm.ClassDefiner"
  ): typeof com$destroystokyo$paper$event$executor$asm$ClassDefiner;
  type(
    classname: "com.destroystokyo.paper.event.executor.asm.SafeClassDefiner"
  ): typeof com$destroystokyo$paper$event$executor$asm$SafeClassDefiner;
  type(
    classname: "com.destroystokyo.paper.event.executor.asm.SafeClassDefiner$GeneratedClassLoader"
  ): typeof com$destroystokyo$paper$event$executor$asm$SafeClassDefiner$GeneratedClassLoader;
  type(
    classname: "com.destroystokyo.paper.event.executor.MethodHandleEventExecutor"
  ): typeof com$destroystokyo$paper$event$executor$MethodHandleEventExecutor;
  type(
    classname: "com.destroystokyo.paper.event.executor.StaticMethodHandleEventExecutor"
  ): typeof com$destroystokyo$paper$event$executor$StaticMethodHandleEventExecutor;
  type(
    classname: "com.destroystokyo.paper.event.inventory.PrepareGrindstoneEvent"
  ): typeof com$destroystokyo$paper$event$inventory$PrepareGrindstoneEvent;
  type(
    classname: "org.bukkit.inventory.GrindstoneInventory"
  ): typeof org$bukkit$inventory$GrindstoneInventory;
  type(
    classname: "com.destroystokyo.paper.event.player.IllegalPacketEvent"
  ): typeof com$destroystokyo$paper$event$player$IllegalPacketEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerAdvancementCriterionGrantEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerAdvancementCriterionGrantEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerArmorChangeEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerArmorChangeEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerArmorChangeEvent$SlotType"
  ): typeof com$destroystokyo$paper$event$player$PlayerArmorChangeEvent$SlotType;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerAttackEntityCooldownResetEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerAttackEntityCooldownResetEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerClientOptionsChangeEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerClientOptionsChangeEvent;
  type(
    classname: "com.destroystokyo.paper.SkinParts"
  ): typeof com$destroystokyo$paper$SkinParts;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerConnectionCloseEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerElytraBoostEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerElytraBoostEvent;
  type(
    classname: "org.bukkit.entity.Firework"
  ): typeof org$bukkit$entity$Firework;
  type(
    classname: "org.bukkit.inventory.meta.FireworkMeta"
  ): typeof org$bukkit$inventory$meta$FireworkMeta;
  type(
    classname: "org.bukkit.FireworkEffect"
  ): typeof org$bukkit$FireworkEffect;
  type(
    classname: "org.bukkit.FireworkEffect$Builder"
  ): typeof org$bukkit$FireworkEffect$Builder;
  type(
    classname: "org.bukkit.FireworkEffect$Type"
  ): typeof org$bukkit$FireworkEffect$Type;
  type(
    classname: "com.google.common.collect.ImmutableList$Builder"
  ): typeof com$google$common$collect$ImmutableList$Builder;
  type(
    classname: "com.google.common.collect.ImmutableList"
  ): typeof com$google$common$collect$ImmutableList;
  type(
    classname: "com.google.common.collect.UnmodifiableIterator"
  ): typeof com$google$common$collect$UnmodifiableIterator;
  type(
    classname: "com.google.common.collect.UnmodifiableListIterator"
  ): typeof com$google$common$collect$UnmodifiableListIterator;
  type(
    classname: "com.google.common.collect.ImmutableCollection$Builder"
  ): typeof com$google$common$collect$ImmutableCollection$Builder;
  type(
    classname: "com.google.common.collect.ImmutableCollection"
  ): typeof com$google$common$collect$ImmutableCollection;
  type(
    classname: "com.google.common.collect.ImmutableCollection$ArrayBasedBuilder"
  ): typeof com$google$common$collect$ImmutableCollection$ArrayBasedBuilder;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerHandshakeEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerHandshakeEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerInitialSpawnEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerInitialSpawnEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerJumpEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerJumpEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerLaunchProjectileEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerLocaleChangeEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerLocaleChangeEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerPickupExperienceEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerPostRespawnEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerPostRespawnEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerReadyArrowEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerReadyArrowEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerRecipeBookClickEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerStartSpectatingEntityEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerStartSpectatingEntityEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerStopSpectatingEntityEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerStopSpectatingEntityEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerTeleportEndGatewayEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerTeleportEndGatewayEvent;
  type(
    classname: "com.destroystokyo.paper.event.player.PlayerUseUnknownEntityEvent"
  ): typeof com$destroystokyo$paper$event$player$PlayerUseUnknownEntityEvent;
  type(
    classname: "com.destroystokyo.paper.event.profile.FillProfileEvent"
  ): typeof com$destroystokyo$paper$event$profile$FillProfileEvent;
  type(
    classname: "com.destroystokyo.paper.event.profile.LookupProfileEvent"
  ): typeof com$destroystokyo$paper$event$profile$LookupProfileEvent;
  type(
    classname: "com.destroystokyo.paper.event.profile.PreFillProfileEvent"
  ): typeof com$destroystokyo$paper$event$profile$PreFillProfileEvent;
  type(
    classname: "com.destroystokyo.paper.event.profile.PreLookupProfileEvent"
  ): typeof com$destroystokyo$paper$event$profile$PreLookupProfileEvent;
  type(
    classname: "com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent"
  ): typeof com$destroystokyo$paper$event$profile$ProfileWhitelistVerifyEvent;
  type(
    classname: "com.destroystokyo.paper.event.server.AsyncTabCompleteEvent"
  ): typeof com$destroystokyo$paper$event$server$AsyncTabCompleteEvent;
  type(
    classname: "com.destroystokyo.paper.event.server.GS4QueryEvent"
  ): typeof com$destroystokyo$paper$event$server$GS4QueryEvent;
  type(
    classname: "com.destroystokyo.paper.event.server.GS4QueryEvent$QueryType"
  ): typeof com$destroystokyo$paper$event$server$GS4QueryEvent$QueryType;
  type(
    classname: "com.destroystokyo.paper.event.server.GS4QueryEvent$QueryResponse"
  ): typeof com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse;
  type(
    classname: "com.destroystokyo.paper.event.server.GS4QueryEvent$QueryResponse$Builder"
  ): typeof com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$Builder;
  type(
    classname: "com.destroystokyo.paper.event.server.GS4QueryEvent$QueryResponse$PluginInformation"
  ): typeof com$destroystokyo$paper$event$server$GS4QueryEvent$QueryResponse$PluginInformation;
  type(
    classname: "com.destroystokyo.paper.event.server.GS4QueryEvent$1"
  ): typeof com$destroystokyo$paper$event$server$GS4QueryEvent$1;
  type(
    classname: "com.destroystokyo.paper.event.server.PaperServerListPingEvent"
  ): typeof com$destroystokyo$paper$event$server$PaperServerListPingEvent;
  type(
    classname: "com.destroystokyo.paper.network.StatusClient"
  ): typeof com$destroystokyo$paper$network$StatusClient;
  type(
    classname: "com.destroystokyo.paper.event.server.PaperServerListPingEvent$1"
  ): typeof com$destroystokyo$paper$event$server$PaperServerListPingEvent$1;
  type(
    classname: "com.destroystokyo.paper.event.server.PaperServerListPingEvent$PlayerIterator"
  ): typeof com$destroystokyo$paper$event$server$PaperServerListPingEvent$PlayerIterator;
  type(
    classname: "com.destroystokyo.paper.event.server.ServerExceptionEvent"
  ): typeof com$destroystokyo$paper$event$server$ServerExceptionEvent;
  type(
    classname: "com.destroystokyo.paper.exception.ServerException"
  ): typeof com$destroystokyo$paper$exception$ServerException;
  type(
    classname: "com.destroystokyo.paper.event.server.ServerTickEndEvent"
  ): typeof com$destroystokyo$paper$event$server$ServerTickEndEvent;
  type(
    classname: "com.destroystokyo.paper.event.server.ServerTickStartEvent"
  ): typeof com$destroystokyo$paper$event$server$ServerTickStartEvent;
  type(
    classname: "com.destroystokyo.paper.event.server.WhitelistToggleEvent"
  ): typeof com$destroystokyo$paper$event$server$WhitelistToggleEvent;
  type(
    classname: "com.destroystokyo.paper.exception.ServerCommandException"
  ): typeof com$destroystokyo$paper$exception$ServerCommandException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerEventException"
  ): typeof com$destroystokyo$paper$exception$ServerEventException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerInternalException"
  ): typeof com$destroystokyo$paper$exception$ServerInternalException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerPluginEnableDisableException"
  ): typeof com$destroystokyo$paper$exception$ServerPluginEnableDisableException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerPluginException"
  ): typeof com$destroystokyo$paper$exception$ServerPluginException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerPluginMessageException"
  ): typeof com$destroystokyo$paper$exception$ServerPluginMessageException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerSchedulerException"
  ): typeof com$destroystokyo$paper$exception$ServerSchedulerException;
  type(
    classname: "com.destroystokyo.paper.exception.ServerTabCompleteException"
  ): typeof com$destroystokyo$paper$exception$ServerTabCompleteException;
  type(
    classname: "com.destroystokyo.paper.inventory.ItemStackRecipeChoice"
  ): typeof com$destroystokyo$paper$inventory$ItemStackRecipeChoice;
  type(
    classname: "org.bukkit.inventory.RecipeChoice"
  ): typeof org$bukkit$inventory$RecipeChoice;
  type(
    classname: "com.destroystokyo.paper.inventory.meta.ArmorStandMeta"
  ): typeof com$destroystokyo$paper$inventory$meta$ArmorStandMeta;
  type(
    classname: "com.destroystokyo.paper.loottable.LootableBlockInventory"
  ): typeof com$destroystokyo$paper$loottable$LootableBlockInventory;
  type(
    classname: "com.destroystokyo.paper.loottable.LootableInventory"
  ): typeof com$destroystokyo$paper$loottable$LootableInventory;
  type(
    classname: "com.destroystokyo.paper.loottable.LootableEntityInventory"
  ): typeof com$destroystokyo$paper$loottable$LootableEntityInventory;
  type(
    classname: "com.destroystokyo.paper.loottable.LootableInventoryReplenishEvent"
  ): typeof com$destroystokyo$paper$loottable$LootableInventoryReplenishEvent;
  type(
    classname: "com.destroystokyo.paper.MaterialSetTag"
  ): typeof com$destroystokyo$paper$MaterialSetTag;
  type(
    classname: "com.destroystokyo.paper.MaterialTags"
  ): typeof com$destroystokyo$paper$MaterialTags;
  type(
    classname: "com.destroystokyo.paper.NamespacedTag"
  ): typeof com$destroystokyo$paper$NamespacedTag;
  type(
    classname: "com.destroystokyo.paper.util.SneakyThrow"
  ): typeof com$destroystokyo$paper$util$SneakyThrow;
  type(
    classname: "com.destroystokyo.paper.util.VersionFetcher$DummyVersionFetcher"
  ): typeof com$destroystokyo$paper$util$VersionFetcher$DummyVersionFetcher;
  type(
    classname: "com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue"
  ): typeof com$destroystokyo$paper$utils$CachedSizeConcurrentLinkedQueue;
  type(
    classname: "com.destroystokyo.paper.utils.PaperPluginLogger"
  ): typeof com$destroystokyo$paper$utils$PaperPluginLogger;
  type(
    classname: "com.destroystokyo.paper.utils.UnsafeUtils"
  ): typeof com$destroystokyo$paper$utils$UnsafeUtils;
  type(classname: "sun.misc.Unsafe"): typeof sun$misc$Unsafe;
  type(classname: "org.bukkit.Art"): typeof org$bukkit$Art;
  type(classname: "org.bukkit.Axis"): typeof org$bukkit$Axis;
  type(classname: "org.bukkit.block.Banner"): typeof org$bukkit$block$Banner;
  type(
    classname: "org.bukkit.block.banner.Pattern"
  ): typeof org$bukkit$block$banner$Pattern;
  type(
    classname: "org.bukkit.block.banner.PatternType"
  ): typeof org$bukkit$block$banner$PatternType;
  type(classname: "org.bukkit.block.Barrel"): typeof org$bukkit$block$Barrel;
  type(
    classname: "org.bukkit.block.Container"
  ): typeof org$bukkit$block$Container;
  type(
    classname: "org.bukkit.block.Lockable"
  ): typeof org$bukkit$block$Lockable;
  type(
    classname: "org.bukkit.inventory.BlockInventoryHolder"
  ): typeof org$bukkit$inventory$BlockInventoryHolder;
  type(classname: "org.bukkit.block.Beacon"): typeof org$bukkit$block$Beacon;
  type(classname: "org.bukkit.block.Bed"): typeof org$bukkit$block$Bed;
  type(classname: "org.bukkit.block.Beehive"): typeof org$bukkit$block$Beehive;
  type(
    classname: "org.bukkit.block.EntityBlockStorage"
  ): typeof org$bukkit$block$EntityBlockStorage;
  type(classname: "org.bukkit.block.Bell"): typeof org$bukkit$block$Bell;
  type(
    classname: "org.bukkit.block.BlastFurnace"
  ): typeof org$bukkit$block$BlastFurnace;
  type(classname: "org.bukkit.block.Furnace"): typeof org$bukkit$block$Furnace;
  type(
    classname: "org.bukkit.inventory.FurnaceInventory"
  ): typeof org$bukkit$inventory$FurnaceInventory;
  type(
    classname: "org.bukkit.block.BlockFace$1"
  ): typeof org$bukkit$block$BlockFace$1;
  type(
    classname: "org.bukkit.block.BrewingStand"
  ): typeof org$bukkit$block$BrewingStand;
  type(
    classname: "org.bukkit.inventory.BrewerInventory"
  ): typeof org$bukkit$inventory$BrewerInventory;
  type(
    classname: "org.bukkit.block.Campfire"
  ): typeof org$bukkit$block$Campfire;
  type(classname: "org.bukkit.block.Chest"): typeof org$bukkit$block$Chest;
  type(
    classname: "org.bukkit.block.CommandBlock"
  ): typeof org$bukkit$block$CommandBlock;
  type(
    classname: "org.bukkit.block.Comparator"
  ): typeof org$bukkit$block$Comparator;
  type(classname: "org.bukkit.block.Conduit"): typeof org$bukkit$block$Conduit;
  type(
    classname: "org.bukkit.block.CreatureSpawner"
  ): typeof org$bukkit$block$CreatureSpawner;
  type(
    classname: "org.bukkit.block.data.Ageable"
  ): typeof org$bukkit$block$data$Ageable;
  type(
    classname: "org.bukkit.block.data.AnaloguePowerable"
  ): typeof org$bukkit$block$data$AnaloguePowerable;
  type(
    classname: "org.bukkit.block.data.Attachable"
  ): typeof org$bukkit$block$data$Attachable;
  type(
    classname: "org.bukkit.block.data.Bisected"
  ): typeof org$bukkit$block$data$Bisected;
  type(
    classname: "org.bukkit.block.data.Bisected$Half"
  ): typeof org$bukkit$block$data$Bisected$Half;
  type(
    classname: "org.bukkit.block.data.Directional"
  ): typeof org$bukkit$block$data$Directional;
  type(
    classname: "org.bukkit.block.data.FaceAttachable"
  ): typeof org$bukkit$block$data$FaceAttachable;
  type(
    classname: "org.bukkit.block.data.FaceAttachable$AttachedFace"
  ): typeof org$bukkit$block$data$FaceAttachable$AttachedFace;
  type(
    classname: "org.bukkit.block.data.Levelled"
  ): typeof org$bukkit$block$data$Levelled;
  type(
    classname: "org.bukkit.block.data.Lightable"
  ): typeof org$bukkit$block$data$Lightable;
  type(
    classname: "org.bukkit.block.data.MultipleFacing"
  ): typeof org$bukkit$block$data$MultipleFacing;
  type(
    classname: "org.bukkit.block.data.Openable"
  ): typeof org$bukkit$block$data$Openable;
  type(
    classname: "org.bukkit.block.data.Orientable"
  ): typeof org$bukkit$block$data$Orientable;
  type(
    classname: "org.bukkit.block.data.Powerable"
  ): typeof org$bukkit$block$data$Powerable;
  type(
    classname: "org.bukkit.block.data.Rail"
  ): typeof org$bukkit$block$data$Rail;
  type(
    classname: "org.bukkit.block.data.Rail$Shape"
  ): typeof org$bukkit$block$data$Rail$Shape;
  type(
    classname: "org.bukkit.block.data.Rotatable"
  ): typeof org$bukkit$block$data$Rotatable;
  type(
    classname: "org.bukkit.block.data.Snowable"
  ): typeof org$bukkit$block$data$Snowable;
  type(
    classname: "org.bukkit.block.data.type.Bamboo"
  ): typeof org$bukkit$block$data$type$Bamboo;
  type(
    classname: "org.bukkit.block.data.type.Sapling"
  ): typeof org$bukkit$block$data$type$Sapling;
  type(
    classname: "org.bukkit.block.data.type.Bamboo$Leaves"
  ): typeof org$bukkit$block$data$type$Bamboo$Leaves;
  type(
    classname: "org.bukkit.block.data.type.Bed"
  ): typeof org$bukkit$block$data$type$Bed;
  type(
    classname: "org.bukkit.block.data.type.Bed$Part"
  ): typeof org$bukkit$block$data$type$Bed$Part;
  type(
    classname: "org.bukkit.block.data.type.Beehive"
  ): typeof org$bukkit$block$data$type$Beehive;
  type(
    classname: "org.bukkit.block.data.type.Bell"
  ): typeof org$bukkit$block$data$type$Bell;
  type(
    classname: "org.bukkit.block.data.type.Bell$Attachment"
  ): typeof org$bukkit$block$data$type$Bell$Attachment;
  type(
    classname: "org.bukkit.block.data.type.BrewingStand"
  ): typeof org$bukkit$block$data$type$BrewingStand;
  type(
    classname: "org.bukkit.block.data.type.BubbleColumn"
  ): typeof org$bukkit$block$data$type$BubbleColumn;
  type(
    classname: "org.bukkit.block.data.type.Cake"
  ): typeof org$bukkit$block$data$type$Cake;
  type(
    classname: "org.bukkit.block.data.type.Campfire"
  ): typeof org$bukkit$block$data$type$Campfire;
  type(
    classname: "org.bukkit.block.data.Waterlogged"
  ): typeof org$bukkit$block$data$Waterlogged;
  type(
    classname: "org.bukkit.block.data.type.Chest"
  ): typeof org$bukkit$block$data$type$Chest;
  type(
    classname: "org.bukkit.block.data.type.Chest$Type"
  ): typeof org$bukkit$block$data$type$Chest$Type;
  type(
    classname: "org.bukkit.block.data.type.Cocoa"
  ): typeof org$bukkit$block$data$type$Cocoa;
  type(
    classname: "org.bukkit.block.data.type.CommandBlock"
  ): typeof org$bukkit$block$data$type$CommandBlock;
  type(
    classname: "org.bukkit.block.data.type.Comparator"
  ): typeof org$bukkit$block$data$type$Comparator;
  type(
    classname: "org.bukkit.block.data.type.Comparator$Mode"
  ): typeof org$bukkit$block$data$type$Comparator$Mode;
  type(
    classname: "org.bukkit.block.data.type.CoralWallFan"
  ): typeof org$bukkit$block$data$type$CoralWallFan;
  type(
    classname: "org.bukkit.block.data.type.DaylightDetector"
  ): typeof org$bukkit$block$data$type$DaylightDetector;
  type(
    classname: "org.bukkit.block.data.type.Dispenser"
  ): typeof org$bukkit$block$data$type$Dispenser;
  type(
    classname: "org.bukkit.block.data.type.Door"
  ): typeof org$bukkit$block$data$type$Door;
  type(
    classname: "org.bukkit.block.data.type.Door$Hinge"
  ): typeof org$bukkit$block$data$type$Door$Hinge;
  type(
    classname: "org.bukkit.block.data.type.EnderChest"
  ): typeof org$bukkit$block$data$type$EnderChest;
  type(
    classname: "org.bukkit.block.data.type.EndPortalFrame"
  ): typeof org$bukkit$block$data$type$EndPortalFrame;
  type(
    classname: "org.bukkit.block.data.type.Farmland"
  ): typeof org$bukkit$block$data$type$Farmland;
  type(
    classname: "org.bukkit.block.data.type.Fence"
  ): typeof org$bukkit$block$data$type$Fence;
  type(
    classname: "org.bukkit.block.data.type.Fire"
  ): typeof org$bukkit$block$data$type$Fire;
  type(
    classname: "org.bukkit.block.data.type.Furnace"
  ): typeof org$bukkit$block$data$type$Furnace;
  type(
    classname: "org.bukkit.block.data.type.Gate"
  ): typeof org$bukkit$block$data$type$Gate;
  type(
    classname: "org.bukkit.block.data.type.GlassPane"
  ): typeof org$bukkit$block$data$type$GlassPane;
  type(
    classname: "org.bukkit.block.data.type.Grindstone"
  ): typeof org$bukkit$block$data$type$Grindstone;
  type(
    classname: "org.bukkit.block.data.type.Hopper"
  ): typeof org$bukkit$block$data$type$Hopper;
  type(
    classname: "org.bukkit.block.data.type.Jukebox"
  ): typeof org$bukkit$block$data$type$Jukebox;
  type(
    classname: "org.bukkit.block.data.type.Ladder"
  ): typeof org$bukkit$block$data$type$Ladder;
  type(
    classname: "org.bukkit.block.data.type.Lantern"
  ): typeof org$bukkit$block$data$type$Lantern;
  type(
    classname: "org.bukkit.block.data.type.Leaves"
  ): typeof org$bukkit$block$data$type$Leaves;
  type(
    classname: "org.bukkit.block.data.type.Lectern"
  ): typeof org$bukkit$block$data$type$Lectern;
  type(
    classname: "org.bukkit.block.data.type.NoteBlock"
  ): typeof org$bukkit$block$data$type$NoteBlock;
  type(
    classname: "org.bukkit.block.data.type.Observer"
  ): typeof org$bukkit$block$data$type$Observer;
  type(
    classname: "org.bukkit.block.data.type.Piston"
  ): typeof org$bukkit$block$data$type$Piston;
  type(
    classname: "org.bukkit.block.data.type.PistonHead"
  ): typeof org$bukkit$block$data$type$PistonHead;
  type(
    classname: "org.bukkit.block.data.type.TechnicalPiston"
  ): typeof org$bukkit$block$data$type$TechnicalPiston;
  type(
    classname: "org.bukkit.block.data.type.TechnicalPiston$Type"
  ): typeof org$bukkit$block$data$type$TechnicalPiston$Type;
  type(
    classname: "org.bukkit.block.data.type.RedstoneRail"
  ): typeof org$bukkit$block$data$type$RedstoneRail;
  type(
    classname: "org.bukkit.block.data.type.RedstoneWallTorch"
  ): typeof org$bukkit$block$data$type$RedstoneWallTorch;
  type(
    classname: "org.bukkit.block.data.type.RedstoneWire"
  ): typeof org$bukkit$block$data$type$RedstoneWire;
  type(
    classname: "org.bukkit.block.data.type.RedstoneWire$Connection"
  ): typeof org$bukkit$block$data$type$RedstoneWire$Connection;
  type(
    classname: "org.bukkit.block.data.type.Repeater"
  ): typeof org$bukkit$block$data$type$Repeater;
  type(
    classname: "org.bukkit.block.data.type.Scaffolding"
  ): typeof org$bukkit$block$data$type$Scaffolding;
  type(
    classname: "org.bukkit.block.data.type.SeaPickle"
  ): typeof org$bukkit$block$data$type$SeaPickle;
  type(
    classname: "org.bukkit.block.data.type.Sign"
  ): typeof org$bukkit$block$data$type$Sign;
  type(
    classname: "org.bukkit.block.data.type.Slab"
  ): typeof org$bukkit$block$data$type$Slab;
  type(
    classname: "org.bukkit.block.data.type.Slab$Type"
  ): typeof org$bukkit$block$data$type$Slab$Type;
  type(
    classname: "org.bukkit.block.data.type.Snow"
  ): typeof org$bukkit$block$data$type$Snow;
  type(
    classname: "org.bukkit.block.data.type.Stairs"
  ): typeof org$bukkit$block$data$type$Stairs;
  type(
    classname: "org.bukkit.block.data.type.Stairs$Shape"
  ): typeof org$bukkit$block$data$type$Stairs$Shape;
  type(
    classname: "org.bukkit.block.data.type.StructureBlock"
  ): typeof org$bukkit$block$data$type$StructureBlock;
  type(
    classname: "org.bukkit.block.data.type.StructureBlock$Mode"
  ): typeof org$bukkit$block$data$type$StructureBlock$Mode;
  type(
    classname: "org.bukkit.block.data.type.Switch"
  ): typeof org$bukkit$block$data$type$Switch;
  type(
    classname: "org.bukkit.block.data.type.Switch$Face"
  ): typeof org$bukkit$block$data$type$Switch$Face;
  type(
    classname: "org.bukkit.block.data.type.TNT"
  ): typeof org$bukkit$block$data$type$TNT;
  type(
    classname: "org.bukkit.block.data.type.TrapDoor"
  ): typeof org$bukkit$block$data$type$TrapDoor;
  type(
    classname: "org.bukkit.block.data.type.Tripwire"
  ): typeof org$bukkit$block$data$type$Tripwire;
  type(
    classname: "org.bukkit.block.data.type.TripwireHook"
  ): typeof org$bukkit$block$data$type$TripwireHook;
  type(
    classname: "org.bukkit.block.data.type.TurtleEgg"
  ): typeof org$bukkit$block$data$type$TurtleEgg;
  type(
    classname: "org.bukkit.block.data.type.WallSign"
  ): typeof org$bukkit$block$data$type$WallSign;
  type(
    classname: "org.bukkit.block.DaylightDetector"
  ): typeof org$bukkit$block$DaylightDetector;
  type(
    classname: "org.bukkit.block.Dispenser"
  ): typeof org$bukkit$block$Dispenser;
  type(
    classname: "org.bukkit.projectiles.BlockProjectileSource"
  ): typeof org$bukkit$projectiles$BlockProjectileSource;
  type(
    classname: "org.bukkit.block.DoubleChest"
  ): typeof org$bukkit$block$DoubleChest;
  type(
    classname: "org.bukkit.inventory.DoubleChestInventory"
  ): typeof org$bukkit$inventory$DoubleChestInventory;
  type(classname: "org.bukkit.block.Dropper"): typeof org$bukkit$block$Dropper;
  type(
    classname: "org.bukkit.block.EnchantingTable"
  ): typeof org$bukkit$block$EnchantingTable;
  type(
    classname: "org.bukkit.block.EnderChest"
  ): typeof org$bukkit$block$EnderChest;
  type(classname: "org.bukkit.block.Hopper"): typeof org$bukkit$block$Hopper;
  type(classname: "org.bukkit.block.Jigsaw"): typeof org$bukkit$block$Jigsaw;
  type(classname: "org.bukkit.block.Jukebox"): typeof org$bukkit$block$Jukebox;
  type(classname: "org.bukkit.block.Lectern"): typeof org$bukkit$block$Lectern;
  type(
    classname: "org.bukkit.block.ShulkerBox"
  ): typeof org$bukkit$block$ShulkerBox;
  type(classname: "org.bukkit.block.Skull"): typeof org$bukkit$block$Skull;
  type(classname: "org.bukkit.SkullType"): typeof org$bukkit$SkullType;
  type(classname: "org.bukkit.block.Smoker"): typeof org$bukkit$block$Smoker;
  type(
    classname: "org.bukkit.block.Structure"
  ): typeof org$bukkit$block$Structure;
  type(
    classname: "org.bukkit.block.structure.Mirror"
  ): typeof org$bukkit$block$structure$Mirror;
  type(
    classname: "org.bukkit.block.structure.StructureRotation"
  ): typeof org$bukkit$block$structure$StructureRotation;
  type(
    classname: "org.bukkit.block.structure.UsageMode"
  ): typeof org$bukkit$block$structure$UsageMode;
  type(classname: "org.bukkit.Bukkit"): typeof org$bukkit$Bukkit;
  type(classname: "org.bukkit.ChatColor$10"): typeof org$bukkit$ChatColor$10;
  type(classname: "org.bukkit.ChatColor$11"): typeof org$bukkit$ChatColor$11;
  type(classname: "org.bukkit.ChatColor$12"): typeof org$bukkit$ChatColor$12;
  type(classname: "org.bukkit.ChatColor$13"): typeof org$bukkit$ChatColor$13;
  type(classname: "org.bukkit.ChatColor$14"): typeof org$bukkit$ChatColor$14;
  type(classname: "org.bukkit.ChatColor$15"): typeof org$bukkit$ChatColor$15;
  type(classname: "org.bukkit.ChatColor$16"): typeof org$bukkit$ChatColor$16;
  type(classname: "org.bukkit.ChatColor$17"): typeof org$bukkit$ChatColor$17;
  type(classname: "org.bukkit.ChatColor$18"): typeof org$bukkit$ChatColor$18;
  type(classname: "org.bukkit.ChatColor$19"): typeof org$bukkit$ChatColor$19;
  type(classname: "org.bukkit.ChatColor$2"): typeof org$bukkit$ChatColor$2;
  type(classname: "org.bukkit.ChatColor$20"): typeof org$bukkit$ChatColor$20;
  type(classname: "org.bukkit.ChatColor$21"): typeof org$bukkit$ChatColor$21;
  type(classname: "org.bukkit.ChatColor$22"): typeof org$bukkit$ChatColor$22;
  type(classname: "org.bukkit.ChatColor$3"): typeof org$bukkit$ChatColor$3;
  type(classname: "org.bukkit.ChatColor$4"): typeof org$bukkit$ChatColor$4;
  type(classname: "org.bukkit.ChatColor$5"): typeof org$bukkit$ChatColor$5;
  type(classname: "org.bukkit.ChatColor$6"): typeof org$bukkit$ChatColor$6;
  type(classname: "org.bukkit.ChatColor$7"): typeof org$bukkit$ChatColor$7;
  type(classname: "org.bukkit.ChatColor$8"): typeof org$bukkit$ChatColor$8;
  type(classname: "org.bukkit.ChatColor$9"): typeof org$bukkit$ChatColor$9;
  type(classname: "org.bukkit.CoalType"): typeof org$bukkit$CoalType;
  type(
    classname: "org.bukkit.command.BlockCommandSender"
  ): typeof org$bukkit$command$BlockCommandSender;
  type(
    classname: "org.bukkit.command.BufferedCommandSender"
  ): typeof org$bukkit$command$BufferedCommandSender;
  type(
    classname: "org.bukkit.command.CommandException"
  ): typeof org$bukkit$command$CommandException;
  type(
    classname: "org.bukkit.command.defaults.BukkitCommand"
  ): typeof org$bukkit$command$defaults$BukkitCommand;
  type(
    classname: "org.bukkit.command.defaults.HelpCommand"
  ): typeof org$bukkit$command$defaults$HelpCommand;
  type(
    classname: "org.bukkit.command.defaults.PluginsCommand"
  ): typeof org$bukkit$command$defaults$PluginsCommand;
  type(
    classname: "org.bukkit.command.defaults.ReloadCommand"
  ): typeof org$bukkit$command$defaults$ReloadCommand;
  type(
    classname: "org.bukkit.command.defaults.VersionCommand"
  ): typeof org$bukkit$command$defaults$VersionCommand;
  type(
    classname: "org.bukkit.command.defaults.VersionCommand$1"
  ): typeof org$bukkit$command$defaults$VersionCommand$1;
  type(
    classname: "org.bukkit.command.FormattedCommandAlias"
  ): typeof org$bukkit$command$FormattedCommandAlias;
  type(
    classname: "org.bukkit.command.MultipleCommandAlias"
  ): typeof org$bukkit$command$MultipleCommandAlias;
  type(
    classname: "org.bukkit.command.PluginCommandYamlParser"
  ): typeof org$bukkit$command$PluginCommandYamlParser;
  type(
    classname: "org.bukkit.command.ProxiedCommandSender"
  ): typeof org$bukkit$command$ProxiedCommandSender;
  type(
    classname: "org.bukkit.command.RemoteConsoleCommandSender"
  ): typeof org$bukkit$command$RemoteConsoleCommandSender;
  type(
    classname: "org.bukkit.command.SimpleCommandMap"
  ): typeof org$bukkit$command$SimpleCommandMap;
  type(
    classname: "org.bukkit.configuration.file.YamlConstructor"
  ): typeof org$bukkit$configuration$file$YamlConstructor;
  type(
    classname: "org.bukkit.configuration.file.YamlConstructor$1"
  ): typeof org$bukkit$configuration$file$YamlConstructor$1;
  type(
    classname: "org.bukkit.configuration.file.YamlConstructor$ConstructCustomObject"
  ): typeof org$bukkit$configuration$file$YamlConstructor$ConstructCustomObject;
  type(
    classname: "org.bukkit.configuration.file.YamlRepresenter"
  ): typeof org$bukkit$configuration$file$YamlRepresenter;
  type(
    classname: "org.bukkit.configuration.file.YamlRepresenter$1"
  ): typeof org$bukkit$configuration$file$YamlRepresenter$1;
  type(
    classname: "org.bukkit.configuration.file.YamlRepresenter$RepresentConfigurationSection"
  ): typeof org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSection;
  type(
    classname: "org.bukkit.configuration.file.YamlRepresenter$RepresentConfigurationSerializable"
  ): typeof org$bukkit$configuration$file$YamlRepresenter$RepresentConfigurationSerializable;
  type(
    classname: "org.bukkit.configuration.InvalidConfigurationException"
  ): typeof org$bukkit$configuration$InvalidConfigurationException;
  type(
    classname: "org.bukkit.configuration.MemorySection"
  ): typeof org$bukkit$configuration$MemorySection;
  type(
    classname: "org.bukkit.configuration.serialization.ConfigurationSerialization"
  ): typeof org$bukkit$configuration$serialization$ConfigurationSerialization;
  type(
    classname: "org.bukkit.configuration.serialization.DelegateDeserialization"
  ): typeof org$bukkit$configuration$serialization$DelegateDeserialization;
  type(
    classname: "org.bukkit.configuration.serialization.SerializableAs"
  ): typeof org$bukkit$configuration$serialization$SerializableAs;
  type(
    classname: "org.bukkit.conversations.BooleanPrompt"
  ): typeof org$bukkit$conversations$BooleanPrompt;
  type(
    classname: "org.bukkit.conversations.ConversationFactory"
  ): typeof org$bukkit$conversations$ConversationFactory;
  type(
    classname: "org.bukkit.conversations.ConversationFactory$1"
  ): typeof org$bukkit$conversations$ConversationFactory$1;
  type(
    classname: "org.bukkit.conversations.ConversationFactory$NotPlayerMessagePrompt"
  ): typeof org$bukkit$conversations$ConversationFactory$NotPlayerMessagePrompt;
  type(
    classname: "org.bukkit.conversations.ExactMatchConversationCanceller"
  ): typeof org$bukkit$conversations$ExactMatchConversationCanceller;
  type(
    classname: "org.bukkit.conversations.FixedSetPrompt"
  ): typeof org$bukkit$conversations$FixedSetPrompt;
  type(
    classname: "org.bukkit.conversations.InactivityConversationCanceller"
  ): typeof org$bukkit$conversations$InactivityConversationCanceller;
  type(
    classname: "org.bukkit.conversations.InactivityConversationCanceller$1"
  ): typeof org$bukkit$conversations$InactivityConversationCanceller$1;
  type(
    classname: "org.bukkit.conversations.ManuallyAbandonedConversationCanceller"
  ): typeof org$bukkit$conversations$ManuallyAbandonedConversationCanceller;
  type(
    classname: "org.bukkit.conversations.MessagePrompt"
  ): typeof org$bukkit$conversations$MessagePrompt;
  type(
    classname: "org.bukkit.conversations.NullConversationPrefix"
  ): typeof org$bukkit$conversations$NullConversationPrefix;
  type(
    classname: "org.bukkit.conversations.NumericPrompt"
  ): typeof org$bukkit$conversations$NumericPrompt;
  type(
    classname: "org.bukkit.conversations.PlayerNamePrompt"
  ): typeof org$bukkit$conversations$PlayerNamePrompt;
  type(
    classname: "org.bukkit.conversations.PluginNameConversationPrefix"
  ): typeof org$bukkit$conversations$PluginNameConversationPrefix;
  type(
    classname: "org.bukkit.conversations.RegexPrompt"
  ): typeof org$bukkit$conversations$RegexPrompt;
  type(
    classname: "org.bukkit.conversations.StringPrompt"
  ): typeof org$bukkit$conversations$StringPrompt;
  type(
    classname: "org.bukkit.conversations.ValidatingPrompt"
  ): typeof org$bukkit$conversations$ValidatingPrompt;
  type(classname: "org.bukkit.CropState"): typeof org$bukkit$CropState;
  type(
    classname: "org.bukkit.enchantments.EnchantmentOffer"
  ): typeof org$bukkit$enchantments$EnchantmentOffer;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$10"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$10;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$11"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$11;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$12"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$12;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$13"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$13;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$14"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$14;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$2"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$2;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$3"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$3;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$4"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$4;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$5"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$5;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$6"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$6;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$7"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$7;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$8"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$8;
  type(
    classname: "org.bukkit.enchantments.EnchantmentTarget$9"
  ): typeof org$bukkit$enchantments$EnchantmentTarget$9;
  type(
    classname: "org.bukkit.enchantments.EnchantmentWrapper"
  ): typeof org$bukkit$enchantments$EnchantmentWrapper;
  type(
    classname: "org.bukkit.entity.Ambient"
  ): typeof org$bukkit$entity$Ambient;
  type(
    classname: "org.bukkit.entity.ArmorStand"
  ): typeof org$bukkit$entity$ArmorStand;
  type(
    classname: "org.bukkit.util.EulerAngle"
  ): typeof org$bukkit$util$EulerAngle;
  type(classname: "org.bukkit.entity.Bat"): typeof org$bukkit$entity$Bat;
  type(classname: "org.bukkit.entity.Bee"): typeof org$bukkit$entity$Bee;
  type(classname: "org.bukkit.entity.Blaze"): typeof org$bukkit$entity$Blaze;
  type(classname: "org.bukkit.entity.Boat"): typeof org$bukkit$entity$Boat;
  type(classname: "org.bukkit.TreeSpecies"): typeof org$bukkit$TreeSpecies;
  type(classname: "org.bukkit.entity.Cat"): typeof org$bukkit$entity$Cat;
  type(
    classname: "org.bukkit.entity.Sittable"
  ): typeof org$bukkit$entity$Sittable;
  type(
    classname: "org.bukkit.entity.Cat$Type"
  ): typeof org$bukkit$entity$Cat$Type;
  type(
    classname: "org.bukkit.entity.CaveSpider"
  ): typeof org$bukkit$entity$CaveSpider;
  type(classname: "org.bukkit.entity.Spider"): typeof org$bukkit$entity$Spider;
  type(
    classname: "org.bukkit.entity.ChestedHorse"
  ): typeof org$bukkit$entity$ChestedHorse;
  type(
    classname: "org.bukkit.entity.Chicken"
  ): typeof org$bukkit$entity$Chicken;
  type(classname: "org.bukkit.entity.Cod"): typeof org$bukkit$entity$Cod;
  type(classname: "org.bukkit.entity.Fish"): typeof org$bukkit$entity$Fish;
  type(
    classname: "org.bukkit.entity.WaterMob"
  ): typeof org$bukkit$entity$WaterMob;
  type(
    classname: "org.bukkit.entity.ComplexEntityPart"
  ): typeof org$bukkit$entity$ComplexEntityPart;
  type(classname: "org.bukkit.entity.Cow"): typeof org$bukkit$entity$Cow;
  type(
    classname: "org.bukkit.entity.Dolphin"
  ): typeof org$bukkit$entity$Dolphin;
  type(classname: "org.bukkit.entity.Donkey"): typeof org$bukkit$entity$Donkey;
  type(
    classname: "org.bukkit.entity.Drowned"
  ): typeof org$bukkit$entity$Drowned;
  type(classname: "org.bukkit.entity.Zombie"): typeof org$bukkit$entity$Zombie;
  type(
    classname: "org.bukkit.entity.ElderGuardian"
  ): typeof org$bukkit$entity$ElderGuardian;
  type(
    classname: "org.bukkit.entity.Guardian"
  ): typeof org$bukkit$entity$Guardian;
  type(
    classname: "org.bukkit.entity.EnderCrystal"
  ): typeof org$bukkit$entity$EnderCrystal;
  type(
    classname: "org.bukkit.entity.EnderDragonPart"
  ): typeof org$bukkit$entity$EnderDragonPart;
  type(
    classname: "org.bukkit.entity.Endermite"
  ): typeof org$bukkit$entity$Endermite;
  type(
    classname: "org.bukkit.entity.EnderPearl"
  ): typeof org$bukkit$entity$EnderPearl;
  type(
    classname: "org.bukkit.entity.EnderSignal"
  ): typeof org$bukkit$entity$EnderSignal;
  type(classname: "org.bukkit.entity.Evoker"): typeof org$bukkit$entity$Evoker;
  type(
    classname: "org.bukkit.entity.Illager"
  ): typeof org$bukkit$entity$Illager;
  type(
    classname: "org.bukkit.entity.Spellcaster"
  ): typeof org$bukkit$entity$Spellcaster;
  type(
    classname: "org.bukkit.entity.Spellcaster$Spell"
  ): typeof org$bukkit$entity$Spellcaster$Spell;
  type(
    classname: "org.bukkit.entity.Evoker$Spell"
  ): typeof org$bukkit$entity$Evoker$Spell;
  type(
    classname: "org.bukkit.entity.EvokerFangs"
  ): typeof org$bukkit$entity$EvokerFangs;
  type(
    classname: "org.bukkit.entity.FishHook"
  ): typeof org$bukkit$entity$FishHook;
  type(classname: "org.bukkit.entity.Flying"): typeof org$bukkit$entity$Flying;
  type(classname: "org.bukkit.entity.Fox"): typeof org$bukkit$entity$Fox;
  type(
    classname: "org.bukkit.entity.Fox$Type"
  ): typeof org$bukkit$entity$Fox$Type;
  type(classname: "org.bukkit.entity.Ghast"): typeof org$bukkit$entity$Ghast;
  type(classname: "org.bukkit.entity.Giant"): typeof org$bukkit$entity$Giant;
  type(classname: "org.bukkit.entity.Golem"): typeof org$bukkit$entity$Golem;
  type(
    classname: "org.bukkit.entity.Hanging"
  ): typeof org$bukkit$entity$Hanging;
  type(
    classname: "org.bukkit.material.Attachable"
  ): typeof org$bukkit$material$Attachable;
  type(
    classname: "org.bukkit.material.Directional"
  ): typeof org$bukkit$material$Directional;
  type(classname: "org.bukkit.entity.Horse"): typeof org$bukkit$entity$Horse;
  type(
    classname: "org.bukkit.entity.Horse$Color"
  ): typeof org$bukkit$entity$Horse$Color;
  type(
    classname: "org.bukkit.entity.Horse$Style"
  ): typeof org$bukkit$entity$Horse$Style;
  type(
    classname: "org.bukkit.inventory.HorseInventory"
  ): typeof org$bukkit$inventory$HorseInventory;
  type(
    classname: "org.bukkit.inventory.ArmoredHorseInventory"
  ): typeof org$bukkit$inventory$ArmoredHorseInventory;
  type(classname: "org.bukkit.entity.Husk"): typeof org$bukkit$entity$Husk;
  type(
    classname: "org.bukkit.entity.Illusioner"
  ): typeof org$bukkit$entity$Illusioner;
  type(
    classname: "org.bukkit.entity.IronGolem"
  ): typeof org$bukkit$entity$IronGolem;
  type(
    classname: "org.bukkit.entity.ItemFrame"
  ): typeof org$bukkit$entity$ItemFrame;
  type(classname: "org.bukkit.Rotation"): typeof org$bukkit$Rotation;
  type(
    classname: "org.bukkit.entity.LargeFireball"
  ): typeof org$bukkit$entity$LargeFireball;
  type(
    classname: "org.bukkit.entity.SizedFireball"
  ): typeof org$bukkit$entity$SizedFireball;
  type(
    classname: "org.bukkit.entity.LeashHitch"
  ): typeof org$bukkit$entity$LeashHitch;
  type(
    classname: "org.bukkit.entity.LingeringPotion"
  ): typeof org$bukkit$entity$LingeringPotion;
  type(
    classname: "org.bukkit.entity.ThrownPotion"
  ): typeof org$bukkit$entity$ThrownPotion;
  type(classname: "org.bukkit.entity.Llama"): typeof org$bukkit$entity$Llama;
  type(
    classname: "org.bukkit.entity.Llama$Color"
  ): typeof org$bukkit$entity$Llama$Color;
  type(
    classname: "org.bukkit.inventory.LlamaInventory"
  ): typeof org$bukkit$inventory$LlamaInventory;
  type(
    classname: "org.bukkit.inventory.SaddledHorseInventory"
  ): typeof org$bukkit$inventory$SaddledHorseInventory;
  type(
    classname: "org.bukkit.entity.LlamaSpit"
  ): typeof org$bukkit$entity$LlamaSpit;
  type(
    classname: "org.bukkit.entity.MagmaCube"
  ): typeof org$bukkit$entity$MagmaCube;
  type(
    classname: "org.bukkit.entity.Minecart"
  ): typeof org$bukkit$entity$Minecart;
  type(
    classname: "org.bukkit.entity.minecart.CommandMinecart"
  ): typeof org$bukkit$entity$minecart$CommandMinecart;
  type(
    classname: "org.bukkit.entity.minecart.ExplosiveMinecart"
  ): typeof org$bukkit$entity$minecart$ExplosiveMinecart;
  type(
    classname: "org.bukkit.entity.minecart.HopperMinecart"
  ): typeof org$bukkit$entity$minecart$HopperMinecart;
  type(
    classname: "org.bukkit.entity.minecart.PoweredMinecart"
  ): typeof org$bukkit$entity$minecart$PoweredMinecart;
  type(
    classname: "org.bukkit.entity.minecart.RideableMinecart"
  ): typeof org$bukkit$entity$minecart$RideableMinecart;
  type(
    classname: "org.bukkit.entity.minecart.SpawnerMinecart"
  ): typeof org$bukkit$entity$minecart$SpawnerMinecart;
  type(
    classname: "org.bukkit.entity.minecart.StorageMinecart"
  ): typeof org$bukkit$entity$minecart$StorageMinecart;
  type(classname: "org.bukkit.entity.Mule"): typeof org$bukkit$entity$Mule;
  type(
    classname: "org.bukkit.entity.MushroomCow"
  ): typeof org$bukkit$entity$MushroomCow;
  type(
    classname: "org.bukkit.entity.MushroomCow$Variant"
  ): typeof org$bukkit$entity$MushroomCow$Variant;
  type(classname: "org.bukkit.entity.Ocelot"): typeof org$bukkit$entity$Ocelot;
  type(
    classname: "org.bukkit.entity.Ocelot$Type"
  ): typeof org$bukkit$entity$Ocelot$Type;
  type(
    classname: "org.bukkit.entity.Painting"
  ): typeof org$bukkit$entity$Painting;
  type(classname: "org.bukkit.entity.Panda"): typeof org$bukkit$entity$Panda;
  type(
    classname: "org.bukkit.entity.Panda$Gene"
  ): typeof org$bukkit$entity$Panda$Gene;
  type(classname: "org.bukkit.entity.Parrot"): typeof org$bukkit$entity$Parrot;
  type(
    classname: "org.bukkit.entity.Parrot$Variant"
  ): typeof org$bukkit$entity$Parrot$Variant;
  type(
    classname: "org.bukkit.entity.Phantom"
  ): typeof org$bukkit$entity$Phantom;
  type(classname: "org.bukkit.entity.Pig"): typeof org$bukkit$entity$Pig;
  type(
    classname: "org.bukkit.entity.PigZombie"
  ): typeof org$bukkit$entity$PigZombie;
  type(
    classname: "org.bukkit.entity.Pillager"
  ): typeof org$bukkit$entity$Pillager;
  type(
    classname: "org.bukkit.entity.PolarBear"
  ): typeof org$bukkit$entity$PolarBear;
  type(
    classname: "org.bukkit.entity.PufferFish"
  ): typeof org$bukkit$entity$PufferFish;
  type(classname: "org.bukkit.entity.Rabbit"): typeof org$bukkit$entity$Rabbit;
  type(
    classname: "org.bukkit.entity.Rabbit$Type"
  ): typeof org$bukkit$entity$Rabbit$Type;
  type(
    classname: "org.bukkit.entity.Ravager"
  ): typeof org$bukkit$entity$Ravager;
  type(classname: "org.bukkit.entity.Salmon"): typeof org$bukkit$entity$Salmon;
  type(classname: "org.bukkit.entity.Sheep"): typeof org$bukkit$entity$Sheep;
  type(
    classname: "org.bukkit.entity.Shulker"
  ): typeof org$bukkit$entity$Shulker;
  type(
    classname: "org.bukkit.entity.ShulkerBullet"
  ): typeof org$bukkit$entity$ShulkerBullet;
  type(
    classname: "org.bukkit.entity.Silverfish"
  ): typeof org$bukkit$entity$Silverfish;
  type(
    classname: "org.bukkit.entity.Skeleton"
  ): typeof org$bukkit$entity$Skeleton;
  type(
    classname: "org.bukkit.entity.Skeleton$SkeletonType"
  ): typeof org$bukkit$entity$Skeleton$SkeletonType;
  type(
    classname: "org.bukkit.entity.SmallFireball"
  ): typeof org$bukkit$entity$SmallFireball;
  type(
    classname: "org.bukkit.entity.Snowball"
  ): typeof org$bukkit$entity$Snowball;
  type(
    classname: "org.bukkit.entity.Snowman"
  ): typeof org$bukkit$entity$Snowman;
  type(
    classname: "org.bukkit.entity.SpectralArrow"
  ): typeof org$bukkit$entity$SpectralArrow;
  type(
    classname: "org.bukkit.entity.SplashPotion"
  ): typeof org$bukkit$entity$SplashPotion;
  type(classname: "org.bukkit.entity.Squid"): typeof org$bukkit$entity$Squid;
  type(classname: "org.bukkit.entity.Stray"): typeof org$bukkit$entity$Stray;
  type(
    classname: "org.bukkit.entity.ThrownExpBottle"
  ): typeof org$bukkit$entity$ThrownExpBottle;
  type(
    classname: "org.bukkit.entity.TippedArrow"
  ): typeof org$bukkit$entity$TippedArrow;
  type(
    classname: "org.bukkit.entity.TNTPrimed"
  ): typeof org$bukkit$entity$TNTPrimed;
  type(
    classname: "org.bukkit.entity.TraderLlama"
  ): typeof org$bukkit$entity$TraderLlama;
  type(
    classname: "org.bukkit.entity.Trident"
  ): typeof org$bukkit$entity$Trident;
  type(
    classname: "org.bukkit.entity.TropicalFish"
  ): typeof org$bukkit$entity$TropicalFish;
  type(
    classname: "org.bukkit.entity.TropicalFish$Pattern"
  ): typeof org$bukkit$entity$TropicalFish$Pattern;
  type(classname: "org.bukkit.entity.Vex"): typeof org$bukkit$entity$Vex;
  type(
    classname: "org.bukkit.entity.Vindicator"
  ): typeof org$bukkit$entity$Vindicator;
  type(
    classname: "org.bukkit.entity.WanderingTrader"
  ): typeof org$bukkit$entity$WanderingTrader;
  type(classname: "org.bukkit.entity.Wither"): typeof org$bukkit$entity$Wither;
  type(
    classname: "org.bukkit.entity.WitherSkeleton"
  ): typeof org$bukkit$entity$WitherSkeleton;
  type(
    classname: "org.bukkit.entity.WitherSkull"
  ): typeof org$bukkit$entity$WitherSkull;
  type(classname: "org.bukkit.entity.Wolf"): typeof org$bukkit$entity$Wolf;
  type(
    classname: "org.bukkit.entity.ZombieHorse"
  ): typeof org$bukkit$entity$ZombieHorse;
  type(
    classname: "org.bukkit.entity.ZombieVillager"
  ): typeof org$bukkit$entity$ZombieVillager;
  type(
    classname: "org.bukkit.event.block.Action"
  ): typeof org$bukkit$event$block$Action;
  type(
    classname: "org.bukkit.event.block.BlockBreakEvent"
  ): typeof org$bukkit$event$block$BlockBreakEvent;
  type(
    classname: "org.bukkit.event.block.BlockBurnEvent"
  ): typeof org$bukkit$event$block$BlockBurnEvent;
  type(
    classname: "org.bukkit.event.block.BlockCanBuildEvent"
  ): typeof org$bukkit$event$block$BlockCanBuildEvent;
  type(
    classname: "org.bukkit.event.block.BlockCookEvent"
  ): typeof org$bukkit$event$block$BlockCookEvent;
  type(
    classname: "org.bukkit.event.block.BlockDamageEvent"
  ): typeof org$bukkit$event$block$BlockDamageEvent;
  type(
    classname: "org.bukkit.event.block.BlockDispenseArmorEvent"
  ): typeof org$bukkit$event$block$BlockDispenseArmorEvent;
  type(
    classname: "org.bukkit.event.block.BlockDispenseEvent"
  ): typeof org$bukkit$event$block$BlockDispenseEvent;
  type(
    classname: "org.bukkit.event.block.BlockDropItemEvent"
  ): typeof org$bukkit$event$block$BlockDropItemEvent;
  type(
    classname: "org.bukkit.event.block.BlockEvent"
  ): typeof org$bukkit$event$block$BlockEvent;
  type(
    classname: "org.bukkit.event.block.BlockExpEvent"
  ): typeof org$bukkit$event$block$BlockExpEvent;
  type(
    classname: "org.bukkit.event.block.BlockExplodeEvent"
  ): typeof org$bukkit$event$block$BlockExplodeEvent;
  type(
    classname: "org.bukkit.event.block.BlockFadeEvent"
  ): typeof org$bukkit$event$block$BlockFadeEvent;
  type(
    classname: "org.bukkit.event.block.BlockFertilizeEvent"
  ): typeof org$bukkit$event$block$BlockFertilizeEvent;
  type(
    classname: "org.bukkit.event.block.BlockFormEvent"
  ): typeof org$bukkit$event$block$BlockFormEvent;
  type(
    classname: "org.bukkit.event.block.BlockFromToEvent"
  ): typeof org$bukkit$event$block$BlockFromToEvent;
  type(
    classname: "org.bukkit.event.block.BlockGrowEvent"
  ): typeof org$bukkit$event$block$BlockGrowEvent;
  type(
    classname: "org.bukkit.event.block.BlockIgniteEvent"
  ): typeof org$bukkit$event$block$BlockIgniteEvent;
  type(
    classname: "org.bukkit.event.block.BlockIgniteEvent$IgniteCause"
  ): typeof org$bukkit$event$block$BlockIgniteEvent$IgniteCause;
  type(
    classname: "org.bukkit.event.block.BlockMultiPlaceEvent"
  ): typeof org$bukkit$event$block$BlockMultiPlaceEvent;
  type(
    classname: "org.bukkit.event.block.BlockPhysicsEvent"
  ): typeof org$bukkit$event$block$BlockPhysicsEvent;
  type(
    classname: "org.bukkit.event.block.BlockPistonEvent"
  ): typeof org$bukkit$event$block$BlockPistonEvent;
  type(
    classname: "org.bukkit.event.block.BlockPistonExtendEvent"
  ): typeof org$bukkit$event$block$BlockPistonExtendEvent;
  type(
    classname: "org.bukkit.event.block.BlockPistonRetractEvent"
  ): typeof org$bukkit$event$block$BlockPistonRetractEvent;
  type(
    classname: "org.bukkit.event.block.BlockPlaceEvent"
  ): typeof org$bukkit$event$block$BlockPlaceEvent;
  type(
    classname: "org.bukkit.event.block.BlockRedstoneEvent"
  ): typeof org$bukkit$event$block$BlockRedstoneEvent;
  type(
    classname: "org.bukkit.event.block.BlockShearEntityEvent"
  ): typeof org$bukkit$event$block$BlockShearEntityEvent;
  type(
    classname: "org.bukkit.event.block.BlockSpreadEvent"
  ): typeof org$bukkit$event$block$BlockSpreadEvent;
  type(
    classname: "org.bukkit.event.block.CauldronLevelChangeEvent"
  ): typeof org$bukkit$event$block$CauldronLevelChangeEvent;
  type(
    classname: "org.bukkit.event.block.CauldronLevelChangeEvent$ChangeReason"
  ): typeof org$bukkit$event$block$CauldronLevelChangeEvent$ChangeReason;
  type(
    classname: "org.bukkit.event.block.EntityBlockFormEvent"
  ): typeof org$bukkit$event$block$EntityBlockFormEvent;
  type(
    classname: "org.bukkit.event.block.FluidLevelChangeEvent"
  ): typeof org$bukkit$event$block$FluidLevelChangeEvent;
  type(
    classname: "org.bukkit.event.block.LeavesDecayEvent"
  ): typeof org$bukkit$event$block$LeavesDecayEvent;
  type(
    classname: "org.bukkit.event.block.MoistureChangeEvent"
  ): typeof org$bukkit$event$block$MoistureChangeEvent;
  type(
    classname: "org.bukkit.event.block.NotePlayEvent"
  ): typeof org$bukkit$event$block$NotePlayEvent;
  type(
    classname: "org.bukkit.event.block.SignChangeEvent"
  ): typeof org$bukkit$event$block$SignChangeEvent;
  type(
    classname: "org.bukkit.event.block.SpongeAbsorbEvent"
  ): typeof org$bukkit$event$block$SpongeAbsorbEvent;
  type(
    classname: "org.bukkit.event.command.UnknownCommandEvent"
  ): typeof org$bukkit$event$command$UnknownCommandEvent;
  type(
    classname: "org.bukkit.event.enchantment.EnchantItemEvent"
  ): typeof org$bukkit$event$enchantment$EnchantItemEvent;
  type(
    classname: "org.bukkit.event.enchantment.PrepareItemEnchantEvent"
  ): typeof org$bukkit$event$enchantment$PrepareItemEnchantEvent;
  type(
    classname: "org.bukkit.event.entity.AreaEffectCloudApplyEvent"
  ): typeof org$bukkit$event$entity$AreaEffectCloudApplyEvent;
  type(
    classname: "org.bukkit.event.entity.BatToggleSleepEvent"
  ): typeof org$bukkit$event$entity$BatToggleSleepEvent;
  type(
    classname: "org.bukkit.event.entity.CreatureSpawnEvent"
  ): typeof org$bukkit$event$entity$CreatureSpawnEvent;
  type(
    classname: "org.bukkit.event.entity.CreeperPowerEvent"
  ): typeof org$bukkit$event$entity$CreeperPowerEvent;
  type(
    classname: "org.bukkit.event.entity.CreeperPowerEvent$PowerCause"
  ): typeof org$bukkit$event$entity$CreeperPowerEvent$PowerCause;
  type(
    classname: "org.bukkit.event.entity.EnderDragonChangePhaseEvent"
  ): typeof org$bukkit$event$entity$EnderDragonChangePhaseEvent;
  type(
    classname: "org.bukkit.event.entity.EntityAirChangeEvent"
  ): typeof org$bukkit$event$entity$EntityAirChangeEvent;
  type(
    classname: "org.bukkit.event.entity.EntityBreakDoorEvent"
  ): typeof org$bukkit$event$entity$EntityBreakDoorEvent;
  type(
    classname: "org.bukkit.event.entity.EntityBreedEvent"
  ): typeof org$bukkit$event$entity$EntityBreedEvent;
  type(
    classname: "org.bukkit.event.entity.EntityChangeBlockEvent"
  ): typeof org$bukkit$event$entity$EntityChangeBlockEvent;
  type(
    classname: "org.bukkit.event.entity.EntityCombustByBlockEvent"
  ): typeof org$bukkit$event$entity$EntityCombustByBlockEvent;
  type(
    classname: "org.bukkit.event.entity.EntityCombustByEntityEvent"
  ): typeof org$bukkit$event$entity$EntityCombustByEntityEvent;
  type(
    classname: "org.bukkit.event.entity.EntityCombustEvent"
  ): typeof org$bukkit$event$entity$EntityCombustEvent;
  type(
    classname: "org.bukkit.event.entity.EntityCreatePortalEvent"
  ): typeof org$bukkit$event$entity$EntityCreatePortalEvent;
  type(classname: "org.bukkit.PortalType"): typeof org$bukkit$PortalType;
  type(
    classname: "org.bukkit.event.entity.EntityDamageByBlockEvent"
  ): typeof org$bukkit$event$entity$EntityDamageByBlockEvent;
  type(
    classname: "org.bukkit.event.entity.EntityDamageByEntityEvent"
  ): typeof org$bukkit$event$entity$EntityDamageByEntityEvent;
  type(
    classname: "org.bukkit.event.entity.EntityDeathEvent"
  ): typeof org$bukkit$event$entity$EntityDeathEvent;
  type(
    classname: "org.bukkit.event.entity.EntityDropItemEvent"
  ): typeof org$bukkit$event$entity$EntityDropItemEvent;
  type(
    classname: "org.bukkit.event.entity.EntityEnterBlockEvent"
  ): typeof org$bukkit$event$entity$EntityEnterBlockEvent;
  type(
    classname: "org.bukkit.event.entity.EntityEvent"
  ): typeof org$bukkit$event$entity$EntityEvent;
  type(
    classname: "org.bukkit.event.entity.EntityExplodeEvent"
  ): typeof org$bukkit$event$entity$EntityExplodeEvent;
  type(
    classname: "org.bukkit.event.entity.EntityInteractEvent"
  ): typeof org$bukkit$event$entity$EntityInteractEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPickupItemEvent"
  ): typeof org$bukkit$event$entity$EntityPickupItemEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPlaceEvent"
  ): typeof org$bukkit$event$entity$EntityPlaceEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPortalEnterEvent"
  ): typeof org$bukkit$event$entity$EntityPortalEnterEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPortalEvent"
  ): typeof org$bukkit$event$entity$EntityPortalEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPortalExitEvent"
  ): typeof org$bukkit$event$entity$EntityPortalExitEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPoseChangeEvent"
  ): typeof org$bukkit$event$entity$EntityPoseChangeEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPotionEffectEvent"
  ): typeof org$bukkit$event$entity$EntityPotionEffectEvent;
  type(
    classname: "org.bukkit.event.entity.EntityPotionEffectEvent$Cause"
  ): typeof org$bukkit$event$entity$EntityPotionEffectEvent$Cause;
  type(
    classname: "org.bukkit.event.entity.EntityPotionEffectEvent$Action"
  ): typeof org$bukkit$event$entity$EntityPotionEffectEvent$Action;
  type(
    classname: "org.bukkit.event.entity.EntityRegainHealthEvent"
  ): typeof org$bukkit$event$entity$EntityRegainHealthEvent;
  type(
    classname: "org.bukkit.event.entity.EntityRegainHealthEvent$RegainReason"
  ): typeof org$bukkit$event$entity$EntityRegainHealthEvent$RegainReason;
  type(
    classname: "org.bukkit.event.entity.EntityResurrectEvent"
  ): typeof org$bukkit$event$entity$EntityResurrectEvent;
  type(
    classname: "org.bukkit.event.entity.EntityShootBowEvent"
  ): typeof org$bukkit$event$entity$EntityShootBowEvent;
  type(
    classname: "org.bukkit.event.entity.EntitySpawnEvent"
  ): typeof org$bukkit$event$entity$EntitySpawnEvent;
  type(
    classname: "org.bukkit.event.entity.EntityTameEvent"
  ): typeof org$bukkit$event$entity$EntityTameEvent;
  type(
    classname: "org.bukkit.event.entity.EntityTargetEvent"
  ): typeof org$bukkit$event$entity$EntityTargetEvent;
  type(
    classname: "org.bukkit.event.entity.EntityTargetEvent$TargetReason"
  ): typeof org$bukkit$event$entity$EntityTargetEvent$TargetReason;
  type(
    classname: "org.bukkit.event.entity.EntityTargetLivingEntityEvent"
  ): typeof org$bukkit$event$entity$EntityTargetLivingEntityEvent;
  type(
    classname: "org.bukkit.event.entity.EntityTeleportEvent"
  ): typeof org$bukkit$event$entity$EntityTeleportEvent;
  type(
    classname: "org.bukkit.event.entity.EntityToggleGlideEvent"
  ): typeof org$bukkit$event$entity$EntityToggleGlideEvent;
  type(
    classname: "org.bukkit.event.entity.EntityToggleSwimEvent"
  ): typeof org$bukkit$event$entity$EntityToggleSwimEvent;
  type(
    classname: "org.bukkit.event.entity.EntityTransformEvent"
  ): typeof org$bukkit$event$entity$EntityTransformEvent;
  type(
    classname: "org.bukkit.event.entity.EntityTransformEvent$TransformReason"
  ): typeof org$bukkit$event$entity$EntityTransformEvent$TransformReason;
  type(
    classname: "org.bukkit.event.entity.EntityUnleashEvent"
  ): typeof org$bukkit$event$entity$EntityUnleashEvent;
  type(
    classname: "org.bukkit.event.entity.EntityUnleashEvent$UnleashReason"
  ): typeof org$bukkit$event$entity$EntityUnleashEvent$UnleashReason;
  type(
    classname: "org.bukkit.event.entity.ExpBottleEvent"
  ): typeof org$bukkit$event$entity$ExpBottleEvent;
  type(
    classname: "org.bukkit.event.entity.ExplosionPrimeEvent"
  ): typeof org$bukkit$event$entity$ExplosionPrimeEvent;
  type(
    classname: "org.bukkit.event.entity.FireworkExplodeEvent"
  ): typeof org$bukkit$event$entity$FireworkExplodeEvent;
  type(
    classname: "org.bukkit.event.entity.FoodLevelChangeEvent"
  ): typeof org$bukkit$event$entity$FoodLevelChangeEvent;
  type(
    classname: "org.bukkit.event.entity.HorseJumpEvent"
  ): typeof org$bukkit$event$entity$HorseJumpEvent;
  type(
    classname: "org.bukkit.event.entity.ItemDespawnEvent"
  ): typeof org$bukkit$event$entity$ItemDespawnEvent;
  type(
    classname: "org.bukkit.event.entity.ItemMergeEvent"
  ): typeof org$bukkit$event$entity$ItemMergeEvent;
  type(
    classname: "org.bukkit.event.entity.ItemSpawnEvent"
  ): typeof org$bukkit$event$entity$ItemSpawnEvent;
  type(
    classname: "org.bukkit.event.entity.LingeringPotionSplashEvent"
  ): typeof org$bukkit$event$entity$LingeringPotionSplashEvent;
  type(
    classname: "org.bukkit.event.entity.PigZapEvent"
  ): typeof org$bukkit$event$entity$PigZapEvent;
  type(
    classname: "org.bukkit.event.entity.PigZombieAngerEvent"
  ): typeof org$bukkit$event$entity$PigZombieAngerEvent;
  type(
    classname: "org.bukkit.event.entity.PlayerDeathEvent"
  ): typeof org$bukkit$event$entity$PlayerDeathEvent;
  type(
    classname: "org.bukkit.event.entity.PlayerLeashEntityEvent"
  ): typeof org$bukkit$event$entity$PlayerLeashEntityEvent;
  type(
    classname: "org.bukkit.event.entity.PotionSplashEvent"
  ): typeof org$bukkit$event$entity$PotionSplashEvent;
  type(
    classname: "org.bukkit.event.entity.ProjectileHitEvent"
  ): typeof org$bukkit$event$entity$ProjectileHitEvent;
  type(
    classname: "org.bukkit.event.entity.ProjectileLaunchEvent"
  ): typeof org$bukkit$event$entity$ProjectileLaunchEvent;
  type(
    classname: "org.bukkit.event.entity.SheepDyeWoolEvent"
  ): typeof org$bukkit$event$entity$SheepDyeWoolEvent;
  type(
    classname: "org.bukkit.event.entity.SheepRegrowWoolEvent"
  ): typeof org$bukkit$event$entity$SheepRegrowWoolEvent;
  type(
    classname: "org.bukkit.event.entity.SlimeSplitEvent"
  ): typeof org$bukkit$event$entity$SlimeSplitEvent;
  type(
    classname: "org.bukkit.event.entity.SpawnerSpawnEvent"
  ): typeof org$bukkit$event$entity$SpawnerSpawnEvent;
  type(
    classname: "org.bukkit.event.entity.VillagerAcquireTradeEvent"
  ): typeof org$bukkit$event$entity$VillagerAcquireTradeEvent;
  type(
    classname: "org.bukkit.event.entity.VillagerCareerChangeEvent"
  ): typeof org$bukkit$event$entity$VillagerCareerChangeEvent;
  type(
    classname: "org.bukkit.event.entity.VillagerCareerChangeEvent$ChangeReason"
  ): typeof org$bukkit$event$entity$VillagerCareerChangeEvent$ChangeReason;
  type(
    classname: "org.bukkit.event.entity.VillagerReplenishTradeEvent"
  ): typeof org$bukkit$event$entity$VillagerReplenishTradeEvent;
  type(
    classname: "org.bukkit.event.Event$Result"
  ): typeof org$bukkit$event$Event$Result;
  type(
    classname: "org.bukkit.event.EventException"
  ): typeof org$bukkit$event$EventException;
  type(
    classname: "org.bukkit.event.EventHandler"
  ): typeof org$bukkit$event$EventHandler;
  type(
    classname: "org.bukkit.event.hanging.HangingBreakByEntityEvent"
  ): typeof org$bukkit$event$hanging$HangingBreakByEntityEvent;
  type(
    classname: "org.bukkit.event.hanging.HangingBreakEvent$RemoveCause"
  ): typeof org$bukkit$event$hanging$HangingBreakEvent$RemoveCause;
  type(
    classname: "org.bukkit.event.hanging.HangingBreakEvent"
  ): typeof org$bukkit$event$hanging$HangingBreakEvent;
  type(
    classname: "org.bukkit.event.hanging.HangingEvent"
  ): typeof org$bukkit$event$hanging$HangingEvent;
  type(
    classname: "org.bukkit.event.hanging.HangingPlaceEvent"
  ): typeof org$bukkit$event$hanging$HangingPlaceEvent;
  type(
    classname: "org.bukkit.event.inventory.BrewEvent"
  ): typeof org$bukkit$event$inventory$BrewEvent;
  type(
    classname: "org.bukkit.event.inventory.BrewingStandFuelEvent"
  ): typeof org$bukkit$event$inventory$BrewingStandFuelEvent;
  type(
    classname: "org.bukkit.event.inventory.ClickType"
  ): typeof org$bukkit$event$inventory$ClickType;
  type(
    classname: "org.bukkit.event.inventory.CraftItemEvent"
  ): typeof org$bukkit$event$inventory$CraftItemEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryAction"
  ): typeof org$bukkit$event$inventory$InventoryAction;
  type(
    classname: "org.bukkit.inventory.CraftingInventory"
  ): typeof org$bukkit$inventory$CraftingInventory;
  type(
    classname: "org.bukkit.event.inventory.DragType"
  ): typeof org$bukkit$event$inventory$DragType;
  type(
    classname: "org.bukkit.event.inventory.FurnaceBurnEvent"
  ): typeof org$bukkit$event$inventory$FurnaceBurnEvent;
  type(
    classname: "org.bukkit.event.inventory.FurnaceExtractEvent"
  ): typeof org$bukkit$event$inventory$FurnaceExtractEvent;
  type(
    classname: "org.bukkit.event.inventory.FurnaceSmeltEvent"
  ): typeof org$bukkit$event$inventory$FurnaceSmeltEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryClickEvent"
  ): typeof org$bukkit$event$inventory$InventoryClickEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryCloseEvent"
  ): typeof org$bukkit$event$inventory$InventoryCloseEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryCreativeEvent"
  ): typeof org$bukkit$event$inventory$InventoryCreativeEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryDragEvent"
  ): typeof org$bukkit$event$inventory$InventoryDragEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryEvent"
  ): typeof org$bukkit$event$inventory$InventoryEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryInteractEvent"
  ): typeof org$bukkit$event$inventory$InventoryInteractEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryMoveItemEvent"
  ): typeof org$bukkit$event$inventory$InventoryMoveItemEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryOpenEvent"
  ): typeof org$bukkit$event$inventory$InventoryOpenEvent;
  type(
    classname: "org.bukkit.event.inventory.InventoryPickupItemEvent"
  ): typeof org$bukkit$event$inventory$InventoryPickupItemEvent;
  type(
    classname: "org.bukkit.event.inventory.PrepareAnvilEvent"
  ): typeof org$bukkit$event$inventory$PrepareAnvilEvent;
  type(
    classname: "org.bukkit.event.inventory.PrepareItemCraftEvent"
  ): typeof org$bukkit$event$inventory$PrepareItemCraftEvent;
  type(
    classname: "org.bukkit.event.inventory.TradeSelectEvent"
  ): typeof org$bukkit$event$inventory$TradeSelectEvent;
  type(
    classname: "org.bukkit.inventory.MerchantInventory"
  ): typeof org$bukkit$inventory$MerchantInventory;
  type(
    classname: "org.bukkit.event.player.AsyncPlayerChatEvent"
  ): typeof org$bukkit$event$player$AsyncPlayerChatEvent;
  type(
    classname: "org.bukkit.event.player.AsyncPlayerPreLoginEvent"
  ): typeof org$bukkit$event$player$AsyncPlayerPreLoginEvent;
  type(
    classname: "org.bukkit.event.player.AsyncPlayerPreLoginEvent$Result"
  ): typeof org$bukkit$event$player$AsyncPlayerPreLoginEvent$Result;
  type(
    classname: "org.bukkit.event.player.PlayerPreLoginEvent$Result"
  ): typeof org$bukkit$event$player$PlayerPreLoginEvent$Result;
  type(
    classname: "org.bukkit.event.player.PlayerAdvancementDoneEvent"
  ): typeof org$bukkit$event$player$PlayerAdvancementDoneEvent;
  type(
    classname: "org.bukkit.event.player.PlayerAnimationEvent"
  ): typeof org$bukkit$event$player$PlayerAnimationEvent;
  type(
    classname: "org.bukkit.event.player.PlayerAnimationType"
  ): typeof org$bukkit$event$player$PlayerAnimationType;
  type(
    classname: "org.bukkit.event.player.PlayerArmorStandManipulateEvent"
  ): typeof org$bukkit$event$player$PlayerArmorStandManipulateEvent;
  type(
    classname: "org.bukkit.event.player.PlayerAttemptPickupItemEvent"
  ): typeof org$bukkit$event$player$PlayerAttemptPickupItemEvent;
  type(
    classname: "org.bukkit.event.player.PlayerBedEnterEvent"
  ): typeof org$bukkit$event$player$PlayerBedEnterEvent;
  type(
    classname: "org.bukkit.event.player.PlayerBedEnterEvent$BedEnterResult"
  ): typeof org$bukkit$event$player$PlayerBedEnterEvent$BedEnterResult;
  type(
    classname: "org.bukkit.event.player.PlayerBedLeaveEvent"
  ): typeof org$bukkit$event$player$PlayerBedLeaveEvent;
  type(
    classname: "org.bukkit.event.player.PlayerBucketEmptyEvent"
  ): typeof org$bukkit$event$player$PlayerBucketEmptyEvent;
  type(
    classname: "org.bukkit.event.player.PlayerBucketEvent"
  ): typeof org$bukkit$event$player$PlayerBucketEvent;
  type(
    classname: "org.bukkit.event.player.PlayerBucketFillEvent"
  ): typeof org$bukkit$event$player$PlayerBucketFillEvent;
  type(
    classname: "org.bukkit.event.player.PlayerChangedMainHandEvent"
  ): typeof org$bukkit$event$player$PlayerChangedMainHandEvent;
  type(
    classname: "org.bukkit.event.player.PlayerChangedWorldEvent"
  ): typeof org$bukkit$event$player$PlayerChangedWorldEvent;
  type(
    classname: "org.bukkit.event.player.PlayerChannelEvent"
  ): typeof org$bukkit$event$player$PlayerChannelEvent;
  type(
    classname: "org.bukkit.event.player.PlayerChatEvent"
  ): typeof org$bukkit$event$player$PlayerChatEvent;
  type(
    classname: "org.bukkit.event.player.PlayerChatTabCompleteEvent"
  ): typeof org$bukkit$event$player$PlayerChatTabCompleteEvent;
  type(
    classname: "org.bukkit.event.player.PlayerCommandPreprocessEvent"
  ): typeof org$bukkit$event$player$PlayerCommandPreprocessEvent;
  type(
    classname: "org.bukkit.event.player.PlayerCommandSendEvent"
  ): typeof org$bukkit$event$player$PlayerCommandSendEvent;
  type(
    classname: "org.bukkit.event.player.PlayerDropItemEvent"
  ): typeof org$bukkit$event$player$PlayerDropItemEvent;
  type(
    classname: "org.bukkit.event.player.PlayerEditBookEvent"
  ): typeof org$bukkit$event$player$PlayerEditBookEvent;
  type(
    classname: "org.bukkit.inventory.meta.BookMeta"
  ): typeof org$bukkit$inventory$meta$BookMeta;
  type(
    classname: "org.bukkit.inventory.meta.BookMeta$Generation"
  ): typeof org$bukkit$inventory$meta$BookMeta$Generation;
  type(
    classname: "org.bukkit.inventory.meta.BookMeta$Spigot"
  ): typeof org$bukkit$inventory$meta$BookMeta$Spigot;
  type(
    classname: "org.bukkit.event.player.PlayerEggThrowEvent"
  ): typeof org$bukkit$event$player$PlayerEggThrowEvent;
  type(
    classname: "org.bukkit.event.player.PlayerEvent"
  ): typeof org$bukkit$event$player$PlayerEvent;
  type(
    classname: "org.bukkit.event.player.PlayerExpChangeEvent"
  ): typeof org$bukkit$event$player$PlayerExpChangeEvent;
  type(
    classname: "org.bukkit.event.player.PlayerFishEvent"
  ): typeof org$bukkit$event$player$PlayerFishEvent;
  type(
    classname: "org.bukkit.event.player.PlayerFishEvent$State"
  ): typeof org$bukkit$event$player$PlayerFishEvent$State;
  type(
    classname: "org.bukkit.event.player.PlayerGameModeChangeEvent"
  ): typeof org$bukkit$event$player$PlayerGameModeChangeEvent;
  type(
    classname: "org.bukkit.event.player.PlayerInteractAtEntityEvent"
  ): typeof org$bukkit$event$player$PlayerInteractAtEntityEvent;
  type(
    classname: "org.bukkit.event.player.PlayerInteractEntityEvent"
  ): typeof org$bukkit$event$player$PlayerInteractEntityEvent;
  type(
    classname: "org.bukkit.event.player.PlayerInteractEvent"
  ): typeof org$bukkit$event$player$PlayerInteractEvent;
  type(
    classname: "org.bukkit.event.player.PlayerItemBreakEvent"
  ): typeof org$bukkit$event$player$PlayerItemBreakEvent;
  type(
    classname: "org.bukkit.event.player.PlayerItemConsumeEvent"
  ): typeof org$bukkit$event$player$PlayerItemConsumeEvent;
  type(
    classname: "org.bukkit.event.player.PlayerItemDamageEvent"
  ): typeof org$bukkit$event$player$PlayerItemDamageEvent;
  type(
    classname: "org.bukkit.event.player.PlayerItemHeldEvent"
  ): typeof org$bukkit$event$player$PlayerItemHeldEvent;
  type(
    classname: "org.bukkit.event.player.PlayerItemMendEvent"
  ): typeof org$bukkit$event$player$PlayerItemMendEvent;
  type(
    classname: "org.bukkit.event.player.PlayerJoinEvent"
  ): typeof org$bukkit$event$player$PlayerJoinEvent;
  type(
    classname: "org.bukkit.event.player.PlayerKickEvent"
  ): typeof org$bukkit$event$player$PlayerKickEvent;
  type(
    classname: "org.bukkit.event.player.PlayerLevelChangeEvent"
  ): typeof org$bukkit$event$player$PlayerLevelChangeEvent;
  type(
    classname: "org.bukkit.event.player.PlayerLocaleChangeEvent"
  ): typeof org$bukkit$event$player$PlayerLocaleChangeEvent;
  type(
    classname: "org.bukkit.event.player.PlayerLoginEvent"
  ): typeof org$bukkit$event$player$PlayerLoginEvent;
  type(
    classname: "org.bukkit.event.player.PlayerLoginEvent$Result"
  ): typeof org$bukkit$event$player$PlayerLoginEvent$Result;
  type(
    classname: "org.bukkit.event.player.PlayerMoveEvent"
  ): typeof org$bukkit$event$player$PlayerMoveEvent;
  type(
    classname: "org.bukkit.event.player.PlayerPickupArrowEvent"
  ): typeof org$bukkit$event$player$PlayerPickupArrowEvent;
  type(
    classname: "org.bukkit.event.player.PlayerPickupItemEvent"
  ): typeof org$bukkit$event$player$PlayerPickupItemEvent;
  type(
    classname: "org.bukkit.event.player.PlayerPortalEvent"
  ): typeof org$bukkit$event$player$PlayerPortalEvent;
  type(
    classname: "org.bukkit.event.player.PlayerPreLoginEvent"
  ): typeof org$bukkit$event$player$PlayerPreLoginEvent;
  type(
    classname: "org.bukkit.event.player.PlayerQuitEvent"
  ): typeof org$bukkit$event$player$PlayerQuitEvent;
  type(
    classname: "org.bukkit.event.player.PlayerRecipeDiscoverEvent"
  ): typeof org$bukkit$event$player$PlayerRecipeDiscoverEvent;
  type(
    classname: "org.bukkit.event.player.PlayerRegisterChannelEvent"
  ): typeof org$bukkit$event$player$PlayerRegisterChannelEvent;
  type(
    classname: "org.bukkit.event.player.PlayerResourcePackStatusEvent"
  ): typeof org$bukkit$event$player$PlayerResourcePackStatusEvent;
  type(
    classname: "org.bukkit.event.player.PlayerRespawnEvent"
  ): typeof org$bukkit$event$player$PlayerRespawnEvent;
  type(
    classname: "org.bukkit.event.player.PlayerRiptideEvent"
  ): typeof org$bukkit$event$player$PlayerRiptideEvent;
  type(
    classname: "org.bukkit.event.player.PlayerShearEntityEvent"
  ): typeof org$bukkit$event$player$PlayerShearEntityEvent;
  type(
    classname: "org.bukkit.event.player.PlayerStatisticIncrementEvent"
  ): typeof org$bukkit$event$player$PlayerStatisticIncrementEvent;
  type(
    classname: "org.bukkit.event.player.PlayerSwapHandItemsEvent"
  ): typeof org$bukkit$event$player$PlayerSwapHandItemsEvent;
  type(
    classname: "org.bukkit.event.player.PlayerTakeLecternBookEvent"
  ): typeof org$bukkit$event$player$PlayerTakeLecternBookEvent;
  type(
    classname: "org.bukkit.event.player.PlayerTeleportEvent"
  ): typeof org$bukkit$event$player$PlayerTeleportEvent;
  type(
    classname: "org.bukkit.event.player.PlayerToggleFlightEvent"
  ): typeof org$bukkit$event$player$PlayerToggleFlightEvent;
  type(
    classname: "org.bukkit.event.player.PlayerToggleSneakEvent"
  ): typeof org$bukkit$event$player$PlayerToggleSneakEvent;
  type(
    classname: "org.bukkit.event.player.PlayerToggleSprintEvent"
  ): typeof org$bukkit$event$player$PlayerToggleSprintEvent;
  type(
    classname: "org.bukkit.event.player.PlayerUnleashEntityEvent"
  ): typeof org$bukkit$event$player$PlayerUnleashEntityEvent;
  type(
    classname: "org.bukkit.event.player.PlayerUnregisterChannelEvent"
  ): typeof org$bukkit$event$player$PlayerUnregisterChannelEvent;
  type(
    classname: "org.bukkit.event.player.PlayerVelocityEvent"
  ): typeof org$bukkit$event$player$PlayerVelocityEvent;
  type(
    classname: "org.bukkit.event.raid.RaidEvent"
  ): typeof org$bukkit$event$raid$RaidEvent;
  type(
    classname: "org.bukkit.event.raid.RaidFinishEvent"
  ): typeof org$bukkit$event$raid$RaidFinishEvent;
  type(
    classname: "org.bukkit.event.raid.RaidSpawnWaveEvent"
  ): typeof org$bukkit$event$raid$RaidSpawnWaveEvent;
  type(
    classname: "org.bukkit.event.raid.RaidStopEvent"
  ): typeof org$bukkit$event$raid$RaidStopEvent;
  type(
    classname: "org.bukkit.event.raid.RaidStopEvent$Reason"
  ): typeof org$bukkit$event$raid$RaidStopEvent$Reason;
  type(
    classname: "org.bukkit.event.raid.RaidTriggerEvent"
  ): typeof org$bukkit$event$raid$RaidTriggerEvent;
  type(
    classname: "org.bukkit.event.server.BroadcastMessageEvent"
  ): typeof org$bukkit$event$server$BroadcastMessageEvent;
  type(
    classname: "org.bukkit.event.server.MapInitializeEvent"
  ): typeof org$bukkit$event$server$MapInitializeEvent;
  type(
    classname: "org.bukkit.event.server.PluginDisableEvent"
  ): typeof org$bukkit$event$server$PluginDisableEvent;
  type(
    classname: "org.bukkit.event.server.PluginEnableEvent"
  ): typeof org$bukkit$event$server$PluginEnableEvent;
  type(
    classname: "org.bukkit.event.server.PluginEvent"
  ): typeof org$bukkit$event$server$PluginEvent;
  type(
    classname: "org.bukkit.event.server.RemoteServerCommandEvent"
  ): typeof org$bukkit$event$server$RemoteServerCommandEvent;
  type(
    classname: "org.bukkit.event.server.ServerCommandEvent"
  ): typeof org$bukkit$event$server$ServerCommandEvent;
  type(
    classname: "org.bukkit.event.server.ServerEvent"
  ): typeof org$bukkit$event$server$ServerEvent;
  type(
    classname: "org.bukkit.event.server.ServerListPingEvent"
  ): typeof org$bukkit$event$server$ServerListPingEvent;
  type(
    classname: "org.bukkit.event.server.ServerLoadEvent"
  ): typeof org$bukkit$event$server$ServerLoadEvent;
  type(
    classname: "org.bukkit.event.server.ServerLoadEvent$LoadType"
  ): typeof org$bukkit$event$server$ServerLoadEvent$LoadType;
  type(
    classname: "org.bukkit.event.server.ServiceEvent"
  ): typeof org$bukkit$event$server$ServiceEvent;
  type(
    classname: "org.bukkit.event.server.ServiceRegisterEvent"
  ): typeof org$bukkit$event$server$ServiceRegisterEvent;
  type(
    classname: "org.bukkit.event.server.ServiceUnregisterEvent"
  ): typeof org$bukkit$event$server$ServiceUnregisterEvent;
  type(
    classname: "org.bukkit.event.server.TabCompleteEvent"
  ): typeof org$bukkit$event$server$TabCompleteEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleBlockCollisionEvent"
  ): typeof org$bukkit$event$vehicle$VehicleBlockCollisionEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleCollisionEvent"
  ): typeof org$bukkit$event$vehicle$VehicleCollisionEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleCreateEvent"
  ): typeof org$bukkit$event$vehicle$VehicleCreateEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleDamageEvent"
  ): typeof org$bukkit$event$vehicle$VehicleDamageEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleDestroyEvent"
  ): typeof org$bukkit$event$vehicle$VehicleDestroyEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleEnterEvent"
  ): typeof org$bukkit$event$vehicle$VehicleEnterEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleEntityCollisionEvent"
  ): typeof org$bukkit$event$vehicle$VehicleEntityCollisionEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleEvent"
  ): typeof org$bukkit$event$vehicle$VehicleEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleExitEvent"
  ): typeof org$bukkit$event$vehicle$VehicleExitEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleMoveEvent"
  ): typeof org$bukkit$event$vehicle$VehicleMoveEvent;
  type(
    classname: "org.bukkit.event.vehicle.VehicleUpdateEvent"
  ): typeof org$bukkit$event$vehicle$VehicleUpdateEvent;
  type(
    classname: "org.bukkit.event.weather.LightningStrikeEvent"
  ): typeof org$bukkit$event$weather$LightningStrikeEvent;
  type(
    classname: "org.bukkit.event.weather.LightningStrikeEvent$Cause"
  ): typeof org$bukkit$event$weather$LightningStrikeEvent$Cause;
  type(
    classname: "org.bukkit.event.weather.ThunderChangeEvent"
  ): typeof org$bukkit$event$weather$ThunderChangeEvent;
  type(
    classname: "org.bukkit.event.weather.WeatherChangeEvent"
  ): typeof org$bukkit$event$weather$WeatherChangeEvent;
  type(
    classname: "org.bukkit.event.weather.WeatherEvent"
  ): typeof org$bukkit$event$weather$WeatherEvent;
  type(
    classname: "org.bukkit.event.world.ChunkEvent"
  ): typeof org$bukkit$event$world$ChunkEvent;
  type(
    classname: "org.bukkit.event.world.ChunkLoadEvent"
  ): typeof org$bukkit$event$world$ChunkLoadEvent;
  type(
    classname: "org.bukkit.event.world.ChunkPopulateEvent"
  ): typeof org$bukkit$event$world$ChunkPopulateEvent;
  type(
    classname: "org.bukkit.event.world.ChunkUnloadEvent"
  ): typeof org$bukkit$event$world$ChunkUnloadEvent;
  type(
    classname: "org.bukkit.event.world.LootGenerateEvent"
  ): typeof org$bukkit$event$world$LootGenerateEvent;
  type(
    classname: "org.bukkit.event.world.PortalCreateEvent"
  ): typeof org$bukkit$event$world$PortalCreateEvent;
  type(
    classname: "org.bukkit.event.world.PortalCreateEvent$CreateReason"
  ): typeof org$bukkit$event$world$PortalCreateEvent$CreateReason;
  type(
    classname: "org.bukkit.event.world.SpawnChangeEvent"
  ): typeof org$bukkit$event$world$SpawnChangeEvent;
  type(
    classname: "org.bukkit.event.world.StructureGrowEvent"
  ): typeof org$bukkit$event$world$StructureGrowEvent;
  type(
    classname: "org.bukkit.event.world.TimeSkipEvent"
  ): typeof org$bukkit$event$world$TimeSkipEvent;
  type(
    classname: "org.bukkit.event.world.TimeSkipEvent$SkipReason"
  ): typeof org$bukkit$event$world$TimeSkipEvent$SkipReason;
  type(
    classname: "org.bukkit.event.world.WorldEvent"
  ): typeof org$bukkit$event$world$WorldEvent;
  type(
    classname: "org.bukkit.event.world.WorldInitEvent"
  ): typeof org$bukkit$event$world$WorldInitEvent;
  type(
    classname: "org.bukkit.event.world.WorldLoadEvent"
  ): typeof org$bukkit$event$world$WorldLoadEvent;
  type(
    classname: "org.bukkit.event.world.WorldSaveEvent"
  ): typeof org$bukkit$event$world$WorldSaveEvent;
  type(
    classname: "org.bukkit.event.world.WorldUnloadEvent"
  ): typeof org$bukkit$event$world$WorldUnloadEvent;
  type(
    classname: "org.bukkit.generator.BlockPopulator"
  ): typeof org$bukkit$generator$BlockPopulator;
  type(
    classname: "org.bukkit.generator.ChunkGenerator$1"
  ): typeof org$bukkit$generator$ChunkGenerator$1;
  type(classname: "org.bukkit.GrassSpecies"): typeof org$bukkit$GrassSpecies;
  type(
    classname: "org.bukkit.help.GenericCommandHelpTopic"
  ): typeof org$bukkit$help$GenericCommandHelpTopic;
  type(
    classname: "org.bukkit.help.HelpTopicComparator"
  ): typeof org$bukkit$help$HelpTopicComparator;
  type(
    classname: "org.bukkit.help.HelpTopicComparator$TopicNameComparator"
  ): typeof org$bukkit$help$HelpTopicComparator$TopicNameComparator;
  type(
    classname: "org.bukkit.help.HelpTopicComparator$1"
  ): typeof org$bukkit$help$HelpTopicComparator$1;
  type(
    classname: "org.bukkit.help.IndexHelpTopic"
  ): typeof org$bukkit$help$IndexHelpTopic;
  type(
    classname: "org.bukkit.inventory.BeaconInventory"
  ): typeof org$bukkit$inventory$BeaconInventory;
  type(
    classname: "org.bukkit.inventory.BlastingRecipe"
  ): typeof org$bukkit$inventory$BlastingRecipe;
  type(
    classname: "org.bukkit.inventory.CampfireRecipe"
  ): typeof org$bukkit$inventory$CampfireRecipe;
  type(
    classname: "org.bukkit.inventory.CartographyInventory"
  ): typeof org$bukkit$inventory$CartographyInventory;
  type(
    classname: "org.bukkit.inventory.ComplexRecipe"
  ): typeof org$bukkit$inventory$ComplexRecipe;
  type(
    classname: "org.bukkit.inventory.CookingRecipe"
  ): typeof org$bukkit$inventory$CookingRecipe;
  type(
    classname: "org.bukkit.inventory.EnchantingInventory"
  ): typeof org$bukkit$inventory$EnchantingInventory;
  type(
    classname: "org.bukkit.inventory.FurnaceRecipe"
  ): typeof org$bukkit$inventory$FurnaceRecipe;
  type(
    classname: "org.bukkit.inventory.InventoryView$1"
  ): typeof org$bukkit$inventory$InventoryView$1;
  type(
    classname: "org.bukkit.inventory.LecternInventory"
  ): typeof org$bukkit$inventory$LecternInventory;
  type(
    classname: "org.bukkit.inventory.LoomInventory"
  ): typeof org$bukkit$inventory$LoomInventory;
  type(
    classname: "org.bukkit.inventory.meta.BannerMeta"
  ): typeof org$bukkit$inventory$meta$BannerMeta;
  type(
    classname: "org.bukkit.inventory.meta.BlockDataMeta"
  ): typeof org$bukkit$inventory$meta$BlockDataMeta;
  type(
    classname: "org.bukkit.inventory.meta.BlockStateMeta"
  ): typeof org$bukkit$inventory$meta$BlockStateMeta;
  type(
    classname: "org.bukkit.inventory.meta.CrossbowMeta"
  ): typeof org$bukkit$inventory$meta$CrossbowMeta;
  type(
    classname: "org.bukkit.inventory.meta.Damageable"
  ): typeof org$bukkit$inventory$meta$Damageable;
  type(
    classname: "org.bukkit.inventory.meta.EnchantmentStorageMeta"
  ): typeof org$bukkit$inventory$meta$EnchantmentStorageMeta;
  type(
    classname: "org.bukkit.inventory.meta.FireworkEffectMeta"
  ): typeof org$bukkit$inventory$meta$FireworkEffectMeta;
  type(
    classname: "org.bukkit.inventory.meta.KnowledgeBookMeta"
  ): typeof org$bukkit$inventory$meta$KnowledgeBookMeta;
  type(
    classname: "org.bukkit.inventory.meta.LeatherArmorMeta"
  ): typeof org$bukkit$inventory$meta$LeatherArmorMeta;
  type(
    classname: "org.bukkit.inventory.meta.MapMeta"
  ): typeof org$bukkit$inventory$meta$MapMeta;
  type(
    classname: "org.bukkit.inventory.meta.PotionMeta"
  ): typeof org$bukkit$inventory$meta$PotionMeta;
  type(
    classname: "org.bukkit.inventory.meta.Repairable"
  ): typeof org$bukkit$inventory$meta$Repairable;
  type(
    classname: "org.bukkit.inventory.meta.SkullMeta"
  ): typeof org$bukkit$inventory$meta$SkullMeta;
  type(
    classname: "org.bukkit.inventory.meta.SpawnEggMeta"
  ): typeof org$bukkit$inventory$meta$SpawnEggMeta;
  type(
    classname: "org.bukkit.inventory.meta.SuspiciousStewMeta"
  ): typeof org$bukkit$inventory$meta$SuspiciousStewMeta;
  type(
    classname: "org.bukkit.inventory.meta.tags.ItemTagType$PrimitiveTagType"
  ): typeof org$bukkit$inventory$meta$tags$ItemTagType$PrimitiveTagType;
  type(
    classname: "org.bukkit.inventory.meta.TropicalFishBucketMeta"
  ): typeof org$bukkit$inventory$meta$TropicalFishBucketMeta;
  type(
    classname: "org.bukkit.inventory.RecipeChoice$ExactChoice"
  ): typeof org$bukkit$inventory$RecipeChoice$ExactChoice;
  type(
    classname: "org.bukkit.inventory.RecipeChoice$MaterialChoice"
  ): typeof org$bukkit$inventory$RecipeChoice$MaterialChoice;
  type(
    classname: "org.bukkit.inventory.ShapedRecipe"
  ): typeof org$bukkit$inventory$ShapedRecipe;
  type(
    classname: "org.bukkit.inventory.ShapelessRecipe"
  ): typeof org$bukkit$inventory$ShapelessRecipe;
  type(
    classname: "org.bukkit.inventory.SmokingRecipe"
  ): typeof org$bukkit$inventory$SmokingRecipe;
  type(
    classname: "org.bukkit.inventory.StonecutterInventory"
  ): typeof org$bukkit$inventory$StonecutterInventory;
  type(
    classname: "org.bukkit.inventory.StonecuttingRecipe"
  ): typeof org$bukkit$inventory$StonecuttingRecipe;
  type(
    classname: "org.bukkit.loot.LootContext$Builder"
  ): typeof org$bukkit$loot$LootContext$Builder;
  type(
    classname: "org.bukkit.loot.LootTables"
  ): typeof org$bukkit$loot$LootTables;
  type(
    classname: "org.bukkit.map.MapPalette"
  ): typeof org$bukkit$map$MapPalette;
  type(
    classname: "org.bukkit.map.MinecraftFont"
  ): typeof org$bukkit$map$MinecraftFont;
  type(
    classname: "org.bukkit.material.Banner"
  ): typeof org$bukkit$material$Banner;
  type(
    classname: "org.bukkit.material.Banner$1"
  ): typeof org$bukkit$material$Banner$1;
  type(classname: "org.bukkit.material.Bed"): typeof org$bukkit$material$Bed;
  type(
    classname: "org.bukkit.material.Bed$1"
  ): typeof org$bukkit$material$Bed$1;
  type(
    classname: "org.bukkit.material.Button"
  ): typeof org$bukkit$material$Button;
  type(
    classname: "org.bukkit.material.Redstone"
  ): typeof org$bukkit$material$Redstone;
  type(
    classname: "org.bukkit.material.SimpleAttachableMaterialData"
  ): typeof org$bukkit$material$SimpleAttachableMaterialData;
  type(
    classname: "org.bukkit.material.Button$1"
  ): typeof org$bukkit$material$Button$1;
  type(classname: "org.bukkit.material.Cake"): typeof org$bukkit$material$Cake;
  type(
    classname: "org.bukkit.material.Cauldron"
  ): typeof org$bukkit$material$Cauldron;
  type(
    classname: "org.bukkit.material.Chest"
  ): typeof org$bukkit$material$Chest;
  type(
    classname: "org.bukkit.material.DirectionalContainer"
  ): typeof org$bukkit$material$DirectionalContainer;
  type(classname: "org.bukkit.material.Coal"): typeof org$bukkit$material$Coal;
  type(
    classname: "org.bukkit.material.CocoaPlant"
  ): typeof org$bukkit$material$CocoaPlant;
  type(
    classname: "org.bukkit.material.CocoaPlant$CocoaPlantSize"
  ): typeof org$bukkit$material$CocoaPlant$CocoaPlantSize;
  type(
    classname: "org.bukkit.material.CocoaPlant$1"
  ): typeof org$bukkit$material$CocoaPlant$1;
  type(
    classname: "org.bukkit.material.Command"
  ): typeof org$bukkit$material$Command;
  type(
    classname: "org.bukkit.material.Comparator"
  ): typeof org$bukkit$material$Comparator;
  type(
    classname: "org.bukkit.material.Comparator$1"
  ): typeof org$bukkit$material$Comparator$1;
  type(
    classname: "org.bukkit.material.Crops"
  ): typeof org$bukkit$material$Crops;
  type(
    classname: "org.bukkit.material.Crops$1"
  ): typeof org$bukkit$material$Crops$1;
  type(
    classname: "org.bukkit.material.DetectorRail"
  ): typeof org$bukkit$material$DetectorRail;
  type(
    classname: "org.bukkit.material.PressureSensor"
  ): typeof org$bukkit$material$PressureSensor;
  type(
    classname: "org.bukkit.material.ExtendedRails"
  ): typeof org$bukkit$material$ExtendedRails;
  type(
    classname: "org.bukkit.material.Rails"
  ): typeof org$bukkit$material$Rails;
  type(
    classname: "org.bukkit.material.Diode"
  ): typeof org$bukkit$material$Diode;
  type(
    classname: "org.bukkit.material.Diode$1"
  ): typeof org$bukkit$material$Diode$1;
  type(
    classname: "org.bukkit.material.DirectionalContainer$1"
  ): typeof org$bukkit$material$DirectionalContainer$1;
  type(
    classname: "org.bukkit.material.Dispenser"
  ): typeof org$bukkit$material$Dispenser;
  type(
    classname: "org.bukkit.material.FurnaceAndDispenser"
  ): typeof org$bukkit$material$FurnaceAndDispenser;
  type(
    classname: "org.bukkit.material.Dispenser$1"
  ): typeof org$bukkit$material$Dispenser$1;
  type(classname: "org.bukkit.material.Door"): typeof org$bukkit$material$Door;
  type(
    classname: "org.bukkit.material.Openable"
  ): typeof org$bukkit$material$Openable;
  type(
    classname: "org.bukkit.material.Door$1"
  ): typeof org$bukkit$material$Door$1;
  type(classname: "org.bukkit.material.Dye"): typeof org$bukkit$material$Dye;
  type(
    classname: "org.bukkit.material.EnderChest"
  ): typeof org$bukkit$material$EnderChest;
  type(
    classname: "org.bukkit.material.FlowerPot"
  ): typeof org$bukkit$material$FlowerPot;
  type(
    classname: "org.bukkit.material.Furnace"
  ): typeof org$bukkit$material$Furnace;
  type(classname: "org.bukkit.material.Gate"): typeof org$bukkit$material$Gate;
  type(
    classname: "org.bukkit.material.Gate$1"
  ): typeof org$bukkit$material$Gate$1;
  type(
    classname: "org.bukkit.material.Hopper"
  ): typeof org$bukkit$material$Hopper;
  type(
    classname: "org.bukkit.material.Hopper$1"
  ): typeof org$bukkit$material$Hopper$1;
  type(
    classname: "org.bukkit.material.Ladder"
  ): typeof org$bukkit$material$Ladder;
  type(
    classname: "org.bukkit.material.Ladder$1"
  ): typeof org$bukkit$material$Ladder$1;
  type(
    classname: "org.bukkit.material.Leaves"
  ): typeof org$bukkit$material$Leaves;
  type(classname: "org.bukkit.material.Wood"): typeof org$bukkit$material$Wood;
  type(
    classname: "org.bukkit.material.Lever"
  ): typeof org$bukkit$material$Lever;
  type(
    classname: "org.bukkit.material.Lever$1"
  ): typeof org$bukkit$material$Lever$1;
  type(
    classname: "org.bukkit.material.LongGrass"
  ): typeof org$bukkit$material$LongGrass;
  type(
    classname: "org.bukkit.material.MonsterEggs"
  ): typeof org$bukkit$material$MonsterEggs;
  type(
    classname: "org.bukkit.material.TexturedMaterial"
  ): typeof org$bukkit$material$TexturedMaterial;
  type(
    classname: "org.bukkit.material.Mushroom"
  ): typeof org$bukkit$material$Mushroom;
  type(
    classname: "org.bukkit.material.types.MushroomBlockTexture"
  ): typeof org$bukkit$material$types$MushroomBlockTexture;
  type(
    classname: "org.bukkit.material.Mushroom$1"
  ): typeof org$bukkit$material$Mushroom$1;
  type(
    classname: "org.bukkit.material.NetherWarts"
  ): typeof org$bukkit$material$NetherWarts;
  type(
    classname: "org.bukkit.NetherWartsState"
  ): typeof org$bukkit$NetherWartsState;
  type(
    classname: "org.bukkit.material.NetherWarts$1"
  ): typeof org$bukkit$material$NetherWarts$1;
  type(
    classname: "org.bukkit.material.Observer"
  ): typeof org$bukkit$material$Observer;
  type(
    classname: "org.bukkit.material.Observer$1"
  ): typeof org$bukkit$material$Observer$1;
  type(
    classname: "org.bukkit.material.PistonBaseMaterial"
  ): typeof org$bukkit$material$PistonBaseMaterial;
  type(
    classname: "org.bukkit.material.PistonBaseMaterial$1"
  ): typeof org$bukkit$material$PistonBaseMaterial$1;
  type(
    classname: "org.bukkit.material.PistonExtensionMaterial"
  ): typeof org$bukkit$material$PistonExtensionMaterial;
  type(
    classname: "org.bukkit.material.PistonExtensionMaterial$1"
  ): typeof org$bukkit$material$PistonExtensionMaterial$1;
  type(
    classname: "org.bukkit.material.PoweredRail"
  ): typeof org$bukkit$material$PoweredRail;
  type(
    classname: "org.bukkit.material.PressurePlate"
  ): typeof org$bukkit$material$PressurePlate;
  type(
    classname: "org.bukkit.material.Pumpkin"
  ): typeof org$bukkit$material$Pumpkin;
  type(
    classname: "org.bukkit.material.Pumpkin$1"
  ): typeof org$bukkit$material$Pumpkin$1;
  type(
    classname: "org.bukkit.material.Rails$1"
  ): typeof org$bukkit$material$Rails$1;
  type(
    classname: "org.bukkit.material.RedstoneTorch"
  ): typeof org$bukkit$material$RedstoneTorch;
  type(
    classname: "org.bukkit.material.Torch"
  ): typeof org$bukkit$material$Torch;
  type(
    classname: "org.bukkit.material.RedstoneWire"
  ): typeof org$bukkit$material$RedstoneWire;
  type(
    classname: "org.bukkit.material.Sandstone"
  ): typeof org$bukkit$material$Sandstone;
  type(classname: "org.bukkit.SandstoneType"): typeof org$bukkit$SandstoneType;
  type(
    classname: "org.bukkit.material.Sapling"
  ): typeof org$bukkit$material$Sapling;
  type(classname: "org.bukkit.material.Sign"): typeof org$bukkit$material$Sign;
  type(
    classname: "org.bukkit.material.Sign$1"
  ): typeof org$bukkit$material$Sign$1;
  type(
    classname: "org.bukkit.material.Skull"
  ): typeof org$bukkit$material$Skull;
  type(
    classname: "org.bukkit.material.Skull$1"
  ): typeof org$bukkit$material$Skull$1;
  type(
    classname: "org.bukkit.material.SmoothBrick"
  ): typeof org$bukkit$material$SmoothBrick;
  type(
    classname: "org.bukkit.material.SpawnEgg"
  ): typeof org$bukkit$material$SpawnEgg;
  type(
    classname: "org.bukkit.material.Stairs"
  ): typeof org$bukkit$material$Stairs;
  type(
    classname: "org.bukkit.material.Stairs$1"
  ): typeof org$bukkit$material$Stairs$1;
  type(classname: "org.bukkit.material.Step"): typeof org$bukkit$material$Step;
  type(
    classname: "org.bukkit.material.Torch$1"
  ): typeof org$bukkit$material$Torch$1;
  type(
    classname: "org.bukkit.material.TrapDoor"
  ): typeof org$bukkit$material$TrapDoor;
  type(
    classname: "org.bukkit.material.TrapDoor$1"
  ): typeof org$bukkit$material$TrapDoor$1;
  type(classname: "org.bukkit.material.Tree"): typeof org$bukkit$material$Tree;
  type(
    classname: "org.bukkit.material.Tree$1"
  ): typeof org$bukkit$material$Tree$1;
  type(
    classname: "org.bukkit.material.Tripwire"
  ): typeof org$bukkit$material$Tripwire;
  type(
    classname: "org.bukkit.material.TripwireHook"
  ): typeof org$bukkit$material$TripwireHook;
  type(
    classname: "org.bukkit.material.TripwireHook$1"
  ): typeof org$bukkit$material$TripwireHook$1;
  type(classname: "org.bukkit.material.Vine"): typeof org$bukkit$material$Vine;
  type(
    classname: "org.bukkit.material.Vine$1"
  ): typeof org$bukkit$material$Vine$1;
  type(
    classname: "org.bukkit.material.Wood$1"
  ): typeof org$bukkit$material$Wood$1;
  type(
    classname: "org.bukkit.material.WoodenStep"
  ): typeof org$bukkit$material$WoodenStep;
  type(classname: "org.bukkit.material.Wool"): typeof org$bukkit$material$Wool;
  type(classname: "org.bukkit.Material$1"): typeof org$bukkit$Material$1;
  type(
    classname: "org.bukkit.metadata.FixedMetadataValue"
  ): typeof org$bukkit$metadata$FixedMetadataValue;
  type(
    classname: "org.bukkit.metadata.LazyMetadataValue"
  ): typeof org$bukkit$metadata$LazyMetadataValue;
  type(
    classname: "org.bukkit.metadata.LazyMetadataValue$CacheStrategy"
  ): typeof org$bukkit$metadata$LazyMetadataValue$CacheStrategy;
  type(
    classname: "org.bukkit.metadata.MetadataConversionException"
  ): typeof org$bukkit$metadata$MetadataConversionException;
  type(
    classname: "org.bukkit.metadata.MetadataEvaluationException"
  ): typeof org$bukkit$metadata$MetadataEvaluationException;
  type(
    classname: "org.bukkit.metadata.MetadataStore"
  ): typeof org$bukkit$metadata$MetadataStore;
  type(
    classname: "org.bukkit.metadata.MetadataStoreBase"
  ): typeof org$bukkit$metadata$MetadataStoreBase;
  type(
    classname: "org.bukkit.metadata.MetadataValueAdapter"
  ): typeof org$bukkit$metadata$MetadataValueAdapter;
  type(
    classname: "org.bukkit.Particle$DustOptions"
  ): typeof org$bukkit$Particle$DustOptions;
  type(
    classname: "org.bukkit.permissions.PermissibleBase"
  ): typeof org$bukkit$permissions$PermissibleBase;
  type(
    classname: "org.bukkit.permissions.PermissibleBase$RemoveAttachmentRunnable"
  ): typeof org$bukkit$permissions$PermissibleBase$RemoveAttachmentRunnable;
  type(
    classname: "org.bukkit.permissions.PermissionAttachmentInfo"
  ): typeof org$bukkit$permissions$PermissionAttachmentInfo;
  type(
    classname: "org.bukkit.permissions.PermissionDefault$1"
  ): typeof org$bukkit$permissions$PermissionDefault$1;
  type(
    classname: "org.bukkit.persistence.PersistentDataType$PrimitivePersistentDataType"
  ): typeof org$bukkit$persistence$PersistentDataType$PrimitivePersistentDataType;
  type(
    classname: "org.bukkit.plugin.AuthorNagException"
  ): typeof org$bukkit$plugin$AuthorNagException;
  type(
    classname: "org.bukkit.plugin.EventExecutor$1"
  ): typeof org$bukkit$plugin$EventExecutor$1;
  type(
    classname: "org.bukkit.plugin.IllegalPluginAccessException"
  ): typeof org$bukkit$plugin$IllegalPluginAccessException;
  type(
    classname: "org.bukkit.plugin.InvalidDescriptionException"
  ): typeof org$bukkit$plugin$InvalidDescriptionException;
  type(
    classname: "org.bukkit.plugin.InvalidPluginException"
  ): typeof org$bukkit$plugin$InvalidPluginException;
  type(
    classname: "org.bukkit.plugin.java.JavaPlugin"
  ): typeof org$bukkit$plugin$java$JavaPlugin;
  type(
    classname: "org.bukkit.plugin.java.JavaPluginLoader"
  ): typeof org$bukkit$plugin$java$JavaPluginLoader;
  type(
    classname: "org.bukkit.plugin.java.PluginClassLoader"
  ): typeof org$bukkit$plugin$java$PluginClassLoader;
  type(
    classname: "org.bukkit.plugin.messaging.ChannelNameTooLongException"
  ): typeof org$bukkit$plugin$messaging$ChannelNameTooLongException;
  type(
    classname: "org.bukkit.plugin.messaging.ChannelNotRegisteredException"
  ): typeof org$bukkit$plugin$messaging$ChannelNotRegisteredException;
  type(
    classname: "org.bukkit.plugin.messaging.MessageTooLargeException"
  ): typeof org$bukkit$plugin$messaging$MessageTooLargeException;
  type(
    classname: "org.bukkit.plugin.messaging.PluginChannelDirection"
  ): typeof org$bukkit$plugin$messaging$PluginChannelDirection;
  type(
    classname: "org.bukkit.plugin.messaging.ReservedChannelException"
  ): typeof org$bukkit$plugin$messaging$ReservedChannelException;
  type(
    classname: "org.bukkit.plugin.messaging.StandardMessenger"
  ): typeof org$bukkit$plugin$messaging$StandardMessenger;
  type(
    classname: "org.bukkit.plugin.PluginAwareness"
  ): typeof org$bukkit$plugin$PluginAwareness;
  type(
    classname: "org.bukkit.plugin.PluginAwareness$Flags"
  ): typeof org$bukkit$plugin$PluginAwareness$Flags;
  type(
    classname: "org.bukkit.plugin.PluginBase"
  ): typeof org$bukkit$plugin$PluginBase;
  type(
    classname: "org.bukkit.plugin.PluginDescriptionFile$1"
  ): typeof org$bukkit$plugin$PluginDescriptionFile$1;
  type(
    classname: "org.bukkit.plugin.PluginDescriptionFile$1$1"
  ): typeof org$bukkit$plugin$PluginDescriptionFile$1$1;
  type(
    classname: "org.bukkit.plugin.PluginDescriptionFile$1$1$1"
  ): typeof org$bukkit$plugin$PluginDescriptionFile$1$1$1;
  type(
    classname: "org.bukkit.plugin.PluginDescriptionFile$1$1$1$1"
  ): typeof org$bukkit$plugin$PluginDescriptionFile$1$1$1$1;
  type(
    classname: "org.bukkit.plugin.PluginDescriptionFile$1$1$2"
  ): typeof org$bukkit$plugin$PluginDescriptionFile$1$1$2;
  type(
    classname: "org.bukkit.plugin.PluginLogger"
  ): typeof org$bukkit$plugin$PluginLogger;
  type(
    classname: "org.bukkit.plugin.SimplePluginManager"
  ): typeof org$bukkit$plugin$SimplePluginManager;
  type(
    classname: "com.google.common.graph.MutableGraph"
  ): typeof com$google$common$graph$MutableGraph;
  type(
    classname: "com.google.common.graph.Graph"
  ): typeof com$google$common$graph$Graph;
  type(
    classname: "com.google.common.graph.ElementOrder"
  ): typeof com$google$common$graph$ElementOrder;
  type(
    classname: "com.google.common.graph.ElementOrder$Type"
  ): typeof com$google$common$graph$ElementOrder$Type;
  type(
    classname: "org.bukkit.plugin.SimpleServicesManager"
  ): typeof org$bukkit$plugin$SimpleServicesManager;
  type(
    classname: "org.bukkit.plugin.TimedRegisteredListener"
  ): typeof org$bukkit$plugin$TimedRegisteredListener;
  type(
    classname: "org.bukkit.plugin.UnknownDependencyException"
  ): typeof org$bukkit$plugin$UnknownDependencyException;
  type(classname: "org.bukkit.potion.Potion"): typeof org$bukkit$potion$Potion;
  type(
    classname: "org.bukkit.potion.PotionBrewer"
  ): typeof org$bukkit$potion$PotionBrewer;
  type(
    classname: "org.bukkit.potion.PotionEffectTypeWrapper"
  ): typeof org$bukkit$potion$PotionEffectTypeWrapper;
  type(classname: "org.bukkit.Registry"): typeof org$bukkit$Registry;
  type(classname: "org.bukkit.Registry$1"): typeof org$bukkit$Registry$1;
  type(classname: "org.bukkit.Registry$2"): typeof org$bukkit$Registry$2;
  type(classname: "org.bukkit.Registry$3"): typeof org$bukkit$Registry$3;
  type(classname: "org.bukkit.Registry$4"): typeof org$bukkit$Registry$4;
  type(
    classname: "org.bukkit.Registry$SimpleRegistry"
  ): typeof org$bukkit$Registry$SimpleRegistry;
  type(
    classname: "org.bukkit.scheduler.BukkitWorker"
  ): typeof org$bukkit$scheduler$BukkitWorker;
  type(
    classname: "org.bukkit.scoreboard.Criterias"
  ): typeof org$bukkit$scoreboard$Criterias;
  type(
    classname: "org.bukkit.UndefinedNullability"
  ): typeof org$bukkit$UndefinedNullability;
  type(
    classname: "org.bukkit.util.BlockIterator"
  ): typeof org$bukkit$util$BlockIterator;
  type(
    classname: "org.bukkit.util.ChatPaginator"
  ): typeof org$bukkit$util$ChatPaginator;
  type(
    classname: "org.bukkit.util.ChatPaginator$ChatPage"
  ): typeof org$bukkit$util$ChatPaginator$ChatPage;
  type(classname: "org.bukkit.util.FileUtil"): typeof org$bukkit$util$FileUtil;
  type(
    classname: "org.bukkit.util.io.BukkitObjectInputStream"
  ): typeof org$bukkit$util$io$BukkitObjectInputStream;
  type(
    classname: "org.bukkit.util.io.BukkitObjectOutputStream"
  ): typeof org$bukkit$util$io$BukkitObjectOutputStream;
  type(
    classname: "org.bukkit.util.io.Wrapper"
  ): typeof org$bukkit$util$io$Wrapper;
  type(
    classname: "org.bukkit.util.noise.NoiseGenerator"
  ): typeof org$bukkit$util$noise$NoiseGenerator;
  type(
    classname: "org.bukkit.util.noise.OctaveGenerator"
  ): typeof org$bukkit$util$noise$OctaveGenerator;
  type(
    classname: "org.bukkit.util.noise.PerlinNoiseGenerator"
  ): typeof org$bukkit$util$noise$PerlinNoiseGenerator;
  type(
    classname: "org.bukkit.util.noise.PerlinOctaveGenerator"
  ): typeof org$bukkit$util$noise$PerlinOctaveGenerator;
  type(
    classname: "org.bukkit.util.noise.SimplexNoiseGenerator"
  ): typeof org$bukkit$util$noise$SimplexNoiseGenerator;
  type(
    classname: "org.bukkit.util.noise.SimplexOctaveGenerator"
  ): typeof org$bukkit$util$noise$SimplexOctaveGenerator;
  type(
    classname: "org.bukkit.util.NumberConversions"
  ): typeof org$bukkit$util$NumberConversions;
  type(
    classname: "org.bukkit.util.permissions.BroadcastPermissions"
  ): typeof org$bukkit$util$permissions$BroadcastPermissions;
  type(
    classname: "org.bukkit.util.permissions.CommandPermissions"
  ): typeof org$bukkit$util$permissions$CommandPermissions;
  type(
    classname: "org.bukkit.util.permissions.DefaultPermissions"
  ): typeof org$bukkit$util$permissions$DefaultPermissions;
  type(
    classname: "org.bukkit.util.StringUtil"
  ): typeof org$bukkit$util$StringUtil;
  type(classname: "org.bukkit.Utility"): typeof org$bukkit$Utility;
  type(
    classname: "org.spigotmc.CustomTimingsHandler"
  ): typeof org$spigotmc$CustomTimingsHandler;
  type(
    classname: "org.spigotmc.event.entity.EntityDismountEvent"
  ): typeof org$spigotmc$event$entity$EntityDismountEvent;
  type(
    classname: "org.spigotmc.event.entity.EntityMountEvent"
  ): typeof org$spigotmc$event$entity$EntityMountEvent;
  type(
    classname: "org.spigotmc.event.player.PlayerSpawnLocationEvent"
  ): typeof org$spigotmc$event$player$PlayerSpawnLocationEvent;
};

